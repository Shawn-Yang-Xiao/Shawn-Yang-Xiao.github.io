{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/robots.txt","hash":"be8d5ab7132ac74a9375439e438b00b8c91e50b4","modified":1680536989442},{"_id":"source/_posts/Induction.md","hash":"1b84904d91327dedf7e673e18e5be160c6467ada","modified":1681200798125},{"_id":"source/_posts/Introduction.md","hash":"ead447082a2f303adaac53b869b3c0864735a191","modified":1680527908189},{"_id":"source/_posts/Basics.md","hash":"4c3bb6c8634a7f6f873b554dd976df9f8deee2d3","modified":1681201850567},{"_id":"source/about/index.md","hash":"3c9b7a6853bfcdd019317c95f2aa33829b269cbc","modified":1680536989442},{"_id":"source/tags/index.md","hash":"f913370f50299b9b8b4cfd73fbdd5c07f4950549","modified":1680536989452},{"_id":"source/categories/index.md","hash":"62fe9cd3a09f7971c8bfb84f18ed7863f84cb30a","modified":1680536989442},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1680523481290},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1680523480460},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1680523480179},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1680523481185},{"_id":"themes/landscape/_config.yml","hash":"04d3b56669b5efb3b816a4b11e00ed5ae4dee4d9","modified":1681202072364},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1680523481262},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1680523481423},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1680523481415},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1680523481417},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1680523481428},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1680523481433},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1680523481430},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1680523481435},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1680523481438},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1680523481426},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1680523481442},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1680523481439},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1680523481444},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1680523480839},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1680523480921},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1680523480933},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1680523480958},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1680523480966},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1680523481023},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1680523481164},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1680523480701},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1680523480716},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1680523480798},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1680523480733},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1680523480861},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1680523480784},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1680523480882},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1680523480893},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1680523480904},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1680523480912},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1680523480940},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1680523480984},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1680523480763},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1680523480974},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1680523480828},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1680523481009},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1680523481030},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1680523481317},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1680523481320},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1680523481371},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1680523481064},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1680523481074},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1680523481090},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1680523481307},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1680523481310},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1680523481313},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1680523481241},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1680523480670},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1680523481245},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1680523481252},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1680523480814},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1680523480850},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1680523480997},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1680523480871},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1680523480949},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1680523481038},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1680523481328},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1680523481333},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1680523481330},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1680523481345},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1680523481337},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1680523481359},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1680523481362},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1680523481352},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1680523481368},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1680523481364},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1680523481342},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1680523481356},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1680523481301},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1680523481058},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1680523481396},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1680523481304},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1680523480593},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1680523481220},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1680523481227},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1680523481232},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1680523480624},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1680523481389},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1680523481382},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1680523481130},{"_id":"public/about/index.html","hash":"71ec2f841acc19c57cc5d4e2c0e25feaafa15056","modified":1681366691381},{"_id":"public/tags/index.html","hash":"7753290a81c55e39e1fb9bac370d51f4dade3cf2","modified":1681366691381},{"_id":"public/categories/index.html","hash":"2d0507a58e50d2deb1996ceede0164e1d2c4c7bb","modified":1681366691381},{"_id":"public/wiki/Induction/index.html","hash":"6bef1f869f8225e970da4663a617f1260529d7b7","modified":1681366691381},{"_id":"public/wiki/Basics/index.html","hash":"07eddc450de42fc426552dcc293388cb41034f41","modified":1681366691381},{"_id":"public/wiki/Introduction/index.html","hash":"2acdbab4170b079e9c73198ccde00a1195c5b4db","modified":1681366691381},{"_id":"public/archives/index.html","hash":"efb3e816cfb8a497217e5855968c9e8650792457","modified":1681366691381},{"_id":"public/archives/2023/index.html","hash":"b4e1d2f98ca010562f916258cc2ca7c244bdd89e","modified":1681366691381},{"_id":"public/archives/2023/04/index.html","hash":"b59ef765a185a6f14d9c9e1cab51c6e61b96540b","modified":1681366691381},{"_id":"public/index.html","hash":"29f8d24b8420998cac4389d231ef8f42024e22cc","modified":1681366691381},{"_id":"public/robots.txt","hash":"be8d5ab7132ac74a9375439e438b00b8c91e50b4","modified":1680540171429},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1680540171429},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1680540171429},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1680540171429},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1680540171429},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1680540171429},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1680540171429},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1680540171429},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1680540171429},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1680540171429},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1680540171429},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1680540171429},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1680540171429},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1680540171429},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1680540171429},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1680540171429},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1680540171429},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1680540171429},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1680540171429},{"_id":"public/css/style.css","hash":"3986ef4b1f56bf0ac3bc45aab261e0278794c3f1","modified":1680540171429},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1680540171429},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1680540171429},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1680540171429},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1680540171429},{"_id":"source/_posts/Sipser-Part-One.md","hash":"5d2569a79d9290054185d8a307bc217c63fc8ae6","modified":1681202055338},{"_id":"source/_posts/img/sipser_lec6_pic2.png","hash":"c4419680cfb79cef1b833ad7a262c92de05f662f","modified":1681180888743},{"_id":"source/_posts/img/sipser_lec6_pic1.png","hash":"78b126e8dd7652d882295ef3beebe3a14ad07591","modified":1681175993573},{"_id":"source/_posts/img/sipser_lec3_pic1.png","hash":"4e12d8fb925ddd9106250f55603353702fcabc46","modified":1681131196879},{"_id":"source/_posts/img/02-notation.png","hash":"9370ebfdd0157329d13d080f405b8e0e62475c86","modified":1680597595136},{"_id":"source/_posts/img/02-step_by_step_1.png","hash":"c0c6378dce7653846dea81922750b289fd84d7d3","modified":1680579041215},{"_id":"source/_posts/img/02-step_by_step_3.png","hash":"c47415deac49bbccf554cca427d1908a0ad87e5b","modified":1680579239282},{"_id":"source/_posts/img/02-step_by_step_2.png","hash":"798582954faa1b452b0ed263fca7f63c544f1dd2","modified":1680579101936},{"_id":"source/_posts/img/02-step_by_step_4.png","hash":"777b65e14dbebf98929418422fd80891d87c98c1","modified":1680579289849},{"_id":"public/wiki/Sipser-Part-One/index.html","hash":"c5a79726b644c3eee83ceb3e99e7d8742e64fd70","modified":1681366691381},{"_id":"source/_posts/Software-Foundations-04-Lists.md","hash":"e93f45978de8795ab50ad23fbb0d074de4cd417c","modified":1681201353960},{"_id":"source/_posts/Software-Foundations-05-Poly.md","hash":"69125940a186d2bdb07fcb1a62bf19fb819d0c5b","modified":1681201428170},{"_id":"source/_posts/Software-Foundations-06-Tactics.md","hash":"5011546fba4ac3fa91125cdf48026aa8423e5309","modified":1681201470923},{"_id":"public/wiki/Software-Foundations-06-Tactics/index.html","hash":"b4de2e09fa92b287da3bad1eb42738a9ee52f993","modified":1681366691381},{"_id":"public/wiki/Software-Foundations-05-Poly/index.html","hash":"1d877342c6953cbfe38b7202abe1b2081849dcd9","modified":1681366691381},{"_id":"public/wiki/Software-Foundations-04-Lists/index.html","hash":"3edca8434a66438c243a07c2665da15d35630096","modified":1681366691381},{"_id":"source/_posts/Sipser-Part-One/sipser_lec3_pic1.png","hash":"4e12d8fb925ddd9106250f55603353702fcabc46","modified":1681131196879},{"_id":"source/_posts/Sipser-Part-One/sipser_lec6_pic2.png","hash":"c4419680cfb79cef1b833ad7a262c92de05f662f","modified":1681180888743},{"_id":"source/_posts/Sipser-Part-One/sipser_lec6_pic1.png","hash":"78b126e8dd7652d882295ef3beebe3a14ad07591","modified":1681175993573},{"_id":"source/_posts/Basics/02-notation.png","hash":"9370ebfdd0157329d13d080f405b8e0e62475c86","modified":1680597595136},{"_id":"source/_posts/Basics/02-step_by_step_1.png","hash":"c0c6378dce7653846dea81922750b289fd84d7d3","modified":1680579041215},{"_id":"source/_posts/Basics/02-step_by_step_2.png","hash":"798582954faa1b452b0ed263fca7f63c544f1dd2","modified":1680579101936},{"_id":"source/_posts/Basics/02-step_by_step_3.png","hash":"c47415deac49bbccf554cca427d1908a0ad87e5b","modified":1680579239282},{"_id":"source/_posts/Basics/02-step_by_step_4.png","hash":"777b65e14dbebf98929418422fd80891d87c98c1","modified":1680579289849},{"_id":"public/wiki/Sipser-Part-One/sipser_lec3_pic1.png","hash":"4e12d8fb925ddd9106250f55603353702fcabc46","modified":1681201871559},{"_id":"public/wiki/Sipser-Part-One/sipser_lec6_pic1.png","hash":"78b126e8dd7652d882295ef3beebe3a14ad07591","modified":1681201871559},{"_id":"public/wiki/Sipser-Part-One/sipser_lec6_pic2.png","hash":"c4419680cfb79cef1b833ad7a262c92de05f662f","modified":1681201871559},{"_id":"public/wiki/Basics/02-notation.png","hash":"9370ebfdd0157329d13d080f405b8e0e62475c86","modified":1681201871559},{"_id":"public/wiki/Basics/02-step_by_step_2.png","hash":"798582954faa1b452b0ed263fca7f63c544f1dd2","modified":1681201871559},{"_id":"public/wiki/Basics/02-step_by_step_3.png","hash":"c47415deac49bbccf554cca427d1908a0ad87e5b","modified":1681201871559},{"_id":"public/wiki/Basics/02-step_by_step_1.png","hash":"c0c6378dce7653846dea81922750b289fd84d7d3","modified":1681201871559},{"_id":"public/wiki/Basics/02-step_by_step_4.png","hash":"777b65e14dbebf98929418422fd80891d87c98c1","modified":1681201871559},{"_id":"source/_posts/UPenn-CIS-194-Haskell.md","hash":"fab83c36db172069347ecc81b28c802432590fae","modified":1681366681541},{"_id":"public/wiki/UPenn-CIS-194-Haskell/index.html","hash":"3f12facb930e41bddacbe711bb4d784bf18aff2f","modified":1681366691381}],"Category":[],"Data":[],"Page":[{"title":"About","layout":"page","_content":"\n","source":"about/index.md","raw":"title: \"About\"\nlayout: \"page\"\n---\n\n","date":"2023-04-03T15:49:49.442Z","updated":"2023-04-03T15:49:49.442Z","path":"about/index.html","comments":1,"_id":"clg1287jp0000x8mv2x77decv","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n","date":"2023-04-03T15:49:49.452Z","updated":"2023-04-03T15:49:49.452Z","path":"tags/index.html","comments":1,"_id":"clg1287ju0002x8mvfqhz0m9v","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"title":"Categories","layout":"categories","_content":"","source":"categories/index.md","raw":"title: \"Categories\"\nlayout: \"categories\"\n---\n","date":"2023-04-03T15:49:49.442Z","updated":"2023-04-03T15:49:49.442Z","path":"categories/index.html","comments":1,"_id":"clg1287jw0004x8mvfkqhhokw","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"}],"Post":[{"layout":"[software-foundations] title: Introduction","date":"2023-04-03T12:57:48.000Z","_content":"\n# Software Foundations\n\n\n## Introduction\n\n### 03 Sources of Knowledge\nType System\n\nCompilers can automatically find errors.\n\nCompliers use deductive resoning to determine whether that are type errors.\nAnd human designer use deductive reasoning to prove that the type system is sound. (Well-typed programs don't go wrong.)\n\n<!--more-->\n\nThis may not be perfect:\n- For example, a type system maybe only strong enough to express function with integer input and output.\n- Maybe the system is not complete and cannot type some correct programs.\n- Maybe the system will fail at runtime because of typecasts.\n\nNonetheless, this is still widely accepted.\n\n\n### 04 The Software Crisis\n\nLarge systems become disastrous.\n\nPossible solution: Software Engineering.\n\nDijkstra present his programming methodology --> formal methods.\n\n### 05 Formal methods\n\nEmphasize logic and proof. \nFormal specifications + proofs about programs + machine checking.\n\nFoundations of mathematics\n- Godel's First Incompleteness Theorem\n- The Halting Problem\n- Rice's Theorem: Every property of a program is undecidable.\n\nBut formal methods are still useful and profitable.\n\n### 06 Coq\n\n'Interactive Theorem Proving and Program Development'\n\nType Theory (improve upon Set Theory)\n\nCoq is implemented in OCaml.\n\nCalculus of inductive constructions, better suited to reasoning about data structures.\n\nCoq features\n- **Define** computable functions and logical predicates.\n- **State** mathematical theorems and software specifications.\n- **Develop** formal proofs of theorems, interactively.\n- **Machine-check** those proofs.\n- **Extract** verified programs of OCaml, Haskell, Scheme.\n\n<!-- insert PPT P25 -->\n\n### 07 Three Recent Great Works in Formal Verification\n\nCompCert, written in Coq, has not be found any bug.\nseL4, written in Isabelle/HOL & Haskell, verifies an operating system microkernel.\nFiat Crypography verified implementations of elliptic curve cryptography algorithms.\n\n### 08 7+1 Myths\n\nFormal methods are controversial.\n\n\n1. Formal methods guarantee that software is perfect --> better.\n2. Formal methods is all about theorem proving. --> Specification comes first, then proof's about programs.\n3. Formal methods are only useful for safety-critical systems. --> Also useful in compilers, operating systems, web browser kernels, machine learning systems, distributedd systems etc.\n4. Formal methods require highly trained mathematicians. --> Can be mastered by most students.\n5. Formal methods increase the cost of software development. --> Hall claims that they decreased the cost.\n6. Formal methods are unacceptable to clients. --> They can be explained to clients.\n7. Formal methods are not used on real, large-scale software. --> Formal methods are being used on real, large-scale software.\n\n\"Formal methods are highly addictive.\"\n\n\n\n\n\n","source":"_posts/Introduction.md","raw":"---\nlayout: '[software-foundations] title: Introduction'\ndate: 2023-04-03 20:57:48\ntags:\n---\n\n# Software Foundations\n\n\n## Introduction\n\n### 03 Sources of Knowledge\nType System\n\nCompilers can automatically find errors.\n\nCompliers use deductive resoning to determine whether that are type errors.\nAnd human designer use deductive reasoning to prove that the type system is sound. (Well-typed programs don't go wrong.)\n\n<!--more-->\n\nThis may not be perfect:\n- For example, a type system maybe only strong enough to express function with integer input and output.\n- Maybe the system is not complete and cannot type some correct programs.\n- Maybe the system will fail at runtime because of typecasts.\n\nNonetheless, this is still widely accepted.\n\n\n### 04 The Software Crisis\n\nLarge systems become disastrous.\n\nPossible solution: Software Engineering.\n\nDijkstra present his programming methodology --> formal methods.\n\n### 05 Formal methods\n\nEmphasize logic and proof. \nFormal specifications + proofs about programs + machine checking.\n\nFoundations of mathematics\n- Godel's First Incompleteness Theorem\n- The Halting Problem\n- Rice's Theorem: Every property of a program is undecidable.\n\nBut formal methods are still useful and profitable.\n\n### 06 Coq\n\n'Interactive Theorem Proving and Program Development'\n\nType Theory (improve upon Set Theory)\n\nCoq is implemented in OCaml.\n\nCalculus of inductive constructions, better suited to reasoning about data structures.\n\nCoq features\n- **Define** computable functions and logical predicates.\n- **State** mathematical theorems and software specifications.\n- **Develop** formal proofs of theorems, interactively.\n- **Machine-check** those proofs.\n- **Extract** verified programs of OCaml, Haskell, Scheme.\n\n<!-- insert PPT P25 -->\n\n### 07 Three Recent Great Works in Formal Verification\n\nCompCert, written in Coq, has not be found any bug.\nseL4, written in Isabelle/HOL & Haskell, verifies an operating system microkernel.\nFiat Crypography verified implementations of elliptic curve cryptography algorithms.\n\n### 08 7+1 Myths\n\nFormal methods are controversial.\n\n\n1. Formal methods guarantee that software is perfect --> better.\n2. Formal methods is all about theorem proving. --> Specification comes first, then proof's about programs.\n3. Formal methods are only useful for safety-critical systems. --> Also useful in compilers, operating systems, web browser kernels, machine learning systems, distributedd systems etc.\n4. Formal methods require highly trained mathematicians. --> Can be mastered by most students.\n5. Formal methods increase the cost of software development. --> Hall claims that they decreased the cost.\n6. Formal methods are unacceptable to clients. --> They can be explained to clients.\n7. Formal methods are not used on real, large-scale software. --> Formal methods are being used on real, large-scale software.\n\n\"Formal methods are highly addictive.\"\n\n\n\n\n\n","slug":"Introduction","published":1,"updated":"2023-04-03T13:18:28.189Z","title":"","comments":1,"photos":[],"link":"","_id":"clg1287jr0001x8mv2a08hdxd","content":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<h2 id=\"introduction\">Introduction</h2>\r\n<h3 id=\"sources-of-knowledge\">03 Sources of Knowledge</h3>\r\n<p>Type System</p>\r\n<p>Compilers can automatically find errors.</p>\r\n<p>Compliers use deductive resoning to determine whether that are type\r\nerrors. And human designer use deductive reasoning to prove that the\r\ntype system is sound. (Well-typed programs don't go wrong.)</p>\r\n<span id=\"more\"></span>\r\n<p>This may not be perfect: - For example, a type system maybe only\r\nstrong enough to express function with integer input and output. - Maybe\r\nthe system is not complete and cannot type some correct programs. -\r\nMaybe the system will fail at runtime because of typecasts.</p>\r\n<p>Nonetheless, this is still widely accepted.</p>\r\n<h3 id=\"the-software-crisis\">04 The Software Crisis</h3>\r\n<p>Large systems become disastrous.</p>\r\n<p>Possible solution: Software Engineering.</p>\r\n<p>Dijkstra present his programming methodology --&gt; formal\r\nmethods.</p>\r\n<h3 id=\"formal-methods\">05 Formal methods</h3>\r\n<p>Emphasize logic and proof. Formal specifications + proofs about\r\nprograms + machine checking.</p>\r\n<p>Foundations of mathematics - Godel's First Incompleteness Theorem -\r\nThe Halting Problem - Rice's Theorem: Every property of a program is\r\nundecidable.</p>\r\n<p>But formal methods are still useful and profitable.</p>\r\n<h3 id=\"coq\">06 Coq</h3>\r\n<p>'Interactive Theorem Proving and Program Development'</p>\r\n<p>Type Theory (improve upon Set Theory)</p>\r\n<p>Coq is implemented in OCaml.</p>\r\n<p>Calculus of inductive constructions, better suited to reasoning about\r\ndata structures.</p>\r\n<p>Coq features - <strong>Define</strong> computable functions and\r\nlogical predicates. - <strong>State</strong> mathematical theorems and\r\nsoftware specifications. - <strong>Develop</strong> formal proofs of\r\ntheorems, interactively. - <strong>Machine-check</strong> those proofs.\r\n- <strong>Extract</strong> verified programs of OCaml, Haskell,\r\nScheme.</p>\r\n<!-- insert PPT P25 -->\r\n<h3 id=\"three-recent-great-works-in-formal-verification\">07 Three Recent\r\nGreat Works in Formal Verification</h3>\r\n<p>CompCert, written in Coq, has not be found any bug. seL4, written in\r\nIsabelle/HOL &amp; Haskell, verifies an operating system microkernel.\r\nFiat Crypography verified implementations of elliptic curve cryptography\r\nalgorithms.</p>\r\n<h3 id=\"myths\">08 7+1 Myths</h3>\r\n<p>Formal methods are controversial.</p>\r\n<ol type=\"1\">\r\n<li>Formal methods guarantee that software is perfect --&gt;\r\nbetter.</li>\r\n<li>Formal methods is all about theorem proving. --&gt; Specification\r\ncomes first, then proof's about programs.</li>\r\n<li>Formal methods are only useful for safety-critical systems. --&gt;\r\nAlso useful in compilers, operating systems, web browser kernels,\r\nmachine learning systems, distributedd systems etc.</li>\r\n<li>Formal methods require highly trained mathematicians. --&gt; Can be\r\nmastered by most students.</li>\r\n<li>Formal methods increase the cost of software development. --&gt;\r\nHall claims that they decreased the cost.</li>\r\n<li>Formal methods are unacceptable to clients. --&gt; They can be\r\nexplained to clients.</li>\r\n<li>Formal methods are not used on real, large-scale software. --&gt;\r\nFormal methods are being used on real, large-scale software.</li>\r\n</ol>\r\n<p>\"Formal methods are highly addictive.\"</p>\r\n","site":{"data":{}},"excerpt":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<h2 id=\"introduction\">Introduction</h2>\r\n<h3 id=\"sources-of-knowledge\">03 Sources of Knowledge</h3>\r\n<p>Type System</p>\r\n<p>Compilers can automatically find errors.</p>\r\n<p>Compliers use deductive resoning to determine whether that are type\r\nerrors. And human designer use deductive reasoning to prove that the\r\ntype system is sound. (Well-typed programs don't go wrong.)</p>","more":"<p>This may not be perfect: - For example, a type system maybe only\r\nstrong enough to express function with integer input and output. - Maybe\r\nthe system is not complete and cannot type some correct programs. -\r\nMaybe the system will fail at runtime because of typecasts.</p>\r\n<p>Nonetheless, this is still widely accepted.</p>\r\n<h3 id=\"the-software-crisis\">04 The Software Crisis</h3>\r\n<p>Large systems become disastrous.</p>\r\n<p>Possible solution: Software Engineering.</p>\r\n<p>Dijkstra present his programming methodology --&gt; formal\r\nmethods.</p>\r\n<h3 id=\"formal-methods\">05 Formal methods</h3>\r\n<p>Emphasize logic and proof. Formal specifications + proofs about\r\nprograms + machine checking.</p>\r\n<p>Foundations of mathematics - Godel's First Incompleteness Theorem -\r\nThe Halting Problem - Rice's Theorem: Every property of a program is\r\nundecidable.</p>\r\n<p>But formal methods are still useful and profitable.</p>\r\n<h3 id=\"coq\">06 Coq</h3>\r\n<p>'Interactive Theorem Proving and Program Development'</p>\r\n<p>Type Theory (improve upon Set Theory)</p>\r\n<p>Coq is implemented in OCaml.</p>\r\n<p>Calculus of inductive constructions, better suited to reasoning about\r\ndata structures.</p>\r\n<p>Coq features - <strong>Define</strong> computable functions and\r\nlogical predicates. - <strong>State</strong> mathematical theorems and\r\nsoftware specifications. - <strong>Develop</strong> formal proofs of\r\ntheorems, interactively. - <strong>Machine-check</strong> those proofs.\r\n- <strong>Extract</strong> verified programs of OCaml, Haskell,\r\nScheme.</p>\r\n<!-- insert PPT P25 -->\r\n<h3 id=\"three-recent-great-works-in-formal-verification\">07 Three Recent\r\nGreat Works in Formal Verification</h3>\r\n<p>CompCert, written in Coq, has not be found any bug. seL4, written in\r\nIsabelle/HOL &amp; Haskell, verifies an operating system microkernel.\r\nFiat Crypography verified implementations of elliptic curve cryptography\r\nalgorithms.</p>\r\n<h3 id=\"myths\">08 7+1 Myths</h3>\r\n<p>Formal methods are controversial.</p>\r\n<ol type=\"1\">\r\n<li>Formal methods guarantee that software is perfect --&gt;\r\nbetter.</li>\r\n<li>Formal methods is all about theorem proving. --&gt; Specification\r\ncomes first, then proof's about programs.</li>\r\n<li>Formal methods are only useful for safety-critical systems. --&gt;\r\nAlso useful in compilers, operating systems, web browser kernels,\r\nmachine learning systems, distributedd systems etc.</li>\r\n<li>Formal methods require highly trained mathematicians. --&gt; Can be\r\nmastered by most students.</li>\r\n<li>Formal methods increase the cost of software development. --&gt;\r\nHall claims that they decreased the cost.</li>\r\n<li>Formal methods are unacceptable to clients. --&gt; They can be\r\nexplained to clients.</li>\r\n<li>Formal methods are not used on real, large-scale software. --&gt;\r\nFormal methods are being used on real, large-scale software.</li>\r\n</ol>\r\n<p>\"Formal methods are highly addictive.\"</p>"},{"layout":"[software-foundations] title: Basics","date":"2023-04-03T13:04:31.000Z","_content":"\n# Software Foundations\n\n[Online Textbook](https://softwarefoundations.cis.upenn.edu/lf-current/index.html)\n\n[Michael Clarkson's Open Online Course (on Youtube)](https://www.youtube.com/watch?v=BGg-gxhsV4E)\n[Michael Charkson's Course (on Bilibili)](https://www.bilibili.com/video/BV1kd4y1t7bw/)\n\n[Xiong Yingfei's Course Webpage (2023 Spring)](https://xiongyingfei.github.io/SF/2023/lectures.html)\n\nThis note is used as a brief summary and supplementofr the textbook and courses.\n\n\n## Basics\n\n### Enumerated Types\n\n```Coq\nInductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday.\n```\n\n<!--more-->\n\n```Coq\nDefinition next_weekday (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end.\n```\n\nThen we can do the computation.\n```Coq\nCompute (next_weekday friday).\n(* ==> monday : day *)\n```\n\nNote that pattern-machine needs to be exhaustive, and cannot be redundant.\n\nFor example:\n\n```Coq\nDefinition to_monday (d:day) : day := \n  match d with\n  | monday => monday\n  | tuesday => monday\n  end.\n(** [messages window]\n    Non exhaustive pattern-matching: no clause found for pattern\n    wednesday *)\n```\n\n```Coq\nDefinition to_monday (d:day) : day := \n  match d with\n  | monday => monday\n  | _ => monday\n  | sunday => monday\n  end.\n(** [messages window]\n    Pattern \"sunday\" is redundant in this clause. *)\n```\n\n### Function Call\nFunction call in Coq is by tapping the space bar, like `f a`, it is left associative (that is to say `f a b` is equal to `(f a) b`), and is with nearly the highest priority (i.e. `f a + b` is equal to `(f a) + b`).\n\n### Equality\nThere are two notions of equality in Coq: the equals operator and the equals question mark operator.\n- The equals operator is a logical claim, means something we try to prove. Currently we only use this .\n- The equals question mark operator is an expression that Coq computes. Notation `x=?y`, `x<=?y` use question to denote that this returns a boolean variable. \n\n### Theory Proof\n\nTheory proof is the core of Coq, and it is with the form:\n\n```Coq\nExample test_next_weekday:\n  (next_weekday (next_weekday saturday)) = tuesday.\n\nProof. simpl. reflexivity.  Qed.\n```\n\nOr we may proof `Lemma`, `Theorem`, etc. other than `Example`.\n\nIn the CoqIde, we can observe the proof process step by step with the help of 'Run  to curser' icon.\n\nTake the above proof process as an example:\n\n![](02-step_by_step_1.png)\n\n![](02-step_by_step_2.png)\n\n![](02-step_by_step_3.png)\n\n![](02-step_by_step_4.png)\n\n\n### Notation \n\nProgrammers can introduce new grammar rule.\n\n```Coq\nNotation \"x && y\" := (andb x y).\nNotation \"x || y\" := (orb x y).\n```\n![](02-notation.png)\n\n```Coq\nNotation \"x =? y\" := (eqb x y) (at level 70) : nat_scope.\nNotation \"x <=? y\" := (leb x y) (at level 70) : nat_scope.\n```\n\n### `if-then-else` in Coq\n\n`if-then-else`  in Coq is quite different than in other languages, as type bool is not inherented in Coq. \n\nIn Coq, `if` can be applied to any type with two constructors. If the condition variable is constrcted by the first, go to `then`, otherwise go to `else`.\n\n```Coq\nInductive nbool : Type :=\n  | first\n  | second.\n\nDefinition trans (t : nbool) : nbool :=\n  if t then second\n  else first.\n\nExample exp1 : trans first = second.\nProof. simpl. reflexivity. Qed.\n```\n\n### Check \n\nUsed to inspect the type of expressions. (variables and functions), for example: \n\n```Coq\nCheck true.\nCheck true : bool.\nCheck orb : bool -> bool -> bool.\n```\n\nbool $\\rightarrow$ bool means a function with input of a bool variable and output of a bool variable. (just like Haskell).\n$\\rightarrow$ is right associative.\n\n\n\n### Details of symbl. and reflexivity.\n\nCoq syntax\n1. Vernacular: Give commands to change what Coq is doing. Include `Check`, `Theorem`, `Proof`, `Qed` etc. \n2. Gallina: Functional programming language, write code and state theorem with this. Include `match`, `if`, `forall`.\n3. Ltac: Language for tactics, structure proofs into sections. Include `intros`, `simpl`, `reflexivity`, `destruct`.\n\nLambda calculus (Theoretical underpinning of functional programming). $e ::= x | \\lambda x . e | e_1 e_2$\n\nReduction tactics\n- `simpl.`: \"human readable\"\n- `cbn.`: call by name, try it if `simpl.` doesn't work.\n- `cbv.`: call by value, fully compute. Its result may be big and hard to read, unlike `simpl.`.\n\nGallina (more than $\\lambda$)\nDefinitions (delta reduction)\nInductive types, patter matching; recursion (iota reduction); Let bindings (zeta reduction)\n\n<!-- make this paragraph readable -->\n\n\n### Module System\n\n`Module` in Coq is like `namespace` in C++ and `package` in Java.\n\n### Natural Number\n\nDefinition of natural number\n\n```Coq\nInductive nat : Type :=\n  | O\n  | S (n : nat).\n```\n\nNote that number 0 is denoted by captial letter O.\n`S` represents `succ` in some other languages.\n\n### Recursive Function\n\nRecursive function is defined by keyword `Fixpoint`, i.e. \n\n```Coq\nFixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end.\n\n\nFixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end.\n```\n\nCoq only allows structural recursion.\n\n\n### `intros`\n\nIntroduce hypothesis including variable quantifiers and hypothesis (those before the right arrow).\n\n```Coq\nTheorem plus_id_example : forall n m:nat,\n  n = m ->\n  n + n = m + m.\n\nProof.\n  (* move both quantifiers into the context: *)\n  intros n m.\n  (* move the hypothesis into the context: *)\n  intros H.\n  (* rewrite the goal using the hypothesis: *)\n  rewrite -> H.\n  reflexivity.  Qed.\n```\n\nRight arrow and left arrow are different in `rewrite` expression.  In the above example, `n` is replaced by `m`, and in the following one, `(p * 0)` is replaced by `0`.\n\n```Coq\n(* mult_n_O ===> forall n : nat, 0 = n * 0 *)\n\nTheorem mult_n_0_m_0 : forall p q : nat,\n  (p * 0) + (q * 0) = 0.\n\nProof.\n  intros p q.\n  rewrite <- mult_n_O.\n  rewrite <- mult_n_O.\n  reflexivity. Qed.\n```\n\n### `destruct`\n\n\n\n```Coq\nTheorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.\n\nProof.\n  intros n. destruct n as [| n'] eqn:E.\n  - reflexivity.\n  - reflexivity.   Qed.\n```\n(`[| n']` is equal to `[O | S n']`)\n\nIn the proof process above, `destruct` divide it into two subgoals. The first is to prove that `(0 + 1 =? 0) = false`, the second is to prove that `(S n' + 1 =? 0) = false`. In the first subgoal, `eqn:E` name the hypothesis n=0 as E.\n\nTwo `reflexivity.` with a dash in front solves one subgoal, respectively.\n\nHere is another example of two variables need subgoal division. \n```Coq\nTheorem andb_commutative : forall b c, andb b c = andb c b.\nProof.\n  intros b c. destruct b eqn:Eb.\n  (* b = true *)\n  - destruct c eqn:Ec.\n    + reflexivity.  (* c = true *)\n    + reflexivity.  (* c = false *)\n  (* b = false *)\n  - destruct c eqn:Ec.\n    + reflexivity.  (* c = true *)\n    + reflexivity.  (* c = false *)\nQed.\n```\n\nBesides `+` and `-`, Coq also permits other notations, like braces.\n\n\n\n","source":"_posts/Basics.md","raw":"---\nlayout: '[software-foundations] title: Basics'\ndate: 2023-04-03 21:04:31\ntags:\n---\n\n# Software Foundations\n\n[Online Textbook](https://softwarefoundations.cis.upenn.edu/lf-current/index.html)\n\n[Michael Clarkson's Open Online Course (on Youtube)](https://www.youtube.com/watch?v=BGg-gxhsV4E)\n[Michael Charkson's Course (on Bilibili)](https://www.bilibili.com/video/BV1kd4y1t7bw/)\n\n[Xiong Yingfei's Course Webpage (2023 Spring)](https://xiongyingfei.github.io/SF/2023/lectures.html)\n\nThis note is used as a brief summary and supplementofr the textbook and courses.\n\n\n## Basics\n\n### Enumerated Types\n\n```Coq\nInductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday.\n```\n\n<!--more-->\n\n```Coq\nDefinition next_weekday (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end.\n```\n\nThen we can do the computation.\n```Coq\nCompute (next_weekday friday).\n(* ==> monday : day *)\n```\n\nNote that pattern-machine needs to be exhaustive, and cannot be redundant.\n\nFor example:\n\n```Coq\nDefinition to_monday (d:day) : day := \n  match d with\n  | monday => monday\n  | tuesday => monday\n  end.\n(** [messages window]\n    Non exhaustive pattern-matching: no clause found for pattern\n    wednesday *)\n```\n\n```Coq\nDefinition to_monday (d:day) : day := \n  match d with\n  | monday => monday\n  | _ => monday\n  | sunday => monday\n  end.\n(** [messages window]\n    Pattern \"sunday\" is redundant in this clause. *)\n```\n\n### Function Call\nFunction call in Coq is by tapping the space bar, like `f a`, it is left associative (that is to say `f a b` is equal to `(f a) b`), and is with nearly the highest priority (i.e. `f a + b` is equal to `(f a) + b`).\n\n### Equality\nThere are two notions of equality in Coq: the equals operator and the equals question mark operator.\n- The equals operator is a logical claim, means something we try to prove. Currently we only use this .\n- The equals question mark operator is an expression that Coq computes. Notation `x=?y`, `x<=?y` use question to denote that this returns a boolean variable. \n\n### Theory Proof\n\nTheory proof is the core of Coq, and it is with the form:\n\n```Coq\nExample test_next_weekday:\n  (next_weekday (next_weekday saturday)) = tuesday.\n\nProof. simpl. reflexivity.  Qed.\n```\n\nOr we may proof `Lemma`, `Theorem`, etc. other than `Example`.\n\nIn the CoqIde, we can observe the proof process step by step with the help of 'Run  to curser' icon.\n\nTake the above proof process as an example:\n\n![](02-step_by_step_1.png)\n\n![](02-step_by_step_2.png)\n\n![](02-step_by_step_3.png)\n\n![](02-step_by_step_4.png)\n\n\n### Notation \n\nProgrammers can introduce new grammar rule.\n\n```Coq\nNotation \"x && y\" := (andb x y).\nNotation \"x || y\" := (orb x y).\n```\n![](02-notation.png)\n\n```Coq\nNotation \"x =? y\" := (eqb x y) (at level 70) : nat_scope.\nNotation \"x <=? y\" := (leb x y) (at level 70) : nat_scope.\n```\n\n### `if-then-else` in Coq\n\n`if-then-else`  in Coq is quite different than in other languages, as type bool is not inherented in Coq. \n\nIn Coq, `if` can be applied to any type with two constructors. If the condition variable is constrcted by the first, go to `then`, otherwise go to `else`.\n\n```Coq\nInductive nbool : Type :=\n  | first\n  | second.\n\nDefinition trans (t : nbool) : nbool :=\n  if t then second\n  else first.\n\nExample exp1 : trans first = second.\nProof. simpl. reflexivity. Qed.\n```\n\n### Check \n\nUsed to inspect the type of expressions. (variables and functions), for example: \n\n```Coq\nCheck true.\nCheck true : bool.\nCheck orb : bool -> bool -> bool.\n```\n\nbool $\\rightarrow$ bool means a function with input of a bool variable and output of a bool variable. (just like Haskell).\n$\\rightarrow$ is right associative.\n\n\n\n### Details of symbl. and reflexivity.\n\nCoq syntax\n1. Vernacular: Give commands to change what Coq is doing. Include `Check`, `Theorem`, `Proof`, `Qed` etc. \n2. Gallina: Functional programming language, write code and state theorem with this. Include `match`, `if`, `forall`.\n3. Ltac: Language for tactics, structure proofs into sections. Include `intros`, `simpl`, `reflexivity`, `destruct`.\n\nLambda calculus (Theoretical underpinning of functional programming). $e ::= x | \\lambda x . e | e_1 e_2$\n\nReduction tactics\n- `simpl.`: \"human readable\"\n- `cbn.`: call by name, try it if `simpl.` doesn't work.\n- `cbv.`: call by value, fully compute. Its result may be big and hard to read, unlike `simpl.`.\n\nGallina (more than $\\lambda$)\nDefinitions (delta reduction)\nInductive types, patter matching; recursion (iota reduction); Let bindings (zeta reduction)\n\n<!-- make this paragraph readable -->\n\n\n### Module System\n\n`Module` in Coq is like `namespace` in C++ and `package` in Java.\n\n### Natural Number\n\nDefinition of natural number\n\n```Coq\nInductive nat : Type :=\n  | O\n  | S (n : nat).\n```\n\nNote that number 0 is denoted by captial letter O.\n`S` represents `succ` in some other languages.\n\n### Recursive Function\n\nRecursive function is defined by keyword `Fixpoint`, i.e. \n\n```Coq\nFixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end.\n\n\nFixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end.\n```\n\nCoq only allows structural recursion.\n\n\n### `intros`\n\nIntroduce hypothesis including variable quantifiers and hypothesis (those before the right arrow).\n\n```Coq\nTheorem plus_id_example : forall n m:nat,\n  n = m ->\n  n + n = m + m.\n\nProof.\n  (* move both quantifiers into the context: *)\n  intros n m.\n  (* move the hypothesis into the context: *)\n  intros H.\n  (* rewrite the goal using the hypothesis: *)\n  rewrite -> H.\n  reflexivity.  Qed.\n```\n\nRight arrow and left arrow are different in `rewrite` expression.  In the above example, `n` is replaced by `m`, and in the following one, `(p * 0)` is replaced by `0`.\n\n```Coq\n(* mult_n_O ===> forall n : nat, 0 = n * 0 *)\n\nTheorem mult_n_0_m_0 : forall p q : nat,\n  (p * 0) + (q * 0) = 0.\n\nProof.\n  intros p q.\n  rewrite <- mult_n_O.\n  rewrite <- mult_n_O.\n  reflexivity. Qed.\n```\n\n### `destruct`\n\n\n\n```Coq\nTheorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.\n\nProof.\n  intros n. destruct n as [| n'] eqn:E.\n  - reflexivity.\n  - reflexivity.   Qed.\n```\n(`[| n']` is equal to `[O | S n']`)\n\nIn the proof process above, `destruct` divide it into two subgoals. The first is to prove that `(0 + 1 =? 0) = false`, the second is to prove that `(S n' + 1 =? 0) = false`. In the first subgoal, `eqn:E` name the hypothesis n=0 as E.\n\nTwo `reflexivity.` with a dash in front solves one subgoal, respectively.\n\nHere is another example of two variables need subgoal division. \n```Coq\nTheorem andb_commutative : forall b c, andb b c = andb c b.\nProof.\n  intros b c. destruct b eqn:Eb.\n  (* b = true *)\n  - destruct c eqn:Ec.\n    + reflexivity.  (* c = true *)\n    + reflexivity.  (* c = false *)\n  (* b = false *)\n  - destruct c eqn:Ec.\n    + reflexivity.  (* c = true *)\n    + reflexivity.  (* c = false *)\nQed.\n```\n\nBesides `+` and `-`, Coq also permits other notations, like braces.\n\n\n\n","slug":"Basics","published":1,"updated":"2023-04-11T08:30:50.567Z","_id":"clg1287ju0003x8mv1apa5wk9","title":"","comments":1,"photos":[],"link":"","content":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<p><a\r\nhref=\"https://softwarefoundations.cis.upenn.edu/lf-current/index.html\">Online\r\nTextbook</a></p>\r\n<p><a href=\"https://www.youtube.com/watch?v=BGg-gxhsV4E\">Michael\r\nClarkson's Open Online Course (on Youtube)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1kd4y1t7bw/\">Michael Charkson's\r\nCourse (on Bilibili)</a></p>\r\n<p><a href=\"https://xiongyingfei.github.io/SF/2023/lectures.html\">Xiong\r\nYingfei's Course Webpage (2023 Spring)</a></p>\r\n<p>This note is used as a brief summary and supplementofr the textbook\r\nand courses.</p>\r\n<h2 id=\"basics\">Basics</h2>\r\n<h3 id=\"enumerated-types\">Enumerated Types</h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> day : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">monday</span></span><br><span class=\"line\">  | <span class=\"type\">tuesday</span></span><br><span class=\"line\">  | <span class=\"type\">wednesday</span></span><br><span class=\"line\">  | <span class=\"type\">thursday</span></span><br><span class=\"line\">  | <span class=\"type\">friday</span></span><br><span class=\"line\">  | <span class=\"type\">saturday</span></span><br><span class=\"line\">  | <span class=\"type\">sunday</span>.</span><br></pre></td></tr></table></figure>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> next_weekday (d:day) : day :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> d <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">monday</span>    =&gt; tuesday</span><br><span class=\"line\">  | <span class=\"type\">tuesday</span>   =&gt; wednesday</span><br><span class=\"line\">  | <span class=\"type\">wednesday</span> =&gt; thursday</span><br><span class=\"line\">  | <span class=\"type\">thursday</span>  =&gt; friday</span><br><span class=\"line\">  | <span class=\"type\">friday</span>    =&gt; monday</span><br><span class=\"line\">  | <span class=\"type\">saturday</span>  =&gt; monday</span><br><span class=\"line\">  | <span class=\"type\">sunday</span>    =&gt; monday</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure>\r\n<p>Then we can do the computation. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Compute</span> (next_weekday friday).</span><br><span class=\"line\"><span class=\"comment\">(* ==&gt; monday : day *)</span></span><br></pre></td></tr></table></figure></p>\r\n<p>Note that pattern-machine needs to be exhaustive, and cannot be\r\nredundant.</p>\r\n<p>For example:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> to_monday (d:day) : day := </span><br><span class=\"line\">  <span class=\"keyword\">match</span> d <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">monday</span> =&gt; monday</span><br><span class=\"line\">  | <span class=\"type\">tuesday</span> =&gt; monday</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"><span class=\"comment\">(** [messages window]</span></span><br><span class=\"line\"><span class=\"comment\">    Non exhaustive pattern-matching: no clause found for pattern</span></span><br><span class=\"line\"><span class=\"comment\">    wednesday *)</span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> to_monday (d:day) : day := </span><br><span class=\"line\">  <span class=\"keyword\">match</span> d <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">monday</span> =&gt; monday</span><br><span class=\"line\">  | <span class=\"type\">_</span> =&gt; monday</span><br><span class=\"line\">  | <span class=\"type\">sunday</span> =&gt; monday</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"><span class=\"comment\">(** [messages window]</span></span><br><span class=\"line\"><span class=\"comment\">    Pattern &quot;sunday&quot; is redundant in this clause. *)</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"function-call\">Function Call</h3>\r\n<p>Function call in Coq is by tapping the space bar, like\r\n<code>f a</code>, it is left associative (that is to say\r\n<code>f a b</code> is equal to <code>(f a) b</code>), and is with nearly\r\nthe highest priority (i.e. <code>f a + b</code> is equal to\r\n<code>(f a) + b</code>).</p>\r\n<h3 id=\"equality\">Equality</h3>\r\n<p>There are two notions of equality in Coq: the equals operator and the\r\nequals question mark operator. - The equals operator is a logical claim,\r\nmeans something we try to prove. Currently we only use this . - The\r\nequals question mark operator is an expression that Coq computes.\r\nNotation <code>x=?y</code>, <code>x&lt;=?y</code> use question to denote\r\nthat this returns a boolean variable.</p>\r\n<h3 id=\"theory-proof\">Theory Proof</h3>\r\n<p>Theory proof is the core of Coq, and it is with the form:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Example</span> test_next_weekday:</span><br><span class=\"line\">  (next_weekday (next_weekday saturday)) = tuesday.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"built_in\">simpl</span>. <span class=\"built_in\">reflexivity</span>.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>Or we may proof <code>Lemma</code>, <code>Theorem</code>, etc. other\r\nthan <code>Example</code>.</p>\r\n<p>In the CoqIde, we can observe the proof process step by step with the\r\nhelp of 'Run to curser' icon.</p>\r\n<p>Take the above proof process as an example:</p>\r\n<p><img src=\"02-step_by_step_1.png\" /></p>\r\n<p><img src=\"02-step_by_step_2.png\" /></p>\r\n<p><img src=\"02-step_by_step_3.png\" /></p>\r\n<p><img src=\"02-step_by_step_4.png\" /></p>\r\n<h3 id=\"notation\">Notation</h3>\r\n<p>Programmers can introduce new grammar rule.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x &amp;&amp; y&quot;</span> := (andb x y).</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x || y&quot;</span> := (orb x y).</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"02-notation.png\" /></p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x =? y&quot;</span> := (eqb x y) (<span class=\"built_in\">at</span> level <span class=\"number\">70</span>) : nat_scope.</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x &lt;=? y&quot;</span> := (leb x y) (<span class=\"built_in\">at</span> level <span class=\"number\">70</span>) : nat_scope.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"if-then-else-in-coq\"><code>if-then-else</code> in Coq</h3>\r\n<p><code>if-then-else</code> in Coq is quite different than in other\r\nlanguages, as type bool is not inherented in Coq.</p>\r\n<p>In Coq, <code>if</code> can be applied to any type with two\r\nconstructors. If the condition variable is constrcted by the first, go\r\nto <code>then</code>, otherwise go to <code>else</code>.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> nbool : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">first</span></span><br><span class=\"line\">  | <span class=\"type\">second</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Definition</span> trans (t : nbool) : nbool :=</span><br><span class=\"line\">  <span class=\"keyword\">if</span> t <span class=\"keyword\">then</span> second</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"built_in\">first</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Example</span> exp1 : trans <span class=\"built_in\">first</span> = second.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"built_in\">simpl</span>. <span class=\"built_in\">reflexivity</span>. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"check\">Check</h3>\r\n<p>Used to inspect the type of expressions. (variables and functions),\r\nfor example:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Check</span> true.</span><br><span class=\"line\"><span class=\"keyword\">Check</span> true : bool.</span><br><span class=\"line\"><span class=\"keyword\">Check</span> orb : bool -&gt; bool -&gt; bool.</span><br></pre></td></tr></table></figure>\r\n<p>bool <span class=\"math inline\">\\(\\rightarrow\\)</span> bool means a\r\nfunction with input of a bool variable and output of a bool variable.\r\n(just like Haskell). <span class=\"math inline\">\\(\\rightarrow\\)</span> is\r\nright associative.</p>\r\n<h3 id=\"details-of-symbl.-and-reflexivity.\">Details of symbl. and\r\nreflexivity.</h3>\r\n<p>Coq syntax 1. Vernacular: Give commands to change what Coq is doing.\r\nInclude <code>Check</code>, <code>Theorem</code>, <code>Proof</code>,\r\n<code>Qed</code> etc. 2. Gallina: Functional programming language, write\r\ncode and state theorem with this. Include <code>match</code>,\r\n<code>if</code>, <code>forall</code>. 3. Ltac: Language for tactics,\r\nstructure proofs into sections. Include <code>intros</code>,\r\n<code>simpl</code>, <code>reflexivity</code>, <code>destruct</code>.</p>\r\n<p>Lambda calculus (Theoretical underpinning of functional programming).\r\n<span class=\"math inline\">\\(e ::= x | \\lambda x . e | e_1\r\ne_2\\)</span></p>\r\n<p>Reduction tactics - <code>simpl.</code>: \"human readable\" -\r\n<code>cbn.</code>: call by name, try it if <code>simpl.</code> doesn't\r\nwork. - <code>cbv.</code>: call by value, fully compute. Its result may\r\nbe big and hard to read, unlike <code>simpl.</code>.</p>\r\n<p>Gallina (more than <span class=\"math inline\">\\(\\lambda\\)</span>)\r\nDefinitions (delta reduction) Inductive types, patter matching;\r\nrecursion (iota reduction); Let bindings (zeta reduction)</p>\r\n<!-- make this paragraph readable -->\r\n<h3 id=\"module-system\">Module System</h3>\r\n<p><code>Module</code> in Coq is like <code>namespace</code> in C++ and\r\n<code>package</code> in Java.</p>\r\n<h3 id=\"natural-number\">Natural Number</h3>\r\n<p>Definition of natural number</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> nat : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">O</span></span><br><span class=\"line\">  | <span class=\"type\">S</span> (n : nat).</span><br></pre></td></tr></table></figure>\r\n<p>Note that number 0 is denoted by captial letter O. <code>S</code>\r\nrepresents <code>succ</code> in some other languages.</p>\r\n<h3 id=\"recursive-function\">Recursive Function</h3>\r\n<p>Recursive function is defined by keyword <code>Fixpoint</code>,\r\ni.e.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> even (n:nat) : bool :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> n <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">O</span>        =&gt; true</span><br><span class=\"line\">  | <span class=\"type\">S</span> O      =&gt; false</span><br><span class=\"line\">  | <span class=\"type\">S</span> (S n&#x27;) =&gt; even n&#x27;</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Fixpoint</span> eqb (n m : nat) : bool :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> n <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">O</span> =&gt; <span class=\"keyword\">match</span> m <span class=\"built_in\">with</span></span><br><span class=\"line\">         | <span class=\"type\">O</span> =&gt; true</span><br><span class=\"line\">         | <span class=\"type\">S</span> m&#x27; =&gt; false</span><br><span class=\"line\">         <span class=\"keyword\">end</span></span><br><span class=\"line\">  | <span class=\"type\">S</span> n&#x27; =&gt; <span class=\"keyword\">match</span> m <span class=\"built_in\">with</span></span><br><span class=\"line\">            | <span class=\"type\">O</span> =&gt; false</span><br><span class=\"line\">            | <span class=\"type\">S</span> m&#x27; =&gt; eqb n&#x27; m&#x27;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure>\r\n<p>Coq only allows structural recursion.</p>\r\n<h3 id=\"intros\"><code>intros</code></h3>\r\n<p>Introduce hypothesis including variable quantifiers and hypothesis\r\n(those before the right arrow).</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> plus_id_example : <span class=\"keyword\">forall</span> n m:nat,</span><br><span class=\"line\">  n = m -&gt;</span><br><span class=\"line\">  n + n = m + m.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"comment\">(* move both quantifiers into the context: *)</span></span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m.</span><br><span class=\"line\">  <span class=\"comment\">(* move the hypothesis into the context: *)</span></span><br><span class=\"line\">  <span class=\"built_in\">intros</span> H.</span><br><span class=\"line\">  <span class=\"comment\">(* rewrite the goal using the hypothesis: *)</span></span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> -&gt; H.</span><br><span class=\"line\">  <span class=\"built_in\">reflexivity</span>.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>Right arrow and left arrow are different in <code>rewrite</code>\r\nexpression. In the above example, <code>n</code> is replaced by\r\n<code>m</code>, and in the following one, <code>(p * 0)</code> is\r\nreplaced by <code>0</code>.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">(* mult_n_O ===&gt; forall n : nat, 0 = n * 0 *)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Theorem</span> mult_n_0_m_0 : <span class=\"keyword\">forall</span> p q : nat,</span><br><span class=\"line\">  (p * <span class=\"number\">0</span>) + (q * <span class=\"number\">0</span>) = <span class=\"number\">0.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> p q.</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> &lt;- mult_n_O.</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> &lt;- mult_n_O.</span><br><span class=\"line\">  <span class=\"built_in\">reflexivity</span>. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"destruct\"><code>destruct</code></h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> plus_1_neq_0 : <span class=\"keyword\">forall</span> n : nat,</span><br><span class=\"line\">  (n + <span class=\"number\">1</span>) =? <span class=\"number\">0</span> = false.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n. <span class=\"built_in\">destruct</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27;] eqn:E.</span><br><span class=\"line\">  - <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"built_in\">reflexivity</span>.   <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>(<code>[| n']</code> is equal to <code>[O | S n']</code>)</p>\r\n<p>In the proof process above, <code>destruct</code> divide it into two\r\nsubgoals. The first is to prove that <code>(0 + 1 =? 0) = false</code>,\r\nthe second is to prove that <code>(S n' + 1 =? 0) = false</code>. In the\r\nfirst subgoal, <code>eqn:E</code> name the hypothesis n=0 as E.</p>\r\n<p>Two <code>reflexivity.</code> with a dash in front solves one\r\nsubgoal, respectively.</p>\r\n<p>Here is another example of two variables need subgoal division.\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> andb_commutative : <span class=\"keyword\">forall</span> b c, andb b c = andb c b.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> b c. <span class=\"built_in\">destruct</span> b eqn:Eb.</span><br><span class=\"line\">  <span class=\"comment\">(* b = true *)</span></span><br><span class=\"line\">  - <span class=\"built_in\">destruct</span> c eqn:Ec.</span><br><span class=\"line\">    + <span class=\"built_in\">reflexivity</span>.  <span class=\"comment\">(* c = true *)</span></span><br><span class=\"line\">    + <span class=\"built_in\">reflexivity</span>.  <span class=\"comment\">(* c = false *)</span></span><br><span class=\"line\">  <span class=\"comment\">(* b = false *)</span></span><br><span class=\"line\">  - <span class=\"built_in\">destruct</span> c eqn:Ec.</span><br><span class=\"line\">    + <span class=\"built_in\">reflexivity</span>.  <span class=\"comment\">(* c = true *)</span></span><br><span class=\"line\">    + <span class=\"built_in\">reflexivity</span>.  <span class=\"comment\">(* c = false *)</span></span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>Besides <code>+</code> and <code>-</code>, Coq also permits other\r\nnotations, like braces.</p>\r\n","site":{"data":{}},"excerpt":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<p><a\r\nhref=\"https://softwarefoundations.cis.upenn.edu/lf-current/index.html\">Online\r\nTextbook</a></p>\r\n<p><a href=\"https://www.youtube.com/watch?v=BGg-gxhsV4E\">Michael\r\nClarkson's Open Online Course (on Youtube)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1kd4y1t7bw/\">Michael Charkson's\r\nCourse (on Bilibili)</a></p>\r\n<p><a href=\"https://xiongyingfei.github.io/SF/2023/lectures.html\">Xiong\r\nYingfei's Course Webpage (2023 Spring)</a></p>\r\n<p>This note is used as a brief summary and supplementofr the textbook\r\nand courses.</p>\r\n<h2 id=\"basics\">Basics</h2>\r\n<h3 id=\"enumerated-types\">Enumerated Types</h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> day : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">monday</span></span><br><span class=\"line\">  | <span class=\"type\">tuesday</span></span><br><span class=\"line\">  | <span class=\"type\">wednesday</span></span><br><span class=\"line\">  | <span class=\"type\">thursday</span></span><br><span class=\"line\">  | <span class=\"type\">friday</span></span><br><span class=\"line\">  | <span class=\"type\">saturday</span></span><br><span class=\"line\">  | <span class=\"type\">sunday</span>.</span><br></pre></td></tr></table></figure>","more":"<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> next_weekday (d:day) : day :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> d <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">monday</span>    =&gt; tuesday</span><br><span class=\"line\">  | <span class=\"type\">tuesday</span>   =&gt; wednesday</span><br><span class=\"line\">  | <span class=\"type\">wednesday</span> =&gt; thursday</span><br><span class=\"line\">  | <span class=\"type\">thursday</span>  =&gt; friday</span><br><span class=\"line\">  | <span class=\"type\">friday</span>    =&gt; monday</span><br><span class=\"line\">  | <span class=\"type\">saturday</span>  =&gt; monday</span><br><span class=\"line\">  | <span class=\"type\">sunday</span>    =&gt; monday</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure>\r\n<p>Then we can do the computation. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Compute</span> (next_weekday friday).</span><br><span class=\"line\"><span class=\"comment\">(* ==&gt; monday : day *)</span></span><br></pre></td></tr></table></figure></p>\r\n<p>Note that pattern-machine needs to be exhaustive, and cannot be\r\nredundant.</p>\r\n<p>For example:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> to_monday (d:day) : day := </span><br><span class=\"line\">  <span class=\"keyword\">match</span> d <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">monday</span> =&gt; monday</span><br><span class=\"line\">  | <span class=\"type\">tuesday</span> =&gt; monday</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"><span class=\"comment\">(** [messages window]</span></span><br><span class=\"line\"><span class=\"comment\">    Non exhaustive pattern-matching: no clause found for pattern</span></span><br><span class=\"line\"><span class=\"comment\">    wednesday *)</span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> to_monday (d:day) : day := </span><br><span class=\"line\">  <span class=\"keyword\">match</span> d <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">monday</span> =&gt; monday</span><br><span class=\"line\">  | <span class=\"type\">_</span> =&gt; monday</span><br><span class=\"line\">  | <span class=\"type\">sunday</span> =&gt; monday</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"><span class=\"comment\">(** [messages window]</span></span><br><span class=\"line\"><span class=\"comment\">    Pattern &quot;sunday&quot; is redundant in this clause. *)</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"function-call\">Function Call</h3>\r\n<p>Function call in Coq is by tapping the space bar, like\r\n<code>f a</code>, it is left associative (that is to say\r\n<code>f a b</code> is equal to <code>(f a) b</code>), and is with nearly\r\nthe highest priority (i.e. <code>f a + b</code> is equal to\r\n<code>(f a) + b</code>).</p>\r\n<h3 id=\"equality\">Equality</h3>\r\n<p>There are two notions of equality in Coq: the equals operator and the\r\nequals question mark operator. - The equals operator is a logical claim,\r\nmeans something we try to prove. Currently we only use this . - The\r\nequals question mark operator is an expression that Coq computes.\r\nNotation <code>x=?y</code>, <code>x&lt;=?y</code> use question to denote\r\nthat this returns a boolean variable.</p>\r\n<h3 id=\"theory-proof\">Theory Proof</h3>\r\n<p>Theory proof is the core of Coq, and it is with the form:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Example</span> test_next_weekday:</span><br><span class=\"line\">  (next_weekday (next_weekday saturday)) = tuesday.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"built_in\">simpl</span>. <span class=\"built_in\">reflexivity</span>.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>Or we may proof <code>Lemma</code>, <code>Theorem</code>, etc. other\r\nthan <code>Example</code>.</p>\r\n<p>In the CoqIde, we can observe the proof process step by step with the\r\nhelp of 'Run to curser' icon.</p>\r\n<p>Take the above proof process as an example:</p>\r\n<p><img src=\"02-step_by_step_1.png\" /></p>\r\n<p><img src=\"02-step_by_step_2.png\" /></p>\r\n<p><img src=\"02-step_by_step_3.png\" /></p>\r\n<p><img src=\"02-step_by_step_4.png\" /></p>\r\n<h3 id=\"notation\">Notation</h3>\r\n<p>Programmers can introduce new grammar rule.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x &amp;&amp; y&quot;</span> := (andb x y).</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x || y&quot;</span> := (orb x y).</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"02-notation.png\" /></p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x =? y&quot;</span> := (eqb x y) (<span class=\"built_in\">at</span> level <span class=\"number\">70</span>) : nat_scope.</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x &lt;=? y&quot;</span> := (leb x y) (<span class=\"built_in\">at</span> level <span class=\"number\">70</span>) : nat_scope.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"if-then-else-in-coq\"><code>if-then-else</code> in Coq</h3>\r\n<p><code>if-then-else</code> in Coq is quite different than in other\r\nlanguages, as type bool is not inherented in Coq.</p>\r\n<p>In Coq, <code>if</code> can be applied to any type with two\r\nconstructors. If the condition variable is constrcted by the first, go\r\nto <code>then</code>, otherwise go to <code>else</code>.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> nbool : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">first</span></span><br><span class=\"line\">  | <span class=\"type\">second</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Definition</span> trans (t : nbool) : nbool :=</span><br><span class=\"line\">  <span class=\"keyword\">if</span> t <span class=\"keyword\">then</span> second</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"built_in\">first</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Example</span> exp1 : trans <span class=\"built_in\">first</span> = second.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"built_in\">simpl</span>. <span class=\"built_in\">reflexivity</span>. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"check\">Check</h3>\r\n<p>Used to inspect the type of expressions. (variables and functions),\r\nfor example:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Check</span> true.</span><br><span class=\"line\"><span class=\"keyword\">Check</span> true : bool.</span><br><span class=\"line\"><span class=\"keyword\">Check</span> orb : bool -&gt; bool -&gt; bool.</span><br></pre></td></tr></table></figure>\r\n<p>bool <span class=\"math inline\">\\(\\rightarrow\\)</span> bool means a\r\nfunction with input of a bool variable and output of a bool variable.\r\n(just like Haskell). <span class=\"math inline\">\\(\\rightarrow\\)</span> is\r\nright associative.</p>\r\n<h3 id=\"details-of-symbl.-and-reflexivity.\">Details of symbl. and\r\nreflexivity.</h3>\r\n<p>Coq syntax 1. Vernacular: Give commands to change what Coq is doing.\r\nInclude <code>Check</code>, <code>Theorem</code>, <code>Proof</code>,\r\n<code>Qed</code> etc. 2. Gallina: Functional programming language, write\r\ncode and state theorem with this. Include <code>match</code>,\r\n<code>if</code>, <code>forall</code>. 3. Ltac: Language for tactics,\r\nstructure proofs into sections. Include <code>intros</code>,\r\n<code>simpl</code>, <code>reflexivity</code>, <code>destruct</code>.</p>\r\n<p>Lambda calculus (Theoretical underpinning of functional programming).\r\n<span class=\"math inline\">\\(e ::= x | \\lambda x . e | e_1\r\ne_2\\)</span></p>\r\n<p>Reduction tactics - <code>simpl.</code>: \"human readable\" -\r\n<code>cbn.</code>: call by name, try it if <code>simpl.</code> doesn't\r\nwork. - <code>cbv.</code>: call by value, fully compute. Its result may\r\nbe big and hard to read, unlike <code>simpl.</code>.</p>\r\n<p>Gallina (more than <span class=\"math inline\">\\(\\lambda\\)</span>)\r\nDefinitions (delta reduction) Inductive types, patter matching;\r\nrecursion (iota reduction); Let bindings (zeta reduction)</p>\r\n<!-- make this paragraph readable -->\r\n<h3 id=\"module-system\">Module System</h3>\r\n<p><code>Module</code> in Coq is like <code>namespace</code> in C++ and\r\n<code>package</code> in Java.</p>\r\n<h3 id=\"natural-number\">Natural Number</h3>\r\n<p>Definition of natural number</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> nat : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">O</span></span><br><span class=\"line\">  | <span class=\"type\">S</span> (n : nat).</span><br></pre></td></tr></table></figure>\r\n<p>Note that number 0 is denoted by captial letter O. <code>S</code>\r\nrepresents <code>succ</code> in some other languages.</p>\r\n<h3 id=\"recursive-function\">Recursive Function</h3>\r\n<p>Recursive function is defined by keyword <code>Fixpoint</code>,\r\ni.e.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> even (n:nat) : bool :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> n <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">O</span>        =&gt; true</span><br><span class=\"line\">  | <span class=\"type\">S</span> O      =&gt; false</span><br><span class=\"line\">  | <span class=\"type\">S</span> (S n&#x27;) =&gt; even n&#x27;</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Fixpoint</span> eqb (n m : nat) : bool :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> n <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">O</span> =&gt; <span class=\"keyword\">match</span> m <span class=\"built_in\">with</span></span><br><span class=\"line\">         | <span class=\"type\">O</span> =&gt; true</span><br><span class=\"line\">         | <span class=\"type\">S</span> m&#x27; =&gt; false</span><br><span class=\"line\">         <span class=\"keyword\">end</span></span><br><span class=\"line\">  | <span class=\"type\">S</span> n&#x27; =&gt; <span class=\"keyword\">match</span> m <span class=\"built_in\">with</span></span><br><span class=\"line\">            | <span class=\"type\">O</span> =&gt; false</span><br><span class=\"line\">            | <span class=\"type\">S</span> m&#x27; =&gt; eqb n&#x27; m&#x27;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure>\r\n<p>Coq only allows structural recursion.</p>\r\n<h3 id=\"intros\"><code>intros</code></h3>\r\n<p>Introduce hypothesis including variable quantifiers and hypothesis\r\n(those before the right arrow).</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> plus_id_example : <span class=\"keyword\">forall</span> n m:nat,</span><br><span class=\"line\">  n = m -&gt;</span><br><span class=\"line\">  n + n = m + m.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"comment\">(* move both quantifiers into the context: *)</span></span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m.</span><br><span class=\"line\">  <span class=\"comment\">(* move the hypothesis into the context: *)</span></span><br><span class=\"line\">  <span class=\"built_in\">intros</span> H.</span><br><span class=\"line\">  <span class=\"comment\">(* rewrite the goal using the hypothesis: *)</span></span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> -&gt; H.</span><br><span class=\"line\">  <span class=\"built_in\">reflexivity</span>.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>Right arrow and left arrow are different in <code>rewrite</code>\r\nexpression. In the above example, <code>n</code> is replaced by\r\n<code>m</code>, and in the following one, <code>(p * 0)</code> is\r\nreplaced by <code>0</code>.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">(* mult_n_O ===&gt; forall n : nat, 0 = n * 0 *)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Theorem</span> mult_n_0_m_0 : <span class=\"keyword\">forall</span> p q : nat,</span><br><span class=\"line\">  (p * <span class=\"number\">0</span>) + (q * <span class=\"number\">0</span>) = <span class=\"number\">0.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> p q.</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> &lt;- mult_n_O.</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> &lt;- mult_n_O.</span><br><span class=\"line\">  <span class=\"built_in\">reflexivity</span>. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"destruct\"><code>destruct</code></h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> plus_1_neq_0 : <span class=\"keyword\">forall</span> n : nat,</span><br><span class=\"line\">  (n + <span class=\"number\">1</span>) =? <span class=\"number\">0</span> = false.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n. <span class=\"built_in\">destruct</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27;] eqn:E.</span><br><span class=\"line\">  - <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"built_in\">reflexivity</span>.   <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>(<code>[| n']</code> is equal to <code>[O | S n']</code>)</p>\r\n<p>In the proof process above, <code>destruct</code> divide it into two\r\nsubgoals. The first is to prove that <code>(0 + 1 =? 0) = false</code>,\r\nthe second is to prove that <code>(S n' + 1 =? 0) = false</code>. In the\r\nfirst subgoal, <code>eqn:E</code> name the hypothesis n=0 as E.</p>\r\n<p>Two <code>reflexivity.</code> with a dash in front solves one\r\nsubgoal, respectively.</p>\r\n<p>Here is another example of two variables need subgoal division.\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> andb_commutative : <span class=\"keyword\">forall</span> b c, andb b c = andb c b.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> b c. <span class=\"built_in\">destruct</span> b eqn:Eb.</span><br><span class=\"line\">  <span class=\"comment\">(* b = true *)</span></span><br><span class=\"line\">  - <span class=\"built_in\">destruct</span> c eqn:Ec.</span><br><span class=\"line\">    + <span class=\"built_in\">reflexivity</span>.  <span class=\"comment\">(* c = true *)</span></span><br><span class=\"line\">    + <span class=\"built_in\">reflexivity</span>.  <span class=\"comment\">(* c = false *)</span></span><br><span class=\"line\">  <span class=\"comment\">(* b = false *)</span></span><br><span class=\"line\">  - <span class=\"built_in\">destruct</span> c eqn:Ec.</span><br><span class=\"line\">    + <span class=\"built_in\">reflexivity</span>.  <span class=\"comment\">(* c = true *)</span></span><br><span class=\"line\">    + <span class=\"built_in\">reflexivity</span>.  <span class=\"comment\">(* c = false *)</span></span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>Besides <code>+</code> and <code>-</code>, Coq also permits other\r\nnotations, like braces.</p>"},{"layout":"[software-foundations] title: Induction","date":"2023-04-03T13:05:34.000Z","_content":"\n# Software Foundations\n\n[Online Textbook](https://softwarefoundations.cis.upenn.edu/lf-current/index.html)\n\n[Michael Clarkson's Open Online Course (on Youtube)](https://www.youtube.com/watch?v=BGg-gxhsV4E)\n[Michael Charkson's Course (on Bilibili)](https://www.bilibili.com/video/BV1kd4y1t7bw/)\n\n[Xiong Yingfei's Course Webpage (2023 Spring)](https://xiongyingfei.github.io/SF/2023/lectures.html)\n\nThis note is used as a brief summary and supplementofr the textbook and courses.\n\n## Induction\n\n### Compile .v File and Inport It\n\n<!--more-->\n\nWe need to import all of our definitions from the previous chapter.\n```Coq\nFrom LF Require Export Basics.\n```\nBut we have to compile Basics.v file into Basics.vo file before we can import it. \n\nIn Linux terminal, we can generate Makefile with command\n```\n$ coq_makefile -f _CoqProject *.v -o Makefile\n```\nAnd then compile all the files\n```\n$ make\n```\nOr just compile Basics.v into Basics.vo\n```\n$ make Basics.vo\n```\n\nIt is slightly different in Windows, where you need to input\n```\n> coqc -Q . LF Basics.v\n```\n\n`LF` is the alias of the directory when compiling.\n\n\n### `induction`\n\nHere is an example of the usage of induction proof.\n\n```Coq\nTheorem add_0_r : forall n:nat, n + 0 = n.\n\nProof. (* A wrong proof *)\n  intros n. destruct n as [| n'] eqn:E.\n  - (* n = 0 *)\n    reflexivity. (* so far so good... *)\n  - (* n = S n' *)\n    simpl.       (* ...but here we are stuck again *)\nAbort.\n\nProof. (* Correct proof *)\n  intros n. induction n as [| n' IHn'].\n  - (* n = 0 *)    reflexivity.\n  - (* n = S n' *) simpl. rewrite -> IHn'. reflexivity.  Qed.\n```\n\nTo understand this phenomena, we first look back at the definiton of plus in Basics.v.\n\n```Coq\nFixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end.\n```\nThe definition of plus operation doesn't tell us how to conclude that `n'+ 0 = n'`, so the destruct way of proof failed. \n\nBut we can use induction to realize the proof:\n\n```Coq\nTheorem minus_n_n: forall n, minus n n = 0.\n(* Example proof *)\nProof.\n  (* WORKED IN CLASS *)\n  intros n. induction n as [| n' IHn'].\n  - (* n = 0 *)\n    simpl. reflexivity.\n  - (* n = S n' *)\n    simpl. rewrite -> IHn'. reflexivity.  \nQed.\n(* Another legal proof *)\nProof.\n    intro n. induction n as [| n' IHn']. \n    - (* n = 0 *) simpl. reflexivity.\n    - (* n = S n' *) simpl. assumption.\nQed.\n```\n\n(`as [| n' IHn']` divide n into two circumstances, `O` and `S n'`, and give name `IHn'` to the induction hypothesis)\n\nThe first subgoal proves that for n = 0, the theorem is correct. And the second subgoal proves that if for n = n', the theorem holds water, then it also does to n = S n'. \n\nStructural induction is applicable to any type that is reductively defined. The first methametical induction is a special case of it on natural number.\n\n### `assert`\n\nProofs within proofs\n\n```Coq\nTheorem mult_0_plus'' : forall n m : nat,\n  (n + 0 + 0) * m = n * m.\n(* Plain proof *)\nProof.\n  intros n m.\n  rewrite add_comm. simpl. (* ==> (n + 0) * m = n * m  *)\n  rewrite add_comm. simpl. (* ==> n * m = n * m *)\n  reflexivity.\nQed.\n(* Proof using assert tactic *)\nProof.\n  intros n m.\n  assert (H: n + 0 + 0 = n).\n    { rewrite add_comm. simpl. rewrite add_comm. reflexivity. } \n  rewrite -> H.\n  reflexivity.\nQed.\n```\n\nAnd print `Set Printing Parentheses.` to see the parentheses omitted and better understand `rewrite` tactic result.\n\nRewrite tactic also serve to specify the elements we want to apply hypothesis to. \n```Coq\nTheorem plus_rearrange : forall n m p q : nat,\n  (n + m) + (p + q) = (m + n) + (p + q).\n(* Wrong proof *)\nProof.\n  intros n m p q.\n  rewrite add_comm.\n  (* ==> p + q + (n + m) = m + n + (p + q)\n      Obviously that is not what we want.*)\nAbort.\n(* Corrent proof *)\nProof.\n  intros n m p q.\n  assert (H: n + m = m + n).\n  { rewrite add_comm. reflexivity. }\n  rewrite H. reflexivity.  \nQed.\n```\n\n<!-- As human, we generally do informal proof. -->\n\n\n","source":"_posts/Induction.md","raw":"---\nlayout: '[software-foundations] title: Induction'\ndate: 2023-04-03 21:05:34\ntags:\n---\n\n# Software Foundations\n\n[Online Textbook](https://softwarefoundations.cis.upenn.edu/lf-current/index.html)\n\n[Michael Clarkson's Open Online Course (on Youtube)](https://www.youtube.com/watch?v=BGg-gxhsV4E)\n[Michael Charkson's Course (on Bilibili)](https://www.bilibili.com/video/BV1kd4y1t7bw/)\n\n[Xiong Yingfei's Course Webpage (2023 Spring)](https://xiongyingfei.github.io/SF/2023/lectures.html)\n\nThis note is used as a brief summary and supplementofr the textbook and courses.\n\n## Induction\n\n### Compile .v File and Inport It\n\n<!--more-->\n\nWe need to import all of our definitions from the previous chapter.\n```Coq\nFrom LF Require Export Basics.\n```\nBut we have to compile Basics.v file into Basics.vo file before we can import it. \n\nIn Linux terminal, we can generate Makefile with command\n```\n$ coq_makefile -f _CoqProject *.v -o Makefile\n```\nAnd then compile all the files\n```\n$ make\n```\nOr just compile Basics.v into Basics.vo\n```\n$ make Basics.vo\n```\n\nIt is slightly different in Windows, where you need to input\n```\n> coqc -Q . LF Basics.v\n```\n\n`LF` is the alias of the directory when compiling.\n\n\n### `induction`\n\nHere is an example of the usage of induction proof.\n\n```Coq\nTheorem add_0_r : forall n:nat, n + 0 = n.\n\nProof. (* A wrong proof *)\n  intros n. destruct n as [| n'] eqn:E.\n  - (* n = 0 *)\n    reflexivity. (* so far so good... *)\n  - (* n = S n' *)\n    simpl.       (* ...but here we are stuck again *)\nAbort.\n\nProof. (* Correct proof *)\n  intros n. induction n as [| n' IHn'].\n  - (* n = 0 *)    reflexivity.\n  - (* n = S n' *) simpl. rewrite -> IHn'. reflexivity.  Qed.\n```\n\nTo understand this phenomena, we first look back at the definiton of plus in Basics.v.\n\n```Coq\nFixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end.\n```\nThe definition of plus operation doesn't tell us how to conclude that `n'+ 0 = n'`, so the destruct way of proof failed. \n\nBut we can use induction to realize the proof:\n\n```Coq\nTheorem minus_n_n: forall n, minus n n = 0.\n(* Example proof *)\nProof.\n  (* WORKED IN CLASS *)\n  intros n. induction n as [| n' IHn'].\n  - (* n = 0 *)\n    simpl. reflexivity.\n  - (* n = S n' *)\n    simpl. rewrite -> IHn'. reflexivity.  \nQed.\n(* Another legal proof *)\nProof.\n    intro n. induction n as [| n' IHn']. \n    - (* n = 0 *) simpl. reflexivity.\n    - (* n = S n' *) simpl. assumption.\nQed.\n```\n\n(`as [| n' IHn']` divide n into two circumstances, `O` and `S n'`, and give name `IHn'` to the induction hypothesis)\n\nThe first subgoal proves that for n = 0, the theorem is correct. And the second subgoal proves that if for n = n', the theorem holds water, then it also does to n = S n'. \n\nStructural induction is applicable to any type that is reductively defined. The first methametical induction is a special case of it on natural number.\n\n### `assert`\n\nProofs within proofs\n\n```Coq\nTheorem mult_0_plus'' : forall n m : nat,\n  (n + 0 + 0) * m = n * m.\n(* Plain proof *)\nProof.\n  intros n m.\n  rewrite add_comm. simpl. (* ==> (n + 0) * m = n * m  *)\n  rewrite add_comm. simpl. (* ==> n * m = n * m *)\n  reflexivity.\nQed.\n(* Proof using assert tactic *)\nProof.\n  intros n m.\n  assert (H: n + 0 + 0 = n).\n    { rewrite add_comm. simpl. rewrite add_comm. reflexivity. } \n  rewrite -> H.\n  reflexivity.\nQed.\n```\n\nAnd print `Set Printing Parentheses.` to see the parentheses omitted and better understand `rewrite` tactic result.\n\nRewrite tactic also serve to specify the elements we want to apply hypothesis to. \n```Coq\nTheorem plus_rearrange : forall n m p q : nat,\n  (n + m) + (p + q) = (m + n) + (p + q).\n(* Wrong proof *)\nProof.\n  intros n m p q.\n  rewrite add_comm.\n  (* ==> p + q + (n + m) = m + n + (p + q)\n      Obviously that is not what we want.*)\nAbort.\n(* Corrent proof *)\nProof.\n  intros n m p q.\n  assert (H: n + m = m + n).\n  { rewrite add_comm. reflexivity. }\n  rewrite H. reflexivity.  \nQed.\n```\n\n<!-- As human, we generally do informal proof. -->\n\n\n","slug":"Induction","published":1,"updated":"2023-04-11T08:13:18.125Z","_id":"clg1287jw0005x8mv6lh6aknl","title":"","comments":1,"photos":[],"link":"","content":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<p><a\r\nhref=\"https://softwarefoundations.cis.upenn.edu/lf-current/index.html\">Online\r\nTextbook</a></p>\r\n<p><a href=\"https://www.youtube.com/watch?v=BGg-gxhsV4E\">Michael\r\nClarkson's Open Online Course (on Youtube)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1kd4y1t7bw/\">Michael Charkson's\r\nCourse (on Bilibili)</a></p>\r\n<p><a href=\"https://xiongyingfei.github.io/SF/2023/lectures.html\">Xiong\r\nYingfei's Course Webpage (2023 Spring)</a></p>\r\n<p>This note is used as a brief summary and supplementofr the textbook\r\nand courses.</p>\r\n<h2 id=\"induction\">Induction</h2>\r\n<h3 id=\"compile-.v-file-and-inport-it\">Compile .v File and Inport\r\nIt</h3>\r\n<span id=\"more\"></span>\r\n<p>We need to import all of our definitions from the previous chapter.\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">From</span> LF <span class=\"keyword\">Require</span> <span class=\"keyword\">Export</span> Basics.</span><br></pre></td></tr></table></figure> But we have to compile Basics.v file into Basics.vo file\r\nbefore we can import it.</p>\r\n<p>In Linux terminal, we can generate Makefile with command\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ coq_makefile -f _CoqProject *.v -o Makefile</span><br></pre></td></tr></table></figure> And then compile all the files <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make</span><br></pre></td></tr></table></figure> Or just\r\ncompile Basics.v into Basics.vo <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make Basics.vo</span><br></pre></td></tr></table></figure></p>\r\n<p>It is slightly different in Windows, where you need to input\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; coqc -Q . LF Basics.v</span><br></pre></td></tr></table></figure></p>\r\n<p><code>LF</code> is the alias of the directory when compiling.</p>\r\n<h3 id=\"induction-1\"><code>induction</code></h3>\r\n<p>Here is an example of the usage of induction proof.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> add_0_r : <span class=\"keyword\">forall</span> n:nat, n + <span class=\"number\">0</span> = n.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"comment\">(* A wrong proof *)</span></span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n. <span class=\"built_in\">destruct</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27;] eqn:E.</span><br><span class=\"line\">  - <span class=\"comment\">(* n = 0 *)</span></span><br><span class=\"line\">    <span class=\"built_in\">reflexivity</span>. <span class=\"comment\">(* so far so good... *)</span></span><br><span class=\"line\">  - <span class=\"comment\">(* n = S n&#x27; *)</span></span><br><span class=\"line\">    <span class=\"built_in\">simpl</span>.       <span class=\"comment\">(* ...but here we are stuck again *)</span></span><br><span class=\"line\"><span class=\"keyword\">Abort</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"comment\">(* Correct proof *)</span></span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n. <span class=\"built_in\">induction</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27; IHn&#x27;].</span><br><span class=\"line\">  - <span class=\"comment\">(* n = 0 *)</span>    <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"comment\">(* n = S n&#x27; *)</span> <span class=\"built_in\">simpl</span>. <span class=\"built_in\">rewrite</span> -&gt; IHn&#x27;. <span class=\"built_in\">reflexivity</span>.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>To understand this phenomena, we first look back at the definiton of\r\nplus in Basics.v.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> plus (n : nat) (m : nat) : nat :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> n <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">O</span> =&gt; m</span><br><span class=\"line\">  | <span class=\"type\">S</span> n&#x27; =&gt; S (plus n&#x27; m)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure>\r\n<p>The definition of plus operation doesn't tell us how to conclude that\r\n<code>n'+ 0 = n'</code>, so the destruct way of proof failed.</p>\r\n<p>But we can use induction to realize the proof:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> minus_n_n: <span class=\"keyword\">forall</span> n, minus n n = <span class=\"number\">0.</span></span><br><span class=\"line\"><span class=\"comment\">(* Example proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"comment\">(* WORKED IN CLASS *)</span></span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n. <span class=\"built_in\">induction</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27; IHn&#x27;].</span><br><span class=\"line\">  - <span class=\"comment\">(* n = 0 *)</span></span><br><span class=\"line\">    <span class=\"built_in\">simpl</span>. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"comment\">(* n = S n&#x27; *)</span></span><br><span class=\"line\">    <span class=\"built_in\">simpl</span>. <span class=\"built_in\">rewrite</span> -&gt; IHn&#x27;. <span class=\"built_in\">reflexivity</span>.  </span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br><span class=\"line\"><span class=\"comment\">(* Another legal proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">    <span class=\"built_in\">intro</span> n. <span class=\"built_in\">induction</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27; IHn&#x27;]. </span><br><span class=\"line\">    - <span class=\"comment\">(* n = 0 *)</span> <span class=\"built_in\">simpl</span>. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">    - <span class=\"comment\">(* n = S n&#x27; *)</span> <span class=\"built_in\">simpl</span>. <span class=\"built_in\">assumption</span>.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>(<code>as [| n' IHn']</code> divide n into two circumstances,\r\n<code>O</code> and <code>S n'</code>, and give name <code>IHn'</code> to\r\nthe induction hypothesis)</p>\r\n<p>The first subgoal proves that for n = 0, the theorem is correct. And\r\nthe second subgoal proves that if for n = n', the theorem holds water,\r\nthen it also does to n = S n'.</p>\r\n<p>Structural induction is applicable to any type that is reductively\r\ndefined. The first methametical induction is a special case of it on\r\nnatural number.</p>\r\n<h3 id=\"assert\"><code>assert</code></h3>\r\n<p>Proofs within proofs</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> mult_0_plus&#x27;&#x27; : <span class=\"keyword\">forall</span> n m : nat,</span><br><span class=\"line\">  (n + <span class=\"number\">0</span> + <span class=\"number\">0</span>) * m = n * m.</span><br><span class=\"line\"><span class=\"comment\">(* Plain proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m.</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> add_comm. <span class=\"built_in\">simpl</span>. <span class=\"comment\">(* ==&gt; (n + 0) * m = n * m  *)</span></span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> add_comm. <span class=\"built_in\">simpl</span>. <span class=\"comment\">(* ==&gt; n * m = n * m *)</span></span><br><span class=\"line\">  <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br><span class=\"line\"><span class=\"comment\">(* Proof using assert tactic *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m.</span><br><span class=\"line\">  <span class=\"built_in\">assert</span> (H: n + <span class=\"number\">0</span> + <span class=\"number\">0</span> = n).</span><br><span class=\"line\">    &#123; <span class=\"built_in\">rewrite</span> add_comm. <span class=\"built_in\">simpl</span>. <span class=\"built_in\">rewrite</span> add_comm. <span class=\"built_in\">reflexivity</span>. &#125; </span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> -&gt; H.</span><br><span class=\"line\">  <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>And print <code>Set Printing Parentheses.</code> to see the\r\nparentheses omitted and better understand <code>rewrite</code> tactic\r\nresult.</p>\r\n<p>Rewrite tactic also serve to specify the elements we want to apply\r\nhypothesis to. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> plus_rearrange : <span class=\"keyword\">forall</span> n m p q : nat,</span><br><span class=\"line\">  (n + m) + (p + q) = (m + n) + (p + q).</span><br><span class=\"line\"><span class=\"comment\">(* Wrong proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m p q.</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> add_comm.</span><br><span class=\"line\">  <span class=\"comment\">(* ==&gt; p + q + (n + m) = m + n + (p + q)</span></span><br><span class=\"line\"><span class=\"comment\">      Obviously that is not what we want.*)</span></span><br><span class=\"line\"><span class=\"keyword\">Abort</span>.</span><br><span class=\"line\"><span class=\"comment\">(* Corrent proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m p q.</span><br><span class=\"line\">  <span class=\"built_in\">assert</span> (H: n + m = m + n).</span><br><span class=\"line\">  &#123; <span class=\"built_in\">rewrite</span> add_comm. <span class=\"built_in\">reflexivity</span>. &#125;</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> H. <span class=\"built_in\">reflexivity</span>.  </span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<!-- As human, we generally do informal proof. -->\r\n","site":{"data":{}},"excerpt":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<p><a\r\nhref=\"https://softwarefoundations.cis.upenn.edu/lf-current/index.html\">Online\r\nTextbook</a></p>\r\n<p><a href=\"https://www.youtube.com/watch?v=BGg-gxhsV4E\">Michael\r\nClarkson's Open Online Course (on Youtube)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1kd4y1t7bw/\">Michael Charkson's\r\nCourse (on Bilibili)</a></p>\r\n<p><a href=\"https://xiongyingfei.github.io/SF/2023/lectures.html\">Xiong\r\nYingfei's Course Webpage (2023 Spring)</a></p>\r\n<p>This note is used as a brief summary and supplementofr the textbook\r\nand courses.</p>\r\n<h2 id=\"induction\">Induction</h2>\r\n<h3 id=\"compile-.v-file-and-inport-it\">Compile .v File and Inport\r\nIt</h3>","more":"<p>We need to import all of our definitions from the previous chapter.\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">From</span> LF <span class=\"keyword\">Require</span> <span class=\"keyword\">Export</span> Basics.</span><br></pre></td></tr></table></figure> But we have to compile Basics.v file into Basics.vo file\r\nbefore we can import it.</p>\r\n<p>In Linux terminal, we can generate Makefile with command\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ coq_makefile -f _CoqProject *.v -o Makefile</span><br></pre></td></tr></table></figure> And then compile all the files <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make</span><br></pre></td></tr></table></figure> Or just\r\ncompile Basics.v into Basics.vo <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make Basics.vo</span><br></pre></td></tr></table></figure></p>\r\n<p>It is slightly different in Windows, where you need to input\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; coqc -Q . LF Basics.v</span><br></pre></td></tr></table></figure></p>\r\n<p><code>LF</code> is the alias of the directory when compiling.</p>\r\n<h3 id=\"induction-1\"><code>induction</code></h3>\r\n<p>Here is an example of the usage of induction proof.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> add_0_r : <span class=\"keyword\">forall</span> n:nat, n + <span class=\"number\">0</span> = n.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"comment\">(* A wrong proof *)</span></span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n. <span class=\"built_in\">destruct</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27;] eqn:E.</span><br><span class=\"line\">  - <span class=\"comment\">(* n = 0 *)</span></span><br><span class=\"line\">    <span class=\"built_in\">reflexivity</span>. <span class=\"comment\">(* so far so good... *)</span></span><br><span class=\"line\">  - <span class=\"comment\">(* n = S n&#x27; *)</span></span><br><span class=\"line\">    <span class=\"built_in\">simpl</span>.       <span class=\"comment\">(* ...but here we are stuck again *)</span></span><br><span class=\"line\"><span class=\"keyword\">Abort</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"comment\">(* Correct proof *)</span></span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n. <span class=\"built_in\">induction</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27; IHn&#x27;].</span><br><span class=\"line\">  - <span class=\"comment\">(* n = 0 *)</span>    <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"comment\">(* n = S n&#x27; *)</span> <span class=\"built_in\">simpl</span>. <span class=\"built_in\">rewrite</span> -&gt; IHn&#x27;. <span class=\"built_in\">reflexivity</span>.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>To understand this phenomena, we first look back at the definiton of\r\nplus in Basics.v.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> plus (n : nat) (m : nat) : nat :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> n <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">O</span> =&gt; m</span><br><span class=\"line\">  | <span class=\"type\">S</span> n&#x27; =&gt; S (plus n&#x27; m)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure>\r\n<p>The definition of plus operation doesn't tell us how to conclude that\r\n<code>n'+ 0 = n'</code>, so the destruct way of proof failed.</p>\r\n<p>But we can use induction to realize the proof:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> minus_n_n: <span class=\"keyword\">forall</span> n, minus n n = <span class=\"number\">0.</span></span><br><span class=\"line\"><span class=\"comment\">(* Example proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"comment\">(* WORKED IN CLASS *)</span></span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n. <span class=\"built_in\">induction</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27; IHn&#x27;].</span><br><span class=\"line\">  - <span class=\"comment\">(* n = 0 *)</span></span><br><span class=\"line\">    <span class=\"built_in\">simpl</span>. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"comment\">(* n = S n&#x27; *)</span></span><br><span class=\"line\">    <span class=\"built_in\">simpl</span>. <span class=\"built_in\">rewrite</span> -&gt; IHn&#x27;. <span class=\"built_in\">reflexivity</span>.  </span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br><span class=\"line\"><span class=\"comment\">(* Another legal proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">    <span class=\"built_in\">intro</span> n. <span class=\"built_in\">induction</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27; IHn&#x27;]. </span><br><span class=\"line\">    - <span class=\"comment\">(* n = 0 *)</span> <span class=\"built_in\">simpl</span>. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">    - <span class=\"comment\">(* n = S n&#x27; *)</span> <span class=\"built_in\">simpl</span>. <span class=\"built_in\">assumption</span>.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>(<code>as [| n' IHn']</code> divide n into two circumstances,\r\n<code>O</code> and <code>S n'</code>, and give name <code>IHn'</code> to\r\nthe induction hypothesis)</p>\r\n<p>The first subgoal proves that for n = 0, the theorem is correct. And\r\nthe second subgoal proves that if for n = n', the theorem holds water,\r\nthen it also does to n = S n'.</p>\r\n<p>Structural induction is applicable to any type that is reductively\r\ndefined. The first methametical induction is a special case of it on\r\nnatural number.</p>\r\n<h3 id=\"assert\"><code>assert</code></h3>\r\n<p>Proofs within proofs</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> mult_0_plus&#x27;&#x27; : <span class=\"keyword\">forall</span> n m : nat,</span><br><span class=\"line\">  (n + <span class=\"number\">0</span> + <span class=\"number\">0</span>) * m = n * m.</span><br><span class=\"line\"><span class=\"comment\">(* Plain proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m.</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> add_comm. <span class=\"built_in\">simpl</span>. <span class=\"comment\">(* ==&gt; (n + 0) * m = n * m  *)</span></span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> add_comm. <span class=\"built_in\">simpl</span>. <span class=\"comment\">(* ==&gt; n * m = n * m *)</span></span><br><span class=\"line\">  <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br><span class=\"line\"><span class=\"comment\">(* Proof using assert tactic *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m.</span><br><span class=\"line\">  <span class=\"built_in\">assert</span> (H: n + <span class=\"number\">0</span> + <span class=\"number\">0</span> = n).</span><br><span class=\"line\">    &#123; <span class=\"built_in\">rewrite</span> add_comm. <span class=\"built_in\">simpl</span>. <span class=\"built_in\">rewrite</span> add_comm. <span class=\"built_in\">reflexivity</span>. &#125; </span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> -&gt; H.</span><br><span class=\"line\">  <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<p>And print <code>Set Printing Parentheses.</code> to see the\r\nparentheses omitted and better understand <code>rewrite</code> tactic\r\nresult.</p>\r\n<p>Rewrite tactic also serve to specify the elements we want to apply\r\nhypothesis to. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> plus_rearrange : <span class=\"keyword\">forall</span> n m p q : nat,</span><br><span class=\"line\">  (n + m) + (p + q) = (m + n) + (p + q).</span><br><span class=\"line\"><span class=\"comment\">(* Wrong proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m p q.</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> add_comm.</span><br><span class=\"line\">  <span class=\"comment\">(* ==&gt; p + q + (n + m) = m + n + (p + q)</span></span><br><span class=\"line\"><span class=\"comment\">      Obviously that is not what we want.*)</span></span><br><span class=\"line\"><span class=\"keyword\">Abort</span>.</span><br><span class=\"line\"><span class=\"comment\">(* Corrent proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m p q.</span><br><span class=\"line\">  <span class=\"built_in\">assert</span> (H: n + m = m + n).</span><br><span class=\"line\">  &#123; <span class=\"built_in\">rewrite</span> add_comm. <span class=\"built_in\">reflexivity</span>. &#125;</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> H. <span class=\"built_in\">reflexivity</span>.  </span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<!-- As human, we generally do informal proof. -->"},{"title":"Sipser Part One","toc":true,"date":"2023-04-11T08:10:43.000Z","mathjax":true,"_content":"\n\n# Introduction to the Theory of Computation  Michael Sipser\n\nwith MIT 18.404 Theory of Computation\n[2020 Fall PPT](https://math.mit.edu/~sipser/18404/Lectures%20Fall%202020/index.html)\n\n## Part One: Automata and Languages\n\n### Lecture 1\n\n#### Automata, computability and complexity\n\n\nFinite Automaton\n1. a model of computer with limited capacity\n2. state diagram of finite automaton\n\n<!--more-->\n\n- states, transitions, start state, accept states\n- Input: finite string; Output: Accept or Reject\n  - The language of the machine: collection of strings that can be accepted by the machine\n   - A is the language of M <=> M recognize A <=> A = L(M)\n- A Math Def: A finite automaton M is a 5-tuple (Q,$\\mathrm{\\Sigma}$,$\\delta$,$q_0$,F).\n  - Q: finite set of states.\n  - $\\mathrm{\\Sigma}$: finite set of alphabet symbols.\n  - $\\delta$: transition function  $\\delta:Q\\times\\mathrm{\\Sigma}\\rightarrow Q$\n   - F: set of accepted state\n   - Languages and Expressions\n   - \tA **string** is a finite sequence of symbols in $\\mathrm{\\Sigma}$  (the empty string, the string of length 0).\n   - A **language** is a set of strings (finite or infinite)  (the empty language, the set with no strings).\n  - a regular language means that it can be applied to a finite automaton\n     - e.g.: B = { w | w has an even number of 1s}  is regular; while C = {w | w has equal numbers of 0s and 1s} is not regular\n- Regular Expressions\n   - Union: $A\\cup B={w|w \\in A \\in or\\ w\\in B}$\n   - Concatenation: $A\\circ B={xy | x \\in A\\ and \\ y \\in B}=AB$\n   - Star: $A^\\ast={x_1\\ldots x_k|each\\ x_i \\in A \\ fork \\geq 0}$ (we always have $\\epsilon \\in A^\\ast$)\n   - **Theorem**: (Closure under union operation) If $A_1, A_2$ are regular languages, so is $A_1\\cup A_2$\n     - **Proof**: Given $M_1 \\rightarrow A_1$,$M_2 \\rightarrow A_2$, construct $M$ that accept $w$ of $M_1$ or $M_2$ accepts $w$\n      - Components of $M$:\n        - $Q=Q_1\\times Q_2= \\{ \\left( q_1,q_2 \\right) |q_1\\in Q_1 and q_2\\in Q_2 \\} $\n        - $q_0= \\left( q_1,q_2 \\right)$\n        - $\\delta\\left(\\left(q,r\\right),a\\right)=\\left(\\delta_1\\left(q,a\\right),\\delta_2\\left(r,a\\right)\\right)$\n        - $F=\\left(F_1\\times Q_2\\right)\\cup\\left(Q_1\\times F_2\\right)$\n\n- Nondeterministic Finite Automata\n  - Features:\n    - To a given status and a given transition, there might me more than one way to go or having no way to go.\n    - allow $\\epsilon$-transition (“free” movement without reading input)\n    - Accept input if some path lead to accept status (Acceptance overrules rejections)\n  - Definition:\n    - The definition of a NFA is similar to DFA except   $\\delta:Q\\times\\mathrm{\\Sigma}_\\epsilon\\rightarrow P\\left(Q\\right)=R|R\\subseteq Q$\n  - Ways to think about nondeterminism:\n    - Computational: Fork new parallel thread and accept if any thread leads to an accept state\n    - Mathematical: Tree with branches. Accept if any branch leads to an accept state\n    - Magical: Machine always makes the right guess that leads to accepting, if possible.\n  - **Theorem**: If an NFA recognizes A, then A is regular\n    - **Proof**: Let NFA $M=\\left(Q,\\mathrm{\\Sigma},\\delta,q_0,F\\right)$ recognize A, construct DFA $M^\\prime=\\left(Q^\\prime,\\mathrm{\\Sigma},\\delta^\\prime,q_0^\\prime,F^\\prime\\right)$ recognizing A\n  - **Theorem**: If A is a regular language, so is $A^\\ast$\n  - **Theorem**: If R is a regular expo and A = L(R) then A is regular\n\n\n\n### Lecture 3\n\n1. Finite automata $\\rightarrow$ regular expressions.\n2. Proving languages are't regular.\n3. Context free grammars\n\n- DFAs $\\rightarrow$ Regular Expressions\n  - We have just explored conversion R $\\rightarrow$ NFA M $\\rightarrow$ DFA M’\n  - **Theorem**: If A is regular, then A = L(R) for some regular expo R\n  - **Proof**: Give conversion DFA M $\\rightarrow$ R\n\n- Generalized NFA\n  - **Def**: A Generalized Nondeterministic Finite Automaton (GNFA) is similar to an NFA, but allows regular expressions as transition labels\n    - may read a whole string in one step\n    - Assume that: \n      - Only have one accept state, which is separate from the start state (All previous accept state point to a new accept state)\n      - One arrow from each state to each other state, except that we can only exiting the start state and can only entering the accept state (use empty language regular expression)\n    - **Lemma**: Every GNFA has an equivalent regular expression R\n\n<!--  \n![](/img/sipser_lec3_pic1.png)\n-->\n\n  - **Lemma**: Every GNFA has an equivalent regular expression R\n    - **Proof**: By induction on the number of states k of G\n    - Basis: k=2, let R = r.\n    - Induction step (k>2): Assume Lemma true for k-1 states and prove for k states, then convert k state GNFA to equivalent k-1 state GNFA.\n    - So we can convert GNFAs to regular expressions, and similarly we can also convert DFAs to regular expressions.\n  - How  can we prove that a language is not regular?\n    - **Pumping Lemma**: For every regular language A, there is a p such that if $s \\in A$ and $\\left| s \\right| \\geq p$ then $s=xyz$ where\n      - $xy^iz \\in A$ for all $i \\geq 0 y^i=yy...y$\n      - $y \\neq \\epsilon$\n      - $\\left| xy \\right| \\leq p$\n    - Variant: Combine closure properties with the pumping lemma.\n      - Find a contradictory example (which might be denoted by intersection of several languages, this can prove that all the languages are not regular).\n      - Chomsky normal form:\n        - A context-free grammar is in Chomsky normal form if every rule is of the form: $A \\rightarrow BC$, $A \\rightarrow a$  where $a$ is any terminal and $A$,$B$ and $C$ are any variables — except that $B$ and $C$ may not be the start variable. In addition, we permit the rule $S \\rightarrow \\epsilon$, where $S$ is the start variable.\n        - Any context-free language is generated by a context-free grammar in Chomsky normal form.\n\n### Lecture 4: Pushdown Automata, CFG <-> PDA\n\n- **Context Free Grammars**\n  - **Rule**: Variable -> string of variables and terminals\n  - **Variables**: Symbols appearing on left-hand side of rule\n  - **Terminals**:  Symbols appearing only on right-hand side\n  - **Start Variable**: Top left symbol\n  - **Productions**: A grammar consists of a collection of substitution rules\n  - e.g. G1:   S -> 0S1;  S -> R;   R -> $\\epsilon$;\n    - in G1, there are 3 rules, 2 variables (R,S), 2 terminals (0,1), and 1 start variable (S)\n    - Use or (|) symbol to write shorthand rules\n  - **Grammars generate strings**: \n    - Write down start variable.\n    - Replace any variable according to a rule. Repeat until only terminals remain.\n    - Result is the generated string.\n    - L(G) is the language of all generated strings.\n    - We call L(G) a Context Free Language.\n  - **Formal Definition**:\n    - A Context Free Grammar G is a 4-tuple $(V,\\mathrm{\\Sigma},R,S)$\n    - $V$: finite set of variables\n    - $\\Sigma$: finite set of terminal symbols\n    - $R$: finite set of rules\n    - $S$: start variable\n      - for $u,v \\in (V \\cup \\mathrm{\\Sigma})^\\ast$ write\n        - $u \\rightarrow v$ if can go from u to v with one substitution step in G\n        - $u \\overset{*}{\\rightarrow} v$ if can go from u to v with some number of substitution steps in G, and the whole sequence is called a derivation of v from u\n    - A is a Context Free Language if A=L(G) for some CFG G\n      - If a string has two different parse trees then it is derived ambiguously and we say that the grammar is **ambiguous**\n  - Schematic diagram: a higher level description for pushdown automata\n    - Schematic diagram for DFA or NFA:\n      - input appears on a “tape” (or we call it an “input tape”), the tape have a “head”\n      - and we have a finite control unit\n    - Schematic diagram for PDA\n      - there is going to be a (pushdown) stack\n      - PDA might use its stack as a kind of unbounded memory, allow fir operations like write-add (push) or read-remove (pop) symbols from the top of the stack\n        - e.g. the we can construct PDA for $D= \\{ 0^k 1^k | k \\geq 0 \\} $\n          - Read 0s from input, push onto stack until read 1\n          - Read 1s from input, while popping 0s from stack\n          - Enter accept state of stack is empty. Note: acceptance only at end of input.\n      - Formal definition of pushdown automaton\n        - A **Pushdown Atomaton** is a 6-tuple $(Q,\\mathrm{\\Sigma},\\mathrm{\\Gamma},\\delta,q_0,F)$\n        - $\\Sigma$: input alphabet.\n        - $\\Gamma$: stack alphabet.\n        - $\\delta:Q \\times \\mathrm{\\Sigma}_\\epsilon \\times \\mathrm{\\Gamma}_\\epsilon \\rightarrow P \\left( Q \\times \\mathrm{\\Gamma}_\\epsilon \\right) \\delta \\left( q,a,c \\right) = \\left( r_1, d \\right) , \\left( r_2, e \\right) $, use state and symbols to denote the transition movement.\n      - Converting CFGs to PDAs\n        - Theorem: If A is a CFL iff some PDA recognize A\n        - \"->\" can be proved with relative ease.\n        - \"<-\" would be harder\n      - Corollaries\n        - Every regular language is a CFL\n        - If A is a CFL and B is regular, then A $\\cap$ B is a CFL.\n- Recursive\n  - We might divide the process: $A_{pq} \\rightarrow A_{pr} A_{rq}$, $ \\left( A_{pp} \\rightarrow \\epsilon, A_{pq} \\rightarrow a A_{rs} b \\right)$ (where a is the input read at the first move, b is the input read at the last move, r is the state following p, and s is the state preceding q).\n\n\n\n### Lecture 5: CF Pumping Lemma, Turing Machine\n  1. Proving languages not context free\n  2. Turing Machines\n  3. T-recognizable and T-decidable languages\n- Pumping Lemma for CFLs\n  - For every CFL A, there is a p such that if $s\\in A$ and $\\left| s \\right| \\geq p$ then $s=uvxyz$ where  \n    1. $u v^i x y^i z \\in A$ for all $i \\geq 0$\n    2. $vy \\neq \\epsilon$\n    3. $\\left| vxy \\right| \\le p$\n  - Informal definition: All long strings in A are pumpable and stay in A.\n- The class of CFls is closed under intersection, concatenation and kleen star, but not closed under union.\n- Deterministic Context-Free Languages (DCFLs): subset to non-deterministic context-free languages\n  - DCFLs include $0^n1^n$ but do not include $ww^R$.\n  - **Lemma**: Every DPDA has an equivalent DPDA that always reads the entire input string.\n    - To tackle with the problem of hanging and looping, use symbol \\$ as the bottom of the stack. If detected midway, reject; if not detected by the end of input, reject; if detected at previous accept state, accept.\n  - **Theorem**: The class of DCFLs is closed under complementation.\n  - Reject\n    - hanging: when the machine tries to pop an empty stack, initialize the stack with a special symbol to identify this reject situation.\n    - looping: when the machine makes an endless sequence of $\\epsilon$.\n\n\n\n\n","source":"_posts/Sipser-Part-One.md","raw":"---\ntitle: Sipser Part One\ntoc: true\ndate: 2023-04-11 16:10:43\ntags:\ncategories:\nmathjax: true\n---\n\n\n# Introduction to the Theory of Computation  Michael Sipser\n\nwith MIT 18.404 Theory of Computation\n[2020 Fall PPT](https://math.mit.edu/~sipser/18404/Lectures%20Fall%202020/index.html)\n\n## Part One: Automata and Languages\n\n### Lecture 1\n\n#### Automata, computability and complexity\n\n\nFinite Automaton\n1. a model of computer with limited capacity\n2. state diagram of finite automaton\n\n<!--more-->\n\n- states, transitions, start state, accept states\n- Input: finite string; Output: Accept or Reject\n  - The language of the machine: collection of strings that can be accepted by the machine\n   - A is the language of M <=> M recognize A <=> A = L(M)\n- A Math Def: A finite automaton M is a 5-tuple (Q,$\\mathrm{\\Sigma}$,$\\delta$,$q_0$,F).\n  - Q: finite set of states.\n  - $\\mathrm{\\Sigma}$: finite set of alphabet symbols.\n  - $\\delta$: transition function  $\\delta:Q\\times\\mathrm{\\Sigma}\\rightarrow Q$\n   - F: set of accepted state\n   - Languages and Expressions\n   - \tA **string** is a finite sequence of symbols in $\\mathrm{\\Sigma}$  (the empty string, the string of length 0).\n   - A **language** is a set of strings (finite or infinite)  (the empty language, the set with no strings).\n  - a regular language means that it can be applied to a finite automaton\n     - e.g.: B = { w | w has an even number of 1s}  is regular; while C = {w | w has equal numbers of 0s and 1s} is not regular\n- Regular Expressions\n   - Union: $A\\cup B={w|w \\in A \\in or\\ w\\in B}$\n   - Concatenation: $A\\circ B={xy | x \\in A\\ and \\ y \\in B}=AB$\n   - Star: $A^\\ast={x_1\\ldots x_k|each\\ x_i \\in A \\ fork \\geq 0}$ (we always have $\\epsilon \\in A^\\ast$)\n   - **Theorem**: (Closure under union operation) If $A_1, A_2$ are regular languages, so is $A_1\\cup A_2$\n     - **Proof**: Given $M_1 \\rightarrow A_1$,$M_2 \\rightarrow A_2$, construct $M$ that accept $w$ of $M_1$ or $M_2$ accepts $w$\n      - Components of $M$:\n        - $Q=Q_1\\times Q_2= \\{ \\left( q_1,q_2 \\right) |q_1\\in Q_1 and q_2\\in Q_2 \\} $\n        - $q_0= \\left( q_1,q_2 \\right)$\n        - $\\delta\\left(\\left(q,r\\right),a\\right)=\\left(\\delta_1\\left(q,a\\right),\\delta_2\\left(r,a\\right)\\right)$\n        - $F=\\left(F_1\\times Q_2\\right)\\cup\\left(Q_1\\times F_2\\right)$\n\n- Nondeterministic Finite Automata\n  - Features:\n    - To a given status and a given transition, there might me more than one way to go or having no way to go.\n    - allow $\\epsilon$-transition (“free” movement without reading input)\n    - Accept input if some path lead to accept status (Acceptance overrules rejections)\n  - Definition:\n    - The definition of a NFA is similar to DFA except   $\\delta:Q\\times\\mathrm{\\Sigma}_\\epsilon\\rightarrow P\\left(Q\\right)=R|R\\subseteq Q$\n  - Ways to think about nondeterminism:\n    - Computational: Fork new parallel thread and accept if any thread leads to an accept state\n    - Mathematical: Tree with branches. Accept if any branch leads to an accept state\n    - Magical: Machine always makes the right guess that leads to accepting, if possible.\n  - **Theorem**: If an NFA recognizes A, then A is regular\n    - **Proof**: Let NFA $M=\\left(Q,\\mathrm{\\Sigma},\\delta,q_0,F\\right)$ recognize A, construct DFA $M^\\prime=\\left(Q^\\prime,\\mathrm{\\Sigma},\\delta^\\prime,q_0^\\prime,F^\\prime\\right)$ recognizing A\n  - **Theorem**: If A is a regular language, so is $A^\\ast$\n  - **Theorem**: If R is a regular expo and A = L(R) then A is regular\n\n\n\n### Lecture 3\n\n1. Finite automata $\\rightarrow$ regular expressions.\n2. Proving languages are't regular.\n3. Context free grammars\n\n- DFAs $\\rightarrow$ Regular Expressions\n  - We have just explored conversion R $\\rightarrow$ NFA M $\\rightarrow$ DFA M’\n  - **Theorem**: If A is regular, then A = L(R) for some regular expo R\n  - **Proof**: Give conversion DFA M $\\rightarrow$ R\n\n- Generalized NFA\n  - **Def**: A Generalized Nondeterministic Finite Automaton (GNFA) is similar to an NFA, but allows regular expressions as transition labels\n    - may read a whole string in one step\n    - Assume that: \n      - Only have one accept state, which is separate from the start state (All previous accept state point to a new accept state)\n      - One arrow from each state to each other state, except that we can only exiting the start state and can only entering the accept state (use empty language regular expression)\n    - **Lemma**: Every GNFA has an equivalent regular expression R\n\n<!--  \n![](/img/sipser_lec3_pic1.png)\n-->\n\n  - **Lemma**: Every GNFA has an equivalent regular expression R\n    - **Proof**: By induction on the number of states k of G\n    - Basis: k=2, let R = r.\n    - Induction step (k>2): Assume Lemma true for k-1 states and prove for k states, then convert k state GNFA to equivalent k-1 state GNFA.\n    - So we can convert GNFAs to regular expressions, and similarly we can also convert DFAs to regular expressions.\n  - How  can we prove that a language is not regular?\n    - **Pumping Lemma**: For every regular language A, there is a p such that if $s \\in A$ and $\\left| s \\right| \\geq p$ then $s=xyz$ where\n      - $xy^iz \\in A$ for all $i \\geq 0 y^i=yy...y$\n      - $y \\neq \\epsilon$\n      - $\\left| xy \\right| \\leq p$\n    - Variant: Combine closure properties with the pumping lemma.\n      - Find a contradictory example (which might be denoted by intersection of several languages, this can prove that all the languages are not regular).\n      - Chomsky normal form:\n        - A context-free grammar is in Chomsky normal form if every rule is of the form: $A \\rightarrow BC$, $A \\rightarrow a$  where $a$ is any terminal and $A$,$B$ and $C$ are any variables — except that $B$ and $C$ may not be the start variable. In addition, we permit the rule $S \\rightarrow \\epsilon$, where $S$ is the start variable.\n        - Any context-free language is generated by a context-free grammar in Chomsky normal form.\n\n### Lecture 4: Pushdown Automata, CFG <-> PDA\n\n- **Context Free Grammars**\n  - **Rule**: Variable -> string of variables and terminals\n  - **Variables**: Symbols appearing on left-hand side of rule\n  - **Terminals**:  Symbols appearing only on right-hand side\n  - **Start Variable**: Top left symbol\n  - **Productions**: A grammar consists of a collection of substitution rules\n  - e.g. G1:   S -> 0S1;  S -> R;   R -> $\\epsilon$;\n    - in G1, there are 3 rules, 2 variables (R,S), 2 terminals (0,1), and 1 start variable (S)\n    - Use or (|) symbol to write shorthand rules\n  - **Grammars generate strings**: \n    - Write down start variable.\n    - Replace any variable according to a rule. Repeat until only terminals remain.\n    - Result is the generated string.\n    - L(G) is the language of all generated strings.\n    - We call L(G) a Context Free Language.\n  - **Formal Definition**:\n    - A Context Free Grammar G is a 4-tuple $(V,\\mathrm{\\Sigma},R,S)$\n    - $V$: finite set of variables\n    - $\\Sigma$: finite set of terminal symbols\n    - $R$: finite set of rules\n    - $S$: start variable\n      - for $u,v \\in (V \\cup \\mathrm{\\Sigma})^\\ast$ write\n        - $u \\rightarrow v$ if can go from u to v with one substitution step in G\n        - $u \\overset{*}{\\rightarrow} v$ if can go from u to v with some number of substitution steps in G, and the whole sequence is called a derivation of v from u\n    - A is a Context Free Language if A=L(G) for some CFG G\n      - If a string has two different parse trees then it is derived ambiguously and we say that the grammar is **ambiguous**\n  - Schematic diagram: a higher level description for pushdown automata\n    - Schematic diagram for DFA or NFA:\n      - input appears on a “tape” (or we call it an “input tape”), the tape have a “head”\n      - and we have a finite control unit\n    - Schematic diagram for PDA\n      - there is going to be a (pushdown) stack\n      - PDA might use its stack as a kind of unbounded memory, allow fir operations like write-add (push) or read-remove (pop) symbols from the top of the stack\n        - e.g. the we can construct PDA for $D= \\{ 0^k 1^k | k \\geq 0 \\} $\n          - Read 0s from input, push onto stack until read 1\n          - Read 1s from input, while popping 0s from stack\n          - Enter accept state of stack is empty. Note: acceptance only at end of input.\n      - Formal definition of pushdown automaton\n        - A **Pushdown Atomaton** is a 6-tuple $(Q,\\mathrm{\\Sigma},\\mathrm{\\Gamma},\\delta,q_0,F)$\n        - $\\Sigma$: input alphabet.\n        - $\\Gamma$: stack alphabet.\n        - $\\delta:Q \\times \\mathrm{\\Sigma}_\\epsilon \\times \\mathrm{\\Gamma}_\\epsilon \\rightarrow P \\left( Q \\times \\mathrm{\\Gamma}_\\epsilon \\right) \\delta \\left( q,a,c \\right) = \\left( r_1, d \\right) , \\left( r_2, e \\right) $, use state and symbols to denote the transition movement.\n      - Converting CFGs to PDAs\n        - Theorem: If A is a CFL iff some PDA recognize A\n        - \"->\" can be proved with relative ease.\n        - \"<-\" would be harder\n      - Corollaries\n        - Every regular language is a CFL\n        - If A is a CFL and B is regular, then A $\\cap$ B is a CFL.\n- Recursive\n  - We might divide the process: $A_{pq} \\rightarrow A_{pr} A_{rq}$, $ \\left( A_{pp} \\rightarrow \\epsilon, A_{pq} \\rightarrow a A_{rs} b \\right)$ (where a is the input read at the first move, b is the input read at the last move, r is the state following p, and s is the state preceding q).\n\n\n\n### Lecture 5: CF Pumping Lemma, Turing Machine\n  1. Proving languages not context free\n  2. Turing Machines\n  3. T-recognizable and T-decidable languages\n- Pumping Lemma for CFLs\n  - For every CFL A, there is a p such that if $s\\in A$ and $\\left| s \\right| \\geq p$ then $s=uvxyz$ where  \n    1. $u v^i x y^i z \\in A$ for all $i \\geq 0$\n    2. $vy \\neq \\epsilon$\n    3. $\\left| vxy \\right| \\le p$\n  - Informal definition: All long strings in A are pumpable and stay in A.\n- The class of CFls is closed under intersection, concatenation and kleen star, but not closed under union.\n- Deterministic Context-Free Languages (DCFLs): subset to non-deterministic context-free languages\n  - DCFLs include $0^n1^n$ but do not include $ww^R$.\n  - **Lemma**: Every DPDA has an equivalent DPDA that always reads the entire input string.\n    - To tackle with the problem of hanging and looping, use symbol \\$ as the bottom of the stack. If detected midway, reject; if not detected by the end of input, reject; if detected at previous accept state, accept.\n  - **Theorem**: The class of DCFLs is closed under complementation.\n  - Reject\n    - hanging: when the machine tries to pop an empty stack, initialize the stack with a special symbol to identify this reject situation.\n    - looping: when the machine makes an endless sequence of $\\epsilon$.\n\n\n\n\n","slug":"Sipser-Part-One","published":1,"updated":"2023-04-11T08:34:15.338Z","_id":"clgbzoyc60000lgmvfei144h3","comments":1,"layout":"post","photos":[],"link":"","content":"<h1\r\nid=\"introduction-to-the-theory-of-computation-michael-sipser\">Introduction\r\nto the Theory of Computation Michael Sipser</h1>\r\n<p>with MIT 18.404 Theory of Computation <a\r\nhref=\"https://math.mit.edu/~sipser/18404/Lectures%20Fall%202020/index.html\">2020\r\nFall PPT</a></p>\r\n<h2 id=\"part-one-automata-and-languages\">Part One: Automata and\r\nLanguages</h2>\r\n<h3 id=\"lecture-1\">Lecture 1</h3>\r\n<h4 id=\"automata-computability-and-complexity\">Automata, computability\r\nand complexity</h4>\r\n<p>Finite Automaton 1. a model of computer with limited capacity 2.\r\nstate diagram of finite automaton</p>\r\n<span id=\"more\"></span>\r\n<ul>\r\n<li>states, transitions, start state, accept states</li>\r\n<li>Input: finite string; Output: Accept or Reject\r\n<ul>\r\n<li>The language of the machine: collection of strings that can be\r\naccepted by the machine</li>\r\n<li>A is the language of M &lt;=&gt; M recognize A &lt;=&gt; A =\r\nL(M)</li>\r\n</ul></li>\r\n<li>A Math Def: A finite automaton M is a 5-tuple (Q,<span\r\nclass=\"math inline\">\\(\\mathrm{\\Sigma}\\)</span>,<span\r\nclass=\"math inline\">\\(\\delta\\)</span>,<span\r\nclass=\"math inline\">\\(q_0\\)</span>,F).\r\n<ul>\r\n<li>Q: finite set of states.</li>\r\n<li><span class=\"math inline\">\\(\\mathrm{\\Sigma}\\)</span>: finite set of\r\nalphabet symbols.</li>\r\n<li><span class=\"math inline\">\\(\\delta\\)</span>: transition function\r\n<span class=\"math inline\">\\(\\delta:Q\\times\\mathrm{\\Sigma}\\rightarrow\r\nQ\\)</span></li>\r\n<li>F: set of accepted state</li>\r\n<li>Languages and Expressions</li>\r\n<li>A <strong>string</strong> is a finite sequence of symbols in <span\r\nclass=\"math inline\">\\(\\mathrm{\\Sigma}\\)</span> (the empty string, the\r\nstring of length 0).</li>\r\n<li>A <strong>language</strong> is a set of strings (finite or infinite)\r\n(the empty language, the set with no strings).</li>\r\n<li>a regular language means that it can be applied to a finite\r\nautomaton\r\n<ul>\r\n<li>e.g.: B = { w | w has an even number of 1s} is regular; while C = {w\r\n| w has equal numbers of 0s and 1s} is not regular</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Regular Expressions\r\n<ul>\r\n<li>Union: <span class=\"math inline\">\\(A\\cup B={w|w \\in A \\in or\\ w\\in\r\nB}\\)</span></li>\r\n<li>Concatenation: <span class=\"math inline\">\\(A\\circ B={xy | x \\in A\\\r\nand \\ y \\in B}=AB\\)</span></li>\r\n<li>Star: <span class=\"math inline\">\\(A^\\ast={x_1\\ldots x_k|each\\ x_i\r\n\\in A \\ fork \\geq 0}\\)</span> (we always have <span\r\nclass=\"math inline\">\\(\\epsilon \\in A^\\ast\\)</span>)</li>\r\n<li><strong>Theorem</strong>: (Closure under union operation) If <span\r\nclass=\"math inline\">\\(A_1, A_2\\)</span> are regular languages, so is\r\n<span class=\"math inline\">\\(A_1\\cup A_2\\)</span>\r\n<ul>\r\n<li><strong>Proof</strong>: Given <span class=\"math inline\">\\(M_1\r\n\\rightarrow A_1\\)</span>,<span class=\"math inline\">\\(M_2 \\rightarrow\r\nA_2\\)</span>, construct <span class=\"math inline\">\\(M\\)</span> that\r\naccept <span class=\"math inline\">\\(w\\)</span> of <span\r\nclass=\"math inline\">\\(M_1\\)</span> or <span\r\nclass=\"math inline\">\\(M_2\\)</span> accepts <span\r\nclass=\"math inline\">\\(w\\)</span></li>\r\n<li>Components of <span class=\"math inline\">\\(M\\)</span>:\r\n<ul>\r\n<li>$Q=Q_1Q_2= { ( q_1,q_2 ) |q_1Q_1 and q_2Q_2 } $</li>\r\n<li><span class=\"math inline\">\\(q_0= \\left( q_1,q_2\r\n\\right)\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\delta\\left(\\left(q,r\\right),a\\right)=\\left(\\delta_1\\left(q,a\\right),\\delta_2\\left(r,a\\right)\\right)\\)</span></li>\r\n<li><span class=\"math inline\">\\(F=\\left(F_1\\times\r\nQ_2\\right)\\cup\\left(Q_1\\times F_2\\right)\\)</span></li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Nondeterministic Finite Automata\r\n<ul>\r\n<li>Features:\r\n<ul>\r\n<li>To a given status and a given transition, there might me more than\r\none way to go or having no way to go.</li>\r\n<li>allow <span class=\"math inline\">\\(\\epsilon\\)</span>-transition\r\n(“free” movement without reading input)</li>\r\n<li>Accept input if some path lead to accept status (Acceptance\r\noverrules rejections)</li>\r\n</ul></li>\r\n<li>Definition:\r\n<ul>\r\n<li>The definition of a NFA is similar to DFA except <span\r\nclass=\"math inline\">\\(\\delta:Q\\times\\mathrm{\\Sigma}_\\epsilon\\rightarrow\r\nP\\left(Q\\right)=R|R\\subseteq Q\\)</span></li>\r\n</ul></li>\r\n<li>Ways to think about nondeterminism:\r\n<ul>\r\n<li>Computational: Fork new parallel thread and accept if any thread\r\nleads to an accept state</li>\r\n<li>Mathematical: Tree with branches. Accept if any branch leads to an\r\naccept state</li>\r\n<li>Magical: Machine always makes the right guess that leads to\r\naccepting, if possible.</li>\r\n</ul></li>\r\n<li><strong>Theorem</strong>: If an NFA recognizes A, then A is regular\r\n<ul>\r\n<li><strong>Proof</strong>: Let NFA <span\r\nclass=\"math inline\">\\(M=\\left(Q,\\mathrm{\\Sigma},\\delta,q_0,F\\right)\\)</span>\r\nrecognize A, construct DFA <span\r\nclass=\"math inline\">\\(M^\\prime=\\left(Q^\\prime,\\mathrm{\\Sigma},\\delta^\\prime,q_0^\\prime,F^\\prime\\right)\\)</span>\r\nrecognizing A</li>\r\n</ul></li>\r\n<li><strong>Theorem</strong>: If A is a regular language, so is <span\r\nclass=\"math inline\">\\(A^\\ast\\)</span></li>\r\n<li><strong>Theorem</strong>: If R is a regular expo and A = L(R) then A\r\nis regular</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"lecture-3\">Lecture 3</h3>\r\n<ol type=\"1\">\r\n<li>Finite automata <span class=\"math inline\">\\(\\rightarrow\\)</span>\r\nregular expressions.</li>\r\n<li>Proving languages are't regular.</li>\r\n<li>Context free grammars</li>\r\n</ol>\r\n<ul>\r\n<li>DFAs <span class=\"math inline\">\\(\\rightarrow\\)</span> Regular\r\nExpressions\r\n<ul>\r\n<li>We have just explored conversion R <span\r\nclass=\"math inline\">\\(\\rightarrow\\)</span> NFA M <span\r\nclass=\"math inline\">\\(\\rightarrow\\)</span> DFA M’</li>\r\n<li><strong>Theorem</strong>: If A is regular, then A = L(R) for some\r\nregular expo R</li>\r\n<li><strong>Proof</strong>: Give conversion DFA M <span\r\nclass=\"math inline\">\\(\\rightarrow\\)</span> R</li>\r\n</ul></li>\r\n<li>Generalized NFA\r\n<ul>\r\n<li><strong>Def</strong>: A Generalized Nondeterministic Finite\r\nAutomaton (GNFA) is similar to an NFA, but allows regular expressions as\r\ntransition labels\r\n<ul>\r\n<li>may read a whole string in one step</li>\r\n<li>Assume that:\r\n<ul>\r\n<li>Only have one accept state, which is separate from the start state\r\n(All previous accept state point to a new accept state)</li>\r\n<li>One arrow from each state to each other state, except that we can\r\nonly exiting the start state and can only entering the accept state (use\r\nempty language regular expression)</li>\r\n</ul></li>\r\n<li><strong>Lemma</strong>: Every GNFA has an equivalent regular\r\nexpression R</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<!--  \r\n![](/img/sipser_lec3_pic1.png)\r\n-->\r\n<ul>\r\n<li><strong>Lemma</strong>: Every GNFA has an equivalent regular\r\nexpression R\r\n<ul>\r\n<li><strong>Proof</strong>: By induction on the number of states k of\r\nG</li>\r\n<li>Basis: k=2, let R = r.</li>\r\n<li>Induction step (k&gt;2): Assume Lemma true for k-1 states and prove\r\nfor k states, then convert k state GNFA to equivalent k-1 state\r\nGNFA.</li>\r\n<li>So we can convert GNFAs to regular expressions, and similarly we can\r\nalso convert DFAs to regular expressions.</li>\r\n</ul></li>\r\n<li>How can we prove that a language is not regular?\r\n<ul>\r\n<li><strong>Pumping Lemma</strong>: For every regular language A, there\r\nis a p such that if <span class=\"math inline\">\\(s \\in A\\)</span> and\r\n<span class=\"math inline\">\\(\\left| s \\right| \\geq p\\)</span> then <span\r\nclass=\"math inline\">\\(s=xyz\\)</span> where\r\n<ul>\r\n<li><span class=\"math inline\">\\(xy^iz \\in A\\)</span> for all <span\r\nclass=\"math inline\">\\(i \\geq 0 y^i=yy...y\\)</span></li>\r\n<li><span class=\"math inline\">\\(y \\neq \\epsilon\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\left| xy \\right| \\leq p\\)</span></li>\r\n</ul></li>\r\n<li>Variant: Combine closure properties with the pumping lemma.\r\n<ul>\r\n<li>Find a contradictory example (which might be denoted by intersection\r\nof several languages, this can prove that all the languages are not\r\nregular).</li>\r\n<li>Chomsky normal form:\r\n<ul>\r\n<li>A context-free grammar is in Chomsky normal form if every rule is of\r\nthe form: <span class=\"math inline\">\\(A \\rightarrow BC\\)</span>, <span\r\nclass=\"math inline\">\\(A \\rightarrow a\\)</span> where <span\r\nclass=\"math inline\">\\(a\\)</span> is any terminal and <span\r\nclass=\"math inline\">\\(A\\)</span>,<span class=\"math inline\">\\(B\\)</span>\r\nand <span class=\"math inline\">\\(C\\)</span> are any variables — except\r\nthat <span class=\"math inline\">\\(B\\)</span> and <span\r\nclass=\"math inline\">\\(C\\)</span> may not be the start variable. In\r\naddition, we permit the rule <span class=\"math inline\">\\(S \\rightarrow\r\n\\epsilon\\)</span>, where <span class=\"math inline\">\\(S\\)</span> is the\r\nstart variable.</li>\r\n<li>Any context-free language is generated by a context-free grammar in\r\nChomsky normal form.</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"lecture-4-pushdown-automata-cfg---pda\">Lecture 4: Pushdown\r\nAutomata, CFG &lt;-&gt; PDA</h3>\r\n<ul>\r\n<li><strong>Context Free Grammars</strong>\r\n<ul>\r\n<li><strong>Rule</strong>: Variable -&gt; string of variables and\r\nterminals</li>\r\n<li><strong>Variables</strong>: Symbols appearing on left-hand side of\r\nrule</li>\r\n<li><strong>Terminals</strong>: Symbols appearing only on right-hand\r\nside</li>\r\n<li><strong>Start Variable</strong>: Top left symbol</li>\r\n<li><strong>Productions</strong>: A grammar consists of a collection of\r\nsubstitution rules</li>\r\n<li>e.g. G1: S -&gt; 0S1; S -&gt; R; R -&gt; <span\r\nclass=\"math inline\">\\(\\epsilon\\)</span>;\r\n<ul>\r\n<li>in G1, there are 3 rules, 2 variables (R,S), 2 terminals (0,1), and\r\n1 start variable (S)</li>\r\n<li>Use or (|) symbol to write shorthand rules</li>\r\n</ul></li>\r\n<li><strong>Grammars generate strings</strong>:\r\n<ul>\r\n<li>Write down start variable.</li>\r\n<li>Replace any variable according to a rule. Repeat until only\r\nterminals remain.</li>\r\n<li>Result is the generated string.</li>\r\n<li>L(G) is the language of all generated strings.</li>\r\n<li>We call L(G) a Context Free Language.</li>\r\n</ul></li>\r\n<li><strong>Formal Definition</strong>:\r\n<ul>\r\n<li>A Context Free Grammar G is a 4-tuple <span\r\nclass=\"math inline\">\\((V,\\mathrm{\\Sigma},R,S)\\)</span></li>\r\n<li><span class=\"math inline\">\\(V\\)</span>: finite set of variables</li>\r\n<li><span class=\"math inline\">\\(\\Sigma\\)</span>: finite set of terminal\r\nsymbols</li>\r\n<li><span class=\"math inline\">\\(R\\)</span>: finite set of rules</li>\r\n<li><span class=\"math inline\">\\(S\\)</span>: start variable\r\n<ul>\r\n<li>for <span class=\"math inline\">\\(u,v \\in (V \\cup\r\n\\mathrm{\\Sigma})^\\ast\\)</span> write\r\n<ul>\r\n<li><span class=\"math inline\">\\(u \\rightarrow v\\)</span> if can go from\r\nu to v with one substitution step in G</li>\r\n<li><span class=\"math inline\">\\(u \\overset{*}{\\rightarrow} v\\)</span> if\r\ncan go from u to v with some number of substitution steps in G, and the\r\nwhole sequence is called a derivation of v from u</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>A is a Context Free Language if A=L(G) for some CFG G\r\n<ul>\r\n<li>If a string has two different parse trees then it is derived\r\nambiguously and we say that the grammar is\r\n<strong>ambiguous</strong></li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Schematic diagram: a higher level description for pushdown automata\r\n<ul>\r\n<li>Schematic diagram for DFA or NFA:\r\n<ul>\r\n<li>input appears on a “tape” (or we call it an “input tape”), the tape\r\nhave a “head”</li>\r\n<li>and we have a finite control unit</li>\r\n</ul></li>\r\n<li>Schematic diagram for PDA\r\n<ul>\r\n<li>there is going to be a (pushdown) stack</li>\r\n<li>PDA might use its stack as a kind of unbounded memory, allow fir\r\noperations like write-add (push) or read-remove (pop) symbols from the\r\ntop of the stack\r\n<ul>\r\n<li>e.g. the we can construct PDA for $D= { 0^k 1^k | k } $\r\n<ul>\r\n<li>Read 0s from input, push onto stack until read 1</li>\r\n<li>Read 1s from input, while popping 0s from stack</li>\r\n<li>Enter accept state of stack is empty. Note: acceptance only at end\r\nof input.</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Formal definition of pushdown automaton\r\n<ul>\r\n<li>A <strong>Pushdown Atomaton</strong> is a 6-tuple <span\r\nclass=\"math inline\">\\((Q,\\mathrm{\\Sigma},\\mathrm{\\Gamma},\\delta,q_0,F)\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\Sigma\\)</span>: input alphabet.</li>\r\n<li><span class=\"math inline\">\\(\\Gamma\\)</span>: stack alphabet.</li>\r\n<li>$:Q <em></em>P ( Q _) ( q,a,c ) = ( r_1, d ) , ( r_2, e ) $, use\r\nstate and symbols to denote the transition movement.</li>\r\n</ul></li>\r\n<li>Converting CFGs to PDAs\r\n<ul>\r\n<li>Theorem: If A is a CFL iff some PDA recognize A</li>\r\n<li>\"-&gt;\" can be proved with relative ease.</li>\r\n<li>\"&lt;-\" would be harder</li>\r\n</ul></li>\r\n<li>Corollaries\r\n<ul>\r\n<li>Every regular language is a CFL</li>\r\n<li>If A is a CFL and B is regular, then A <span\r\nclass=\"math inline\">\\(\\cap\\)</span> B is a CFL.</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Recursive\r\n<ul>\r\n<li>We might divide the process: <span class=\"math inline\">\\(A_{pq}\r\n\\rightarrow A_{pr} A_{rq}\\)</span>, $ ( A_{pp} , A_{pq} a A_{rs} b )$\r\n(where a is the input read at the first move, b is the input read at the\r\nlast move, r is the state following p, and s is the state preceding\r\nq).</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"lecture-5-cf-pumping-lemma-turing-machine\">Lecture 5: CF Pumping\r\nLemma, Turing Machine</h3>\r\n<ol type=\"1\">\r\n<li>Proving languages not context free</li>\r\n<li>Turing Machines</li>\r\n<li>T-recognizable and T-decidable languages</li>\r\n</ol>\r\n<ul>\r\n<li>Pumping Lemma for CFLs\r\n<ul>\r\n<li>For every CFL A, there is a p such that if <span\r\nclass=\"math inline\">\\(s\\in A\\)</span> and <span\r\nclass=\"math inline\">\\(\\left| s \\right| \\geq p\\)</span> then <span\r\nclass=\"math inline\">\\(s=uvxyz\\)</span> where\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(u v^i x y^i z \\in A\\)</span> for all\r\n<span class=\"math inline\">\\(i \\geq 0\\)</span></li>\r\n<li><span class=\"math inline\">\\(vy \\neq \\epsilon\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\left| vxy \\right| \\le p\\)</span></li>\r\n</ol></li>\r\n<li>Informal definition: All long strings in A are pumpable and stay in\r\nA.</li>\r\n</ul></li>\r\n<li>The class of CFls is closed under intersection, concatenation and\r\nkleen star, but not closed under union.</li>\r\n<li>Deterministic Context-Free Languages (DCFLs): subset to\r\nnon-deterministic context-free languages\r\n<ul>\r\n<li>DCFLs include <span class=\"math inline\">\\(0^n1^n\\)</span> but do not\r\ninclude <span class=\"math inline\">\\(ww^R\\)</span>.</li>\r\n<li><strong>Lemma</strong>: Every DPDA has an equivalent DPDA that\r\nalways reads the entire input string.\r\n<ul>\r\n<li>To tackle with the problem of hanging and looping, use symbol $ as\r\nthe bottom of the stack. If detected midway, reject; if not detected by\r\nthe end of input, reject; if detected at previous accept state,\r\naccept.</li>\r\n</ul></li>\r\n<li><strong>Theorem</strong>: The class of DCFLs is closed under\r\ncomplementation.</li>\r\n<li>Reject\r\n<ul>\r\n<li>hanging: when the machine tries to pop an empty stack, initialize\r\nthe stack with a special symbol to identify this reject situation.</li>\r\n<li>looping: when the machine makes an endless sequence of <span\r\nclass=\"math inline\">\\(\\epsilon\\)</span>.</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n","site":{"data":{}},"excerpt":"<h1\r\nid=\"introduction-to-the-theory-of-computation-michael-sipser\">Introduction\r\nto the Theory of Computation Michael Sipser</h1>\r\n<p>with MIT 18.404 Theory of Computation <a\r\nhref=\"https://math.mit.edu/~sipser/18404/Lectures%20Fall%202020/index.html\">2020\r\nFall PPT</a></p>\r\n<h2 id=\"part-one-automata-and-languages\">Part One: Automata and\r\nLanguages</h2>\r\n<h3 id=\"lecture-1\">Lecture 1</h3>\r\n<h4 id=\"automata-computability-and-complexity\">Automata, computability\r\nand complexity</h4>\r\n<p>Finite Automaton 1. a model of computer with limited capacity 2.\r\nstate diagram of finite automaton</p>","more":"<ul>\r\n<li>states, transitions, start state, accept states</li>\r\n<li>Input: finite string; Output: Accept or Reject\r\n<ul>\r\n<li>The language of the machine: collection of strings that can be\r\naccepted by the machine</li>\r\n<li>A is the language of M &lt;=&gt; M recognize A &lt;=&gt; A =\r\nL(M)</li>\r\n</ul></li>\r\n<li>A Math Def: A finite automaton M is a 5-tuple (Q,<span\r\nclass=\"math inline\">\\(\\mathrm{\\Sigma}\\)</span>,<span\r\nclass=\"math inline\">\\(\\delta\\)</span>,<span\r\nclass=\"math inline\">\\(q_0\\)</span>,F).\r\n<ul>\r\n<li>Q: finite set of states.</li>\r\n<li><span class=\"math inline\">\\(\\mathrm{\\Sigma}\\)</span>: finite set of\r\nalphabet symbols.</li>\r\n<li><span class=\"math inline\">\\(\\delta\\)</span>: transition function\r\n<span class=\"math inline\">\\(\\delta:Q\\times\\mathrm{\\Sigma}\\rightarrow\r\nQ\\)</span></li>\r\n<li>F: set of accepted state</li>\r\n<li>Languages and Expressions</li>\r\n<li>A <strong>string</strong> is a finite sequence of symbols in <span\r\nclass=\"math inline\">\\(\\mathrm{\\Sigma}\\)</span> (the empty string, the\r\nstring of length 0).</li>\r\n<li>A <strong>language</strong> is a set of strings (finite or infinite)\r\n(the empty language, the set with no strings).</li>\r\n<li>a regular language means that it can be applied to a finite\r\nautomaton\r\n<ul>\r\n<li>e.g.: B = { w | w has an even number of 1s} is regular; while C = {w\r\n| w has equal numbers of 0s and 1s} is not regular</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Regular Expressions\r\n<ul>\r\n<li>Union: <span class=\"math inline\">\\(A\\cup B={w|w \\in A \\in or\\ w\\in\r\nB}\\)</span></li>\r\n<li>Concatenation: <span class=\"math inline\">\\(A\\circ B={xy | x \\in A\\\r\nand \\ y \\in B}=AB\\)</span></li>\r\n<li>Star: <span class=\"math inline\">\\(A^\\ast={x_1\\ldots x_k|each\\ x_i\r\n\\in A \\ fork \\geq 0}\\)</span> (we always have <span\r\nclass=\"math inline\">\\(\\epsilon \\in A^\\ast\\)</span>)</li>\r\n<li><strong>Theorem</strong>: (Closure under union operation) If <span\r\nclass=\"math inline\">\\(A_1, A_2\\)</span> are regular languages, so is\r\n<span class=\"math inline\">\\(A_1\\cup A_2\\)</span>\r\n<ul>\r\n<li><strong>Proof</strong>: Given <span class=\"math inline\">\\(M_1\r\n\\rightarrow A_1\\)</span>,<span class=\"math inline\">\\(M_2 \\rightarrow\r\nA_2\\)</span>, construct <span class=\"math inline\">\\(M\\)</span> that\r\naccept <span class=\"math inline\">\\(w\\)</span> of <span\r\nclass=\"math inline\">\\(M_1\\)</span> or <span\r\nclass=\"math inline\">\\(M_2\\)</span> accepts <span\r\nclass=\"math inline\">\\(w\\)</span></li>\r\n<li>Components of <span class=\"math inline\">\\(M\\)</span>:\r\n<ul>\r\n<li>$Q=Q_1Q_2= { ( q_1,q_2 ) |q_1Q_1 and q_2Q_2 } $</li>\r\n<li><span class=\"math inline\">\\(q_0= \\left( q_1,q_2\r\n\\right)\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\delta\\left(\\left(q,r\\right),a\\right)=\\left(\\delta_1\\left(q,a\\right),\\delta_2\\left(r,a\\right)\\right)\\)</span></li>\r\n<li><span class=\"math inline\">\\(F=\\left(F_1\\times\r\nQ_2\\right)\\cup\\left(Q_1\\times F_2\\right)\\)</span></li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Nondeterministic Finite Automata\r\n<ul>\r\n<li>Features:\r\n<ul>\r\n<li>To a given status and a given transition, there might me more than\r\none way to go or having no way to go.</li>\r\n<li>allow <span class=\"math inline\">\\(\\epsilon\\)</span>-transition\r\n(“free” movement without reading input)</li>\r\n<li>Accept input if some path lead to accept status (Acceptance\r\noverrules rejections)</li>\r\n</ul></li>\r\n<li>Definition:\r\n<ul>\r\n<li>The definition of a NFA is similar to DFA except <span\r\nclass=\"math inline\">\\(\\delta:Q\\times\\mathrm{\\Sigma}_\\epsilon\\rightarrow\r\nP\\left(Q\\right)=R|R\\subseteq Q\\)</span></li>\r\n</ul></li>\r\n<li>Ways to think about nondeterminism:\r\n<ul>\r\n<li>Computational: Fork new parallel thread and accept if any thread\r\nleads to an accept state</li>\r\n<li>Mathematical: Tree with branches. Accept if any branch leads to an\r\naccept state</li>\r\n<li>Magical: Machine always makes the right guess that leads to\r\naccepting, if possible.</li>\r\n</ul></li>\r\n<li><strong>Theorem</strong>: If an NFA recognizes A, then A is regular\r\n<ul>\r\n<li><strong>Proof</strong>: Let NFA <span\r\nclass=\"math inline\">\\(M=\\left(Q,\\mathrm{\\Sigma},\\delta,q_0,F\\right)\\)</span>\r\nrecognize A, construct DFA <span\r\nclass=\"math inline\">\\(M^\\prime=\\left(Q^\\prime,\\mathrm{\\Sigma},\\delta^\\prime,q_0^\\prime,F^\\prime\\right)\\)</span>\r\nrecognizing A</li>\r\n</ul></li>\r\n<li><strong>Theorem</strong>: If A is a regular language, so is <span\r\nclass=\"math inline\">\\(A^\\ast\\)</span></li>\r\n<li><strong>Theorem</strong>: If R is a regular expo and A = L(R) then A\r\nis regular</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"lecture-3\">Lecture 3</h3>\r\n<ol type=\"1\">\r\n<li>Finite automata <span class=\"math inline\">\\(\\rightarrow\\)</span>\r\nregular expressions.</li>\r\n<li>Proving languages are't regular.</li>\r\n<li>Context free grammars</li>\r\n</ol>\r\n<ul>\r\n<li>DFAs <span class=\"math inline\">\\(\\rightarrow\\)</span> Regular\r\nExpressions\r\n<ul>\r\n<li>We have just explored conversion R <span\r\nclass=\"math inline\">\\(\\rightarrow\\)</span> NFA M <span\r\nclass=\"math inline\">\\(\\rightarrow\\)</span> DFA M’</li>\r\n<li><strong>Theorem</strong>: If A is regular, then A = L(R) for some\r\nregular expo R</li>\r\n<li><strong>Proof</strong>: Give conversion DFA M <span\r\nclass=\"math inline\">\\(\\rightarrow\\)</span> R</li>\r\n</ul></li>\r\n<li>Generalized NFA\r\n<ul>\r\n<li><strong>Def</strong>: A Generalized Nondeterministic Finite\r\nAutomaton (GNFA) is similar to an NFA, but allows regular expressions as\r\ntransition labels\r\n<ul>\r\n<li>may read a whole string in one step</li>\r\n<li>Assume that:\r\n<ul>\r\n<li>Only have one accept state, which is separate from the start state\r\n(All previous accept state point to a new accept state)</li>\r\n<li>One arrow from each state to each other state, except that we can\r\nonly exiting the start state and can only entering the accept state (use\r\nempty language regular expression)</li>\r\n</ul></li>\r\n<li><strong>Lemma</strong>: Every GNFA has an equivalent regular\r\nexpression R</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<!--  \r\n![](/img/sipser_lec3_pic1.png)\r\n-->\r\n<ul>\r\n<li><strong>Lemma</strong>: Every GNFA has an equivalent regular\r\nexpression R\r\n<ul>\r\n<li><strong>Proof</strong>: By induction on the number of states k of\r\nG</li>\r\n<li>Basis: k=2, let R = r.</li>\r\n<li>Induction step (k&gt;2): Assume Lemma true for k-1 states and prove\r\nfor k states, then convert k state GNFA to equivalent k-1 state\r\nGNFA.</li>\r\n<li>So we can convert GNFAs to regular expressions, and similarly we can\r\nalso convert DFAs to regular expressions.</li>\r\n</ul></li>\r\n<li>How can we prove that a language is not regular?\r\n<ul>\r\n<li><strong>Pumping Lemma</strong>: For every regular language A, there\r\nis a p such that if <span class=\"math inline\">\\(s \\in A\\)</span> and\r\n<span class=\"math inline\">\\(\\left| s \\right| \\geq p\\)</span> then <span\r\nclass=\"math inline\">\\(s=xyz\\)</span> where\r\n<ul>\r\n<li><span class=\"math inline\">\\(xy^iz \\in A\\)</span> for all <span\r\nclass=\"math inline\">\\(i \\geq 0 y^i=yy...y\\)</span></li>\r\n<li><span class=\"math inline\">\\(y \\neq \\epsilon\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\left| xy \\right| \\leq p\\)</span></li>\r\n</ul></li>\r\n<li>Variant: Combine closure properties with the pumping lemma.\r\n<ul>\r\n<li>Find a contradictory example (which might be denoted by intersection\r\nof several languages, this can prove that all the languages are not\r\nregular).</li>\r\n<li>Chomsky normal form:\r\n<ul>\r\n<li>A context-free grammar is in Chomsky normal form if every rule is of\r\nthe form: <span class=\"math inline\">\\(A \\rightarrow BC\\)</span>, <span\r\nclass=\"math inline\">\\(A \\rightarrow a\\)</span> where <span\r\nclass=\"math inline\">\\(a\\)</span> is any terminal and <span\r\nclass=\"math inline\">\\(A\\)</span>,<span class=\"math inline\">\\(B\\)</span>\r\nand <span class=\"math inline\">\\(C\\)</span> are any variables — except\r\nthat <span class=\"math inline\">\\(B\\)</span> and <span\r\nclass=\"math inline\">\\(C\\)</span> may not be the start variable. In\r\naddition, we permit the rule <span class=\"math inline\">\\(S \\rightarrow\r\n\\epsilon\\)</span>, where <span class=\"math inline\">\\(S\\)</span> is the\r\nstart variable.</li>\r\n<li>Any context-free language is generated by a context-free grammar in\r\nChomsky normal form.</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"lecture-4-pushdown-automata-cfg---pda\">Lecture 4: Pushdown\r\nAutomata, CFG &lt;-&gt; PDA</h3>\r\n<ul>\r\n<li><strong>Context Free Grammars</strong>\r\n<ul>\r\n<li><strong>Rule</strong>: Variable -&gt; string of variables and\r\nterminals</li>\r\n<li><strong>Variables</strong>: Symbols appearing on left-hand side of\r\nrule</li>\r\n<li><strong>Terminals</strong>: Symbols appearing only on right-hand\r\nside</li>\r\n<li><strong>Start Variable</strong>: Top left symbol</li>\r\n<li><strong>Productions</strong>: A grammar consists of a collection of\r\nsubstitution rules</li>\r\n<li>e.g. G1: S -&gt; 0S1; S -&gt; R; R -&gt; <span\r\nclass=\"math inline\">\\(\\epsilon\\)</span>;\r\n<ul>\r\n<li>in G1, there are 3 rules, 2 variables (R,S), 2 terminals (0,1), and\r\n1 start variable (S)</li>\r\n<li>Use or (|) symbol to write shorthand rules</li>\r\n</ul></li>\r\n<li><strong>Grammars generate strings</strong>:\r\n<ul>\r\n<li>Write down start variable.</li>\r\n<li>Replace any variable according to a rule. Repeat until only\r\nterminals remain.</li>\r\n<li>Result is the generated string.</li>\r\n<li>L(G) is the language of all generated strings.</li>\r\n<li>We call L(G) a Context Free Language.</li>\r\n</ul></li>\r\n<li><strong>Formal Definition</strong>:\r\n<ul>\r\n<li>A Context Free Grammar G is a 4-tuple <span\r\nclass=\"math inline\">\\((V,\\mathrm{\\Sigma},R,S)\\)</span></li>\r\n<li><span class=\"math inline\">\\(V\\)</span>: finite set of variables</li>\r\n<li><span class=\"math inline\">\\(\\Sigma\\)</span>: finite set of terminal\r\nsymbols</li>\r\n<li><span class=\"math inline\">\\(R\\)</span>: finite set of rules</li>\r\n<li><span class=\"math inline\">\\(S\\)</span>: start variable\r\n<ul>\r\n<li>for <span class=\"math inline\">\\(u,v \\in (V \\cup\r\n\\mathrm{\\Sigma})^\\ast\\)</span> write\r\n<ul>\r\n<li><span class=\"math inline\">\\(u \\rightarrow v\\)</span> if can go from\r\nu to v with one substitution step in G</li>\r\n<li><span class=\"math inline\">\\(u \\overset{*}{\\rightarrow} v\\)</span> if\r\ncan go from u to v with some number of substitution steps in G, and the\r\nwhole sequence is called a derivation of v from u</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>A is a Context Free Language if A=L(G) for some CFG G\r\n<ul>\r\n<li>If a string has two different parse trees then it is derived\r\nambiguously and we say that the grammar is\r\n<strong>ambiguous</strong></li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Schematic diagram: a higher level description for pushdown automata\r\n<ul>\r\n<li>Schematic diagram for DFA or NFA:\r\n<ul>\r\n<li>input appears on a “tape” (or we call it an “input tape”), the tape\r\nhave a “head”</li>\r\n<li>and we have a finite control unit</li>\r\n</ul></li>\r\n<li>Schematic diagram for PDA\r\n<ul>\r\n<li>there is going to be a (pushdown) stack</li>\r\n<li>PDA might use its stack as a kind of unbounded memory, allow fir\r\noperations like write-add (push) or read-remove (pop) symbols from the\r\ntop of the stack\r\n<ul>\r\n<li>e.g. the we can construct PDA for $D= { 0^k 1^k | k } $\r\n<ul>\r\n<li>Read 0s from input, push onto stack until read 1</li>\r\n<li>Read 1s from input, while popping 0s from stack</li>\r\n<li>Enter accept state of stack is empty. Note: acceptance only at end\r\nof input.</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Formal definition of pushdown automaton\r\n<ul>\r\n<li>A <strong>Pushdown Atomaton</strong> is a 6-tuple <span\r\nclass=\"math inline\">\\((Q,\\mathrm{\\Sigma},\\mathrm{\\Gamma},\\delta,q_0,F)\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\Sigma\\)</span>: input alphabet.</li>\r\n<li><span class=\"math inline\">\\(\\Gamma\\)</span>: stack alphabet.</li>\r\n<li>$:Q <em></em>P ( Q _) ( q,a,c ) = ( r_1, d ) , ( r_2, e ) $, use\r\nstate and symbols to denote the transition movement.</li>\r\n</ul></li>\r\n<li>Converting CFGs to PDAs\r\n<ul>\r\n<li>Theorem: If A is a CFL iff some PDA recognize A</li>\r\n<li>\"-&gt;\" can be proved with relative ease.</li>\r\n<li>\"&lt;-\" would be harder</li>\r\n</ul></li>\r\n<li>Corollaries\r\n<ul>\r\n<li>Every regular language is a CFL</li>\r\n<li>If A is a CFL and B is regular, then A <span\r\nclass=\"math inline\">\\(\\cap\\)</span> B is a CFL.</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Recursive\r\n<ul>\r\n<li>We might divide the process: <span class=\"math inline\">\\(A_{pq}\r\n\\rightarrow A_{pr} A_{rq}\\)</span>, $ ( A_{pp} , A_{pq} a A_{rs} b )$\r\n(where a is the input read at the first move, b is the input read at the\r\nlast move, r is the state following p, and s is the state preceding\r\nq).</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"lecture-5-cf-pumping-lemma-turing-machine\">Lecture 5: CF Pumping\r\nLemma, Turing Machine</h3>\r\n<ol type=\"1\">\r\n<li>Proving languages not context free</li>\r\n<li>Turing Machines</li>\r\n<li>T-recognizable and T-decidable languages</li>\r\n</ol>\r\n<ul>\r\n<li>Pumping Lemma for CFLs\r\n<ul>\r\n<li>For every CFL A, there is a p such that if <span\r\nclass=\"math inline\">\\(s\\in A\\)</span> and <span\r\nclass=\"math inline\">\\(\\left| s \\right| \\geq p\\)</span> then <span\r\nclass=\"math inline\">\\(s=uvxyz\\)</span> where\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(u v^i x y^i z \\in A\\)</span> for all\r\n<span class=\"math inline\">\\(i \\geq 0\\)</span></li>\r\n<li><span class=\"math inline\">\\(vy \\neq \\epsilon\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\left| vxy \\right| \\le p\\)</span></li>\r\n</ol></li>\r\n<li>Informal definition: All long strings in A are pumpable and stay in\r\nA.</li>\r\n</ul></li>\r\n<li>The class of CFls is closed under intersection, concatenation and\r\nkleen star, but not closed under union.</li>\r\n<li>Deterministic Context-Free Languages (DCFLs): subset to\r\nnon-deterministic context-free languages\r\n<ul>\r\n<li>DCFLs include <span class=\"math inline\">\\(0^n1^n\\)</span> but do not\r\ninclude <span class=\"math inline\">\\(ww^R\\)</span>.</li>\r\n<li><strong>Lemma</strong>: Every DPDA has an equivalent DPDA that\r\nalways reads the entire input string.\r\n<ul>\r\n<li>To tackle with the problem of hanging and looping, use symbol $ as\r\nthe bottom of the stack. If detected midway, reject; if not detected by\r\nthe end of input, reject; if detected at previous accept state,\r\naccept.</li>\r\n</ul></li>\r\n<li><strong>Theorem</strong>: The class of DCFLs is closed under\r\ncomplementation.</li>\r\n<li>Reject\r\n<ul>\r\n<li>hanging: when the machine tries to pop an empty stack, initialize\r\nthe stack with a special symbol to identify this reject situation.</li>\r\n<li>looping: when the machine makes an endless sequence of <span\r\nclass=\"math inline\">\\(\\epsilon\\)</span>.</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>"},{"title":"Software Foundations 04 Lists","toc":true,"date":"2023-04-11T08:21:47.000Z","_content":"\n# Software Foundations\n\n[Online Textbook](https://softwarefoundations.cis.upenn.edu/lf-current/index.html)\n\n[Michael Clarkson's Open Online Course (on Youtube)](https://www.youtube.com/watch?v=BGg-gxhsV4E)\n[Michael Charkson's Course (on Bilibili)](https://www.bilibili.com/video/BV1kd4y1t7bw/)\n\n[Xiong Yingfei's Course Webpage (2023 Spring)](https://xiongyingfei.github.io/SF/2023/lectures.html)\n\nThis note is used as a brief summary and supplementofr the textbook and courses.\n\n## Lists\n\n### Pairs\n\nWe define the pair of natural numbers. (Cartesian product)\n```Coq\nInductive natprod : Type :=\n  | pair (n1 n2 : nat).\n\nDefinition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end.\n\nDefinition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end.\n\nNotation \"( x , y )\" := (pair x y).\n```\n\n<!--more-->\n\nThen comes a new usage of `destruct`:\n\n```Coq\nTheorem surjective_pairing : forall (p : natprod),\n  p = (fst p, snd p).\n(* Wrong proof *)\nProof.\n  simpl. (* Doesn't reduce anything! *)\nAbort.\n(* Correct proof *)\nProof.\n  intros p. destruct p as [n m]. simpl. reflexivity. \nQed.\n```\n\n\n### Lists of Natural Numbers\n\n```Coq\nInductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist).\n\nNotation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity).\nNotation \"[ ]\" := nil.\nNotation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..).\n```\n\nThe concatenation operation of `natlist` is then defined as follows.\n```Coq\nFixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end.\nNotation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60).\n```\n\n\nThen comes the usage of `destruct`:\n```Coq\nTheorem tl_length_pred : forall l:natlist,\n  pred (length l) = length (tl l).\nProof.\n  intros l. destruct l as [| n l'].\n  - (* l = nil *)\n    reflexivity.\n  - (* l = cons n l' *)\n    reflexivity.  \nQed.\n```\n\nAnd of `instruction`\n```Coq\nTheorem app_assoc : forall l1 l2 l3 : natlist,\n  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).\nProof.\n  intros l1 l2 l3. induction l1 as [| n l1' IHl1'].\n  - (* l1 = nil *)\n    reflexivity.\n  - (* l1 = cons n l1' *)\n    simpl. rewrite -> IHl1'. reflexivity.  \nQed.\n```\n\n\n### `Search` Command\n\n```Coq\n\n(** Display a list of all theorems involving [rev]:  *)\nSearch rev.\n\n(** Use a pattern to search for all theorems involving the equality of two additions: *)\nSearch (_ + _ = _ + _).\n\n(** Search inside a particular module as a restriction: *)\nSearch (_ + _ = _ + _) inside Induction.\n\n(** Make the search more precise by using variables in the search pattern instead of wildcards: *)\nSearch (?x + ?y = ?y + ?x).\n```\n\n\n\n### Options\n\n```Coq\nInductive natoption : Type :=\n  | Some (n : nat)\n  | None.\n```\n\nRecall Haskell's `Maybe`, `Nothing` and `Just`.\n\n\n### Partial Maps\n\n```Coq\nInductive id : Type :=\n  | Id (n : nat).\n\nInductive partial_map : Type :=\n  | empty\n  | record (i : id) (v : nat) (m : partial_map).\n\nDefinition update (d : partial_map) (x : id) (value : nat) : partial_map :=\n  record x value d.\n```\n\n\n\n\n","source":"_posts/Software-Foundations-04-Lists.md","raw":"---\ntitle: Software Foundations 04 Lists\ntoc: true\ndate: 2023-04-11 16:21:47\ntags:\ncategories:\n---\n\n# Software Foundations\n\n[Online Textbook](https://softwarefoundations.cis.upenn.edu/lf-current/index.html)\n\n[Michael Clarkson's Open Online Course (on Youtube)](https://www.youtube.com/watch?v=BGg-gxhsV4E)\n[Michael Charkson's Course (on Bilibili)](https://www.bilibili.com/video/BV1kd4y1t7bw/)\n\n[Xiong Yingfei's Course Webpage (2023 Spring)](https://xiongyingfei.github.io/SF/2023/lectures.html)\n\nThis note is used as a brief summary and supplementofr the textbook and courses.\n\n## Lists\n\n### Pairs\n\nWe define the pair of natural numbers. (Cartesian product)\n```Coq\nInductive natprod : Type :=\n  | pair (n1 n2 : nat).\n\nDefinition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end.\n\nDefinition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end.\n\nNotation \"( x , y )\" := (pair x y).\n```\n\n<!--more-->\n\nThen comes a new usage of `destruct`:\n\n```Coq\nTheorem surjective_pairing : forall (p : natprod),\n  p = (fst p, snd p).\n(* Wrong proof *)\nProof.\n  simpl. (* Doesn't reduce anything! *)\nAbort.\n(* Correct proof *)\nProof.\n  intros p. destruct p as [n m]. simpl. reflexivity. \nQed.\n```\n\n\n### Lists of Natural Numbers\n\n```Coq\nInductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist).\n\nNotation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity).\nNotation \"[ ]\" := nil.\nNotation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..).\n```\n\nThe concatenation operation of `natlist` is then defined as follows.\n```Coq\nFixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end.\nNotation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60).\n```\n\n\nThen comes the usage of `destruct`:\n```Coq\nTheorem tl_length_pred : forall l:natlist,\n  pred (length l) = length (tl l).\nProof.\n  intros l. destruct l as [| n l'].\n  - (* l = nil *)\n    reflexivity.\n  - (* l = cons n l' *)\n    reflexivity.  \nQed.\n```\n\nAnd of `instruction`\n```Coq\nTheorem app_assoc : forall l1 l2 l3 : natlist,\n  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).\nProof.\n  intros l1 l2 l3. induction l1 as [| n l1' IHl1'].\n  - (* l1 = nil *)\n    reflexivity.\n  - (* l1 = cons n l1' *)\n    simpl. rewrite -> IHl1'. reflexivity.  \nQed.\n```\n\n\n### `Search` Command\n\n```Coq\n\n(** Display a list of all theorems involving [rev]:  *)\nSearch rev.\n\n(** Use a pattern to search for all theorems involving the equality of two additions: *)\nSearch (_ + _ = _ + _).\n\n(** Search inside a particular module as a restriction: *)\nSearch (_ + _ = _ + _) inside Induction.\n\n(** Make the search more precise by using variables in the search pattern instead of wildcards: *)\nSearch (?x + ?y = ?y + ?x).\n```\n\n\n\n### Options\n\n```Coq\nInductive natoption : Type :=\n  | Some (n : nat)\n  | None.\n```\n\nRecall Haskell's `Maybe`, `Nothing` and `Just`.\n\n\n### Partial Maps\n\n```Coq\nInductive id : Type :=\n  | Id (n : nat).\n\nInductive partial_map : Type :=\n  | empty\n  | record (i : id) (v : nat) (m : partial_map).\n\nDefinition update (d : partial_map) (x : id) (value : nat) : partial_map :=\n  record x value d.\n```\n\n\n\n\n","slug":"Software-Foundations-04-Lists","published":1,"updated":"2023-04-11T08:22:33.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbzyn7p0000m8mv832tggr6","content":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<p><a\r\nhref=\"https://softwarefoundations.cis.upenn.edu/lf-current/index.html\">Online\r\nTextbook</a></p>\r\n<p><a href=\"https://www.youtube.com/watch?v=BGg-gxhsV4E\">Michael\r\nClarkson's Open Online Course (on Youtube)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1kd4y1t7bw/\">Michael Charkson's\r\nCourse (on Bilibili)</a></p>\r\n<p><a href=\"https://xiongyingfei.github.io/SF/2023/lectures.html\">Xiong\r\nYingfei's Course Webpage (2023 Spring)</a></p>\r\n<p>This note is used as a brief summary and supplementofr the textbook\r\nand courses.</p>\r\n<h2 id=\"lists\">Lists</h2>\r\n<h3 id=\"pairs\">Pairs</h3>\r\n<p>We define the pair of natural numbers. (Cartesian product)\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> natprod : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">pair</span> (n1 n2 : nat).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Definition</span> fst (p : natprod) : nat :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> p <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">pair</span> x y =&gt; x</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Definition</span> snd (p : natprod) : nat :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> p <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">pair</span> x y =&gt; y</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;( x , y )&quot;</span> := (pair x y).</span><br></pre></td></tr></table></figure></p>\r\n<span id=\"more\"></span>\r\n<p>Then comes a new usage of <code>destruct</code>:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> surjective_pairing : <span class=\"keyword\">forall</span> (p : natprod),</span><br><span class=\"line\">  p = (fst p, snd p).</span><br><span class=\"line\"><span class=\"comment\">(* Wrong proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">simpl</span>. <span class=\"comment\">(* Doesn&#x27;t reduce anything! *)</span></span><br><span class=\"line\"><span class=\"keyword\">Abort</span>.</span><br><span class=\"line\"><span class=\"comment\">(* Correct proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> p. <span class=\"built_in\">destruct</span> p <span class=\"built_in\">as</span> [n m]. <span class=\"built_in\">simpl</span>. <span class=\"built_in\">reflexivity</span>. </span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"lists-of-natural-numbers\">Lists of Natural Numbers</h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> natlist : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">nil</span></span><br><span class=\"line\">  | <span class=\"type\">cons</span> (n : nat) (l : natlist).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x :: l&quot;</span> := (cons x l)</span><br><span class=\"line\">                     (<span class=\"built_in\">at</span> level <span class=\"number\">60</span>, <span class=\"built_in\">right</span> associativity).</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;[ ]&quot;</span> := nil.</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;[ x ; .. ; y ]&quot;</span> := (cons x .. (cons y nil) ..).</span><br></pre></td></tr></table></figure>\r\n<p>The concatenation operation of <code>natlist</code> is then defined\r\nas follows. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> app (l1 l2 : natlist) : natlist :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> l1 <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">nil</span>    =&gt; l2</span><br><span class=\"line\">  | <span class=\"type\">h</span> :: t =&gt; h :: (app t l2)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x ++ y&quot;</span> := (app x y)</span><br><span class=\"line\">                     (<span class=\"built_in\">right</span> associativity, <span class=\"built_in\">at</span> level <span class=\"number\">60</span>).</span><br></pre></td></tr></table></figure></p>\r\n<p>Then comes the usage of <code>destruct</code>: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> tl_length_pred : <span class=\"keyword\">forall</span> l:natlist,</span><br><span class=\"line\">  pred (length l) = length (tl l).</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> l. <span class=\"built_in\">destruct</span> l <span class=\"built_in\">as</span> [| <span class=\"type\">n</span> l&#x27;].</span><br><span class=\"line\">  - <span class=\"comment\">(* l = nil *)</span></span><br><span class=\"line\">    <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"comment\">(* l = cons n l&#x27; *)</span></span><br><span class=\"line\">    <span class=\"built_in\">reflexivity</span>.  </span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>And of <code>instruction</code> <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> app_assoc : <span class=\"keyword\">forall</span> l1 l2 l3 : natlist,</span><br><span class=\"line\">  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> l1 l2 l3. <span class=\"built_in\">induction</span> l1 <span class=\"built_in\">as</span> [| <span class=\"type\">n</span> l1&#x27; IHl1&#x27;].</span><br><span class=\"line\">  - <span class=\"comment\">(* l1 = nil *)</span></span><br><span class=\"line\">    <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"comment\">(* l1 = cons n l1&#x27; *)</span></span><br><span class=\"line\">    <span class=\"built_in\">simpl</span>. <span class=\"built_in\">rewrite</span> -&gt; IHl1&#x27;. <span class=\"built_in\">reflexivity</span>.  </span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"search-command\"><code>Search</code> Command</h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">(** Display a list of all theorems involving [rev]:  *)</span></span><br><span class=\"line\"><span class=\"keyword\">Search</span> rev.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">(** Use a pattern to search for all theorems involving the equality of two additions: *)</span></span><br><span class=\"line\"><span class=\"keyword\">Search</span> (<span class=\"keyword\">_</span> + <span class=\"keyword\">_</span> = <span class=\"keyword\">_</span> + <span class=\"keyword\">_</span>).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">(** Search inside a particular module as a restriction: *)</span></span><br><span class=\"line\"><span class=\"keyword\">Search</span> (<span class=\"keyword\">_</span> + <span class=\"keyword\">_</span> = <span class=\"keyword\">_</span> + <span class=\"keyword\">_</span>) inside Induction.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">(** Make the search more precise by using variables in the search pattern instead of wildcards: *)</span></span><br><span class=\"line\"><span class=\"keyword\">Search</span> (?x + ?y = ?y + ?x).</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"options\">Options</h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> natoption : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">Some</span> (n : nat)</span><br><span class=\"line\">  | <span class=\"type\">None</span>.</span><br></pre></td></tr></table></figure>\r\n<p>Recall Haskell's <code>Maybe</code>, <code>Nothing</code> and\r\n<code>Just</code>.</p>\r\n<h3 id=\"partial-maps\">Partial Maps</h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> id : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">Id</span> (n : nat).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Inductive</span> partial_map : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">empty</span></span><br><span class=\"line\">  | <span class=\"type\">record</span> (i : id) (v : nat) (m : partial_map).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Definition</span> update (d : partial_map) (x : id) (value : nat) : partial_map :=</span><br><span class=\"line\">  <span class=\"built_in\">record</span> x value d.</span><br></pre></td></tr></table></figure>\r\n","site":{"data":{}},"excerpt":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<p><a\r\nhref=\"https://softwarefoundations.cis.upenn.edu/lf-current/index.html\">Online\r\nTextbook</a></p>\r\n<p><a href=\"https://www.youtube.com/watch?v=BGg-gxhsV4E\">Michael\r\nClarkson's Open Online Course (on Youtube)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1kd4y1t7bw/\">Michael Charkson's\r\nCourse (on Bilibili)</a></p>\r\n<p><a href=\"https://xiongyingfei.github.io/SF/2023/lectures.html\">Xiong\r\nYingfei's Course Webpage (2023 Spring)</a></p>\r\n<p>This note is used as a brief summary and supplementofr the textbook\r\nand courses.</p>\r\n<h2 id=\"lists\">Lists</h2>\r\n<h3 id=\"pairs\">Pairs</h3>\r\n<p>We define the pair of natural numbers. (Cartesian product)\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> natprod : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">pair</span> (n1 n2 : nat).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Definition</span> fst (p : natprod) : nat :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> p <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">pair</span> x y =&gt; x</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Definition</span> snd (p : natprod) : nat :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> p <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">pair</span> x y =&gt; y</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;( x , y )&quot;</span> := (pair x y).</span><br></pre></td></tr></table></figure></p>","more":"<p>Then comes a new usage of <code>destruct</code>:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> surjective_pairing : <span class=\"keyword\">forall</span> (p : natprod),</span><br><span class=\"line\">  p = (fst p, snd p).</span><br><span class=\"line\"><span class=\"comment\">(* Wrong proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">simpl</span>. <span class=\"comment\">(* Doesn&#x27;t reduce anything! *)</span></span><br><span class=\"line\"><span class=\"keyword\">Abort</span>.</span><br><span class=\"line\"><span class=\"comment\">(* Correct proof *)</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> p. <span class=\"built_in\">destruct</span> p <span class=\"built_in\">as</span> [n m]. <span class=\"built_in\">simpl</span>. <span class=\"built_in\">reflexivity</span>. </span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"lists-of-natural-numbers\">Lists of Natural Numbers</h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> natlist : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">nil</span></span><br><span class=\"line\">  | <span class=\"type\">cons</span> (n : nat) (l : natlist).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x :: l&quot;</span> := (cons x l)</span><br><span class=\"line\">                     (<span class=\"built_in\">at</span> level <span class=\"number\">60</span>, <span class=\"built_in\">right</span> associativity).</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;[ ]&quot;</span> := nil.</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;[ x ; .. ; y ]&quot;</span> := (cons x .. (cons y nil) ..).</span><br></pre></td></tr></table></figure>\r\n<p>The concatenation operation of <code>natlist</code> is then defined\r\nas follows. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> app (l1 l2 : natlist) : natlist :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> l1 <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">nil</span>    =&gt; l2</span><br><span class=\"line\">  | <span class=\"type\">h</span> :: t =&gt; h :: (app t l2)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;x ++ y&quot;</span> := (app x y)</span><br><span class=\"line\">                     (<span class=\"built_in\">right</span> associativity, <span class=\"built_in\">at</span> level <span class=\"number\">60</span>).</span><br></pre></td></tr></table></figure></p>\r\n<p>Then comes the usage of <code>destruct</code>: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> tl_length_pred : <span class=\"keyword\">forall</span> l:natlist,</span><br><span class=\"line\">  pred (length l) = length (tl l).</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> l. <span class=\"built_in\">destruct</span> l <span class=\"built_in\">as</span> [| <span class=\"type\">n</span> l&#x27;].</span><br><span class=\"line\">  - <span class=\"comment\">(* l = nil *)</span></span><br><span class=\"line\">    <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"comment\">(* l = cons n l&#x27; *)</span></span><br><span class=\"line\">    <span class=\"built_in\">reflexivity</span>.  </span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>And of <code>instruction</code> <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> app_assoc : <span class=\"keyword\">forall</span> l1 l2 l3 : natlist,</span><br><span class=\"line\">  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> l1 l2 l3. <span class=\"built_in\">induction</span> l1 <span class=\"built_in\">as</span> [| <span class=\"type\">n</span> l1&#x27; IHl1&#x27;].</span><br><span class=\"line\">  - <span class=\"comment\">(* l1 = nil *)</span></span><br><span class=\"line\">    <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"comment\">(* l1 = cons n l1&#x27; *)</span></span><br><span class=\"line\">    <span class=\"built_in\">simpl</span>. <span class=\"built_in\">rewrite</span> -&gt; IHl1&#x27;. <span class=\"built_in\">reflexivity</span>.  </span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"search-command\"><code>Search</code> Command</h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">(** Display a list of all theorems involving [rev]:  *)</span></span><br><span class=\"line\"><span class=\"keyword\">Search</span> rev.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">(** Use a pattern to search for all theorems involving the equality of two additions: *)</span></span><br><span class=\"line\"><span class=\"keyword\">Search</span> (<span class=\"keyword\">_</span> + <span class=\"keyword\">_</span> = <span class=\"keyword\">_</span> + <span class=\"keyword\">_</span>).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">(** Search inside a particular module as a restriction: *)</span></span><br><span class=\"line\"><span class=\"keyword\">Search</span> (<span class=\"keyword\">_</span> + <span class=\"keyword\">_</span> = <span class=\"keyword\">_</span> + <span class=\"keyword\">_</span>) inside Induction.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">(** Make the search more precise by using variables in the search pattern instead of wildcards: *)</span></span><br><span class=\"line\"><span class=\"keyword\">Search</span> (?x + ?y = ?y + ?x).</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"options\">Options</h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> natoption : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">Some</span> (n : nat)</span><br><span class=\"line\">  | <span class=\"type\">None</span>.</span><br></pre></td></tr></table></figure>\r\n<p>Recall Haskell's <code>Maybe</code>, <code>Nothing</code> and\r\n<code>Just</code>.</p>\r\n<h3 id=\"partial-maps\">Partial Maps</h3>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> id : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">Id</span> (n : nat).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Inductive</span> partial_map : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">empty</span></span><br><span class=\"line\">  | <span class=\"type\">record</span> (i : id) (v : nat) (m : partial_map).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Definition</span> update (d : partial_map) (x : id) (value : nat) : partial_map :=</span><br><span class=\"line\">  <span class=\"built_in\">record</span> x value d.</span><br></pre></td></tr></table></figure>"},{"title":"Software Foundations 05 Poly","toc":true,"date":"2023-04-11T08:22:56.000Z","_content":"\n\n# Software Foundations\n\n[Online Textbook](https://softwarefoundations.cis.upenn.edu/lf-current/index.html)\n\n[Michael Clarkson's Open Online Course (on Youtube)](https://www.youtube.com/watch?v=BGg-gxhsV4E)\n[Michael Charkson's Course (on Bilibili)](https://www.bilibili.com/video/BV1kd4y1t7bw/)\n\n[Xiong Yingfei's Course Webpage (2023 Spring)](https://xiongyingfei.github.io/SF/2023/lectures.html)\n\nThis note is used as a brief summary and supplementofr the textbook and courses.\n\n\n## Poly\n\n### Polymorphism\n\n\n#### Omit Type Argument\n\n```Coq\nInductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X).\n```\nThe type list is thus parameterized on another type X.\n\n<!--more-->\n\nWhen we want to avoid typing the type, and let Coq to infer it. We can set:\n```Coq\nArguments nil {X}.\nArguments cons {X}.\nArguments repeat {X}.\n\nFixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end.\n```\n\n#### Catesian Product\n\n```Coq\nInductive prod (X Y : Type) : Type :=\n| pair (x : X) (y : Y).\n\nArguments pair {X} {Y}.\n\nNotation \"( x , y )\" := (pair x y).\nNotation \"X * Y\" := (prod X Y) : type_scope.\n(** (The annotation [: type_scope] tells Coq that this abbreviation\n    should only be used when parsing types, not when parsing\n    expressions.  This avoids a clash with the multiplication\n    symbol.) *)\n```\n\n\n### Higher-Order Functions\n\nFunctions that manipulate other functions are often called **higher-order** functions.\n\nFor example, we have `filter` function\n```Coq\nFixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=\n  match l with\n  | [] => []\n  | h :: t =>\n    if test h then h :: (filter test t)\n    else filter test t\n  end.\n```\n\n#### Functions That Construct Functions\n\nFunctions that return the given functor whatever the argument is.\n```Coq\nDefinition constfun {X: Type} (x: X) : nat -> X :=\n  fun (k:nat) => x.\n\nDefinition ftrue := constfun true.\n\nExample constfun_example1 : ftrue 0 = true.\nProof. reflexivity. Qed.\n```\n\nThis function seems useless, but there is a usage of higher-order functions, let's now mock function currying:\n```Coq\nDefinition plus3 := plus 3.\n\nExample test_plus3 :    plus3 4 = 7.\nProof. reflexivity. Qed.\n```\n\n\n\n### Anonymous Functions\n\nJust like $\\lambda$ function in Haskell, the difference is that Coq use `fun` instead of `\\` to denote this.\n\n```Coq\nExample test_filter2':\n    filter (fun l => (length l) =? 1)\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].\nProof. reflexivity. Qed.\n```\n\n### Map & Fold\n\n`map` is also a function that is useful and interesting:\n```Coq\nFixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=\n  match l with\n  | []     => []\n  | h :: t => (f h) :: (map f t)\n  end.\n```\n\nTake `None` value into consideration, we define:\n```Coq\nDefinition option_map {X Y : Type} (f : X -> Y) (xo : option X)\n                      : option Y :=\n  match xo with\n  | None => None\n  | Some x => Some (f x)\n  end.\n```\n\nAnd you can't miss `fold`, another fantastic function:\n```Coq\nFixpoint fold {X Y: Type} (f : X->Y->Y) (l : list X) (b : Y)\n                         : Y :=\n  match l with\n  | nil => b\n  | h :: t => f h (fold f t b)\n  end.\n```\n\n\n\n\n","source":"_posts/Software-Foundations-05-Poly.md","raw":"---\ntitle: Software Foundations 05 Poly\ntoc: true\ndate: 2023-04-11 16:22:56\ntags:\ncategories:\n---\n\n\n# Software Foundations\n\n[Online Textbook](https://softwarefoundations.cis.upenn.edu/lf-current/index.html)\n\n[Michael Clarkson's Open Online Course (on Youtube)](https://www.youtube.com/watch?v=BGg-gxhsV4E)\n[Michael Charkson's Course (on Bilibili)](https://www.bilibili.com/video/BV1kd4y1t7bw/)\n\n[Xiong Yingfei's Course Webpage (2023 Spring)](https://xiongyingfei.github.io/SF/2023/lectures.html)\n\nThis note is used as a brief summary and supplementofr the textbook and courses.\n\n\n## Poly\n\n### Polymorphism\n\n\n#### Omit Type Argument\n\n```Coq\nInductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X).\n```\nThe type list is thus parameterized on another type X.\n\n<!--more-->\n\nWhen we want to avoid typing the type, and let Coq to infer it. We can set:\n```Coq\nArguments nil {X}.\nArguments cons {X}.\nArguments repeat {X}.\n\nFixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end.\n```\n\n#### Catesian Product\n\n```Coq\nInductive prod (X Y : Type) : Type :=\n| pair (x : X) (y : Y).\n\nArguments pair {X} {Y}.\n\nNotation \"( x , y )\" := (pair x y).\nNotation \"X * Y\" := (prod X Y) : type_scope.\n(** (The annotation [: type_scope] tells Coq that this abbreviation\n    should only be used when parsing types, not when parsing\n    expressions.  This avoids a clash with the multiplication\n    symbol.) *)\n```\n\n\n### Higher-Order Functions\n\nFunctions that manipulate other functions are often called **higher-order** functions.\n\nFor example, we have `filter` function\n```Coq\nFixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=\n  match l with\n  | [] => []\n  | h :: t =>\n    if test h then h :: (filter test t)\n    else filter test t\n  end.\n```\n\n#### Functions That Construct Functions\n\nFunctions that return the given functor whatever the argument is.\n```Coq\nDefinition constfun {X: Type} (x: X) : nat -> X :=\n  fun (k:nat) => x.\n\nDefinition ftrue := constfun true.\n\nExample constfun_example1 : ftrue 0 = true.\nProof. reflexivity. Qed.\n```\n\nThis function seems useless, but there is a usage of higher-order functions, let's now mock function currying:\n```Coq\nDefinition plus3 := plus 3.\n\nExample test_plus3 :    plus3 4 = 7.\nProof. reflexivity. Qed.\n```\n\n\n\n### Anonymous Functions\n\nJust like $\\lambda$ function in Haskell, the difference is that Coq use `fun` instead of `\\` to denote this.\n\n```Coq\nExample test_filter2':\n    filter (fun l => (length l) =? 1)\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].\nProof. reflexivity. Qed.\n```\n\n### Map & Fold\n\n`map` is also a function that is useful and interesting:\n```Coq\nFixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=\n  match l with\n  | []     => []\n  | h :: t => (f h) :: (map f t)\n  end.\n```\n\nTake `None` value into consideration, we define:\n```Coq\nDefinition option_map {X Y : Type} (f : X -> Y) (xo : option X)\n                      : option Y :=\n  match xo with\n  | None => None\n  | Some x => Some (f x)\n  end.\n```\n\nAnd you can't miss `fold`, another fantastic function:\n```Coq\nFixpoint fold {X Y: Type} (f : X->Y->Y) (l : list X) (b : Y)\n                         : Y :=\n  match l with\n  | nil => b\n  | h :: t => f h (fold f t b)\n  end.\n```\n\n\n\n\n","slug":"Software-Foundations-05-Poly","published":1,"updated":"2023-04-11T08:23:48.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbzyn7t0001m8mv10q87zoj","content":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<p><a\r\nhref=\"https://softwarefoundations.cis.upenn.edu/lf-current/index.html\">Online\r\nTextbook</a></p>\r\n<p><a href=\"https://www.youtube.com/watch?v=BGg-gxhsV4E\">Michael\r\nClarkson's Open Online Course (on Youtube)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1kd4y1t7bw/\">Michael Charkson's\r\nCourse (on Bilibili)</a></p>\r\n<p><a href=\"https://xiongyingfei.github.io/SF/2023/lectures.html\">Xiong\r\nYingfei's Course Webpage (2023 Spring)</a></p>\r\n<p>This note is used as a brief summary and supplementofr the textbook\r\nand courses.</p>\r\n<h2 id=\"poly\">Poly</h2>\r\n<h3 id=\"polymorphism\">Polymorphism</h3>\r\n<h4 id=\"omit-type-argument\">Omit Type Argument</h4>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> list (X:<span class=\"keyword\">Type</span>) : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">nil</span></span><br><span class=\"line\">  | <span class=\"type\">cons</span> (x : X) (l : list X).</span><br></pre></td></tr></table></figure>\r\n<p>The type list is thus parameterized on another type X.</p>\r\n<span id=\"more\"></span>\r\n<p>When we want to avoid typing the type, and let Coq to infer it. We\r\ncan set: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Arguments</span> nil &#123;X&#125;.</span><br><span class=\"line\"><span class=\"keyword\">Arguments</span> cons &#123;X&#125;.</span><br><span class=\"line\"><span class=\"keyword\">Arguments</span> <span class=\"built_in\">repeat</span> &#123;X&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Fixpoint</span> app &#123;X : <span class=\"keyword\">Type</span>&#125; (l1 l2 : list X) : list X :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> l1 <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">nil</span>      =&gt; l2</span><br><span class=\"line\">  | <span class=\"type\">cons</span> h t =&gt; cons h (app t l2)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"catesian-product\">Catesian Product</h4>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> prod (X Y : <span class=\"keyword\">Type</span>) : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">| <span class=\"type\">pair</span> (x : X) (y : Y).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Arguments</span> pair &#123;X&#125; &#123;Y&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;( x , y )&quot;</span> := (pair x y).</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;X * Y&quot;</span> := (prod X Y) : type_scope.</span><br><span class=\"line\"><span class=\"comment\">(** (The annotation [: type_scope] tells Coq that this abbreviation</span></span><br><span class=\"line\"><span class=\"comment\">    should only be used when parsing types, not when parsing</span></span><br><span class=\"line\"><span class=\"comment\">    expressions.  This avoids a clash with the multiplication</span></span><br><span class=\"line\"><span class=\"comment\">    symbol.) *)</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"higher-order-functions\">Higher-Order Functions</h3>\r\n<p>Functions that manipulate other functions are often called\r\n<strong>higher-order</strong> functions.</p>\r\n<p>For example, we have <code>filter</code> function <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> filter &#123;X:<span class=\"keyword\">Type</span>&#125; (test: X-&gt;bool) (l:list X) : list X :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> l <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">[] =&gt; []</span></span><br><span class=\"line\"><span class=\"type\">  | h</span> :: t =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> test h <span class=\"keyword\">then</span> h :: (filter test t)</span><br><span class=\"line\">    <span class=\"keyword\">else</span> filter test t</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"functions-that-construct-functions\">Functions That Construct\r\nFunctions</h4>\r\n<p>Functions that return the given functor whatever the argument is.\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> constfun &#123;X: <span class=\"keyword\">Type</span>&#125; (x: X) : nat -&gt; X :=</span><br><span class=\"line\">  <span class=\"keyword\">fun</span> (k:nat) =&gt; x.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Definition</span> ftrue := constfun true.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Example</span> constfun_example1 : ftrue <span class=\"number\">0</span> = true.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"built_in\">reflexivity</span>. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>This function seems useless, but there is a usage of higher-order\r\nfunctions, let's now mock function currying: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> plus3 := plus <span class=\"number\">3.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Example</span> test_plus3 :    plus3 <span class=\"number\">4</span> = <span class=\"number\">7.</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"built_in\">reflexivity</span>. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"anonymous-functions\">Anonymous Functions</h3>\r\n<p>Just like <span class=\"math inline\">\\(\\lambda\\)</span> function in\r\nHaskell, the difference is that Coq use <code>fun</code> instead of\r\n<code>\\</code> to denote this.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Example</span> test_filter2&#x27;:</span><br><span class=\"line\">    filter (<span class=\"keyword\">fun</span> l =&gt; (length l) =? <span class=\"number\">1</span>)</span><br><span class=\"line\">           [ [<span class=\"number\">1</span>; <span class=\"number\">2</span>]; [<span class=\"number\">3</span>]; [<span class=\"number\">4</span>]; [<span class=\"number\">5</span>;<span class=\"number\">6</span>;<span class=\"number\">7</span>]; []; [<span class=\"number\">8</span>] ]</span><br><span class=\"line\">  = [ [<span class=\"number\">3</span>]; [<span class=\"number\">4</span>]; [<span class=\"number\">8</span>] ].</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"built_in\">reflexivity</span>. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"map-fold\">Map &amp; Fold</h3>\r\n<p><code>map</code> is also a function that is useful and interesting:\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> map &#123;X Y : <span class=\"keyword\">Type</span>&#125; (f : X-&gt;Y) (l : list X) : list Y :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> l <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">[]     =&gt; []</span></span><br><span class=\"line\"><span class=\"type\">  | h</span> :: t =&gt; (f h) :: (map f t)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>Take <code>None</code> value into consideration, we define:\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> option_map &#123;X Y : <span class=\"keyword\">Type</span>&#125; (f : X -&gt; Y) (xo : option X)</span><br><span class=\"line\">                      : option Y :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> xo <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">None</span> =&gt; None</span><br><span class=\"line\">  | <span class=\"type\">Some</span> x =&gt; Some (f x)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>And you can't miss <code>fold</code>, another fantastic function:\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> <span class=\"built_in\">fold</span> &#123;X Y: <span class=\"keyword\">Type</span>&#125; (f : X-&gt;Y-&gt;Y) (l : list X) (b : Y)</span><br><span class=\"line\">                         : Y :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> l <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">nil</span> =&gt; b</span><br><span class=\"line\">  | <span class=\"type\">h</span> :: t =&gt; f h (<span class=\"built_in\">fold</span> f t b)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure></p>\r\n","site":{"data":{}},"excerpt":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<p><a\r\nhref=\"https://softwarefoundations.cis.upenn.edu/lf-current/index.html\">Online\r\nTextbook</a></p>\r\n<p><a href=\"https://www.youtube.com/watch?v=BGg-gxhsV4E\">Michael\r\nClarkson's Open Online Course (on Youtube)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1kd4y1t7bw/\">Michael Charkson's\r\nCourse (on Bilibili)</a></p>\r\n<p><a href=\"https://xiongyingfei.github.io/SF/2023/lectures.html\">Xiong\r\nYingfei's Course Webpage (2023 Spring)</a></p>\r\n<p>This note is used as a brief summary and supplementofr the textbook\r\nand courses.</p>\r\n<h2 id=\"poly\">Poly</h2>\r\n<h3 id=\"polymorphism\">Polymorphism</h3>\r\n<h4 id=\"omit-type-argument\">Omit Type Argument</h4>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> list (X:<span class=\"keyword\">Type</span>) : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">nil</span></span><br><span class=\"line\">  | <span class=\"type\">cons</span> (x : X) (l : list X).</span><br></pre></td></tr></table></figure>\r\n<p>The type list is thus parameterized on another type X.</p>","more":"<p>When we want to avoid typing the type, and let Coq to infer it. We\r\ncan set: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Arguments</span> nil &#123;X&#125;.</span><br><span class=\"line\"><span class=\"keyword\">Arguments</span> cons &#123;X&#125;.</span><br><span class=\"line\"><span class=\"keyword\">Arguments</span> <span class=\"built_in\">repeat</span> &#123;X&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Fixpoint</span> app &#123;X : <span class=\"keyword\">Type</span>&#125; (l1 l2 : list X) : list X :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> l1 <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">nil</span>      =&gt; l2</span><br><span class=\"line\">  | <span class=\"type\">cons</span> h t =&gt; cons h (app t l2)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"catesian-product\">Catesian Product</h4>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> prod (X Y : <span class=\"keyword\">Type</span>) : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">| <span class=\"type\">pair</span> (x : X) (y : Y).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Arguments</span> pair &#123;X&#125; &#123;Y&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;( x , y )&quot;</span> := (pair x y).</span><br><span class=\"line\"><span class=\"keyword\">Notation</span> <span class=\"string\">&quot;X * Y&quot;</span> := (prod X Y) : type_scope.</span><br><span class=\"line\"><span class=\"comment\">(** (The annotation [: type_scope] tells Coq that this abbreviation</span></span><br><span class=\"line\"><span class=\"comment\">    should only be used when parsing types, not when parsing</span></span><br><span class=\"line\"><span class=\"comment\">    expressions.  This avoids a clash with the multiplication</span></span><br><span class=\"line\"><span class=\"comment\">    symbol.) *)</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"higher-order-functions\">Higher-Order Functions</h3>\r\n<p>Functions that manipulate other functions are often called\r\n<strong>higher-order</strong> functions.</p>\r\n<p>For example, we have <code>filter</code> function <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> filter &#123;X:<span class=\"keyword\">Type</span>&#125; (test: X-&gt;bool) (l:list X) : list X :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> l <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">[] =&gt; []</span></span><br><span class=\"line\"><span class=\"type\">  | h</span> :: t =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> test h <span class=\"keyword\">then</span> h :: (filter test t)</span><br><span class=\"line\">    <span class=\"keyword\">else</span> filter test t</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"functions-that-construct-functions\">Functions That Construct\r\nFunctions</h4>\r\n<p>Functions that return the given functor whatever the argument is.\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> constfun &#123;X: <span class=\"keyword\">Type</span>&#125; (x: X) : nat -&gt; X :=</span><br><span class=\"line\">  <span class=\"keyword\">fun</span> (k:nat) =&gt; x.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Definition</span> ftrue := constfun true.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Example</span> constfun_example1 : ftrue <span class=\"number\">0</span> = true.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"built_in\">reflexivity</span>. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>This function seems useless, but there is a usage of higher-order\r\nfunctions, let's now mock function currying: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> plus3 := plus <span class=\"number\">3.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Example</span> test_plus3 :    plus3 <span class=\"number\">4</span> = <span class=\"number\">7.</span></span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"built_in\">reflexivity</span>. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"anonymous-functions\">Anonymous Functions</h3>\r\n<p>Just like <span class=\"math inline\">\\(\\lambda\\)</span> function in\r\nHaskell, the difference is that Coq use <code>fun</code> instead of\r\n<code>\\</code> to denote this.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Example</span> test_filter2&#x27;:</span><br><span class=\"line\">    filter (<span class=\"keyword\">fun</span> l =&gt; (length l) =? <span class=\"number\">1</span>)</span><br><span class=\"line\">           [ [<span class=\"number\">1</span>; <span class=\"number\">2</span>]; [<span class=\"number\">3</span>]; [<span class=\"number\">4</span>]; [<span class=\"number\">5</span>;<span class=\"number\">6</span>;<span class=\"number\">7</span>]; []; [<span class=\"number\">8</span>] ]</span><br><span class=\"line\">  = [ [<span class=\"number\">3</span>]; [<span class=\"number\">4</span>]; [<span class=\"number\">8</span>] ].</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>. <span class=\"built_in\">reflexivity</span>. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"map-fold\">Map &amp; Fold</h3>\r\n<p><code>map</code> is also a function that is useful and interesting:\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> map &#123;X Y : <span class=\"keyword\">Type</span>&#125; (f : X-&gt;Y) (l : list X) : list Y :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> l <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">[]     =&gt; []</span></span><br><span class=\"line\"><span class=\"type\">  | h</span> :: t =&gt; (f h) :: (map f t)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>Take <code>None</code> value into consideration, we define:\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> option_map &#123;X Y : <span class=\"keyword\">Type</span>&#125; (f : X -&gt; Y) (xo : option X)</span><br><span class=\"line\">                      : option Y :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> xo <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">None</span> =&gt; None</span><br><span class=\"line\">  | <span class=\"type\">Some</span> x =&gt; Some (f x)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>And you can't miss <code>fold</code>, another fantastic function:\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Fixpoint</span> <span class=\"built_in\">fold</span> &#123;X Y: <span class=\"keyword\">Type</span>&#125; (f : X-&gt;Y-&gt;Y) (l : list X) (b : Y)</span><br><span class=\"line\">                         : Y :=</span><br><span class=\"line\">  <span class=\"keyword\">match</span> l <span class=\"built_in\">with</span></span><br><span class=\"line\">  | <span class=\"type\">nil</span> =&gt; b</span><br><span class=\"line\">  | <span class=\"type\">h</span> :: t =&gt; f h (<span class=\"built_in\">fold</span> f t b)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>.</span><br></pre></td></tr></table></figure></p>"},{"title":"Software Foundations 06 Tactics","toc":true,"date":"2023-04-11T08:24:12.000Z","_content":"\n# Software Foundations\n\n[Online Textbook](https://softwarefoundations.cis.upenn.edu/lf-current/index.html)\n\n[Michael Clarkson's Open Online Course (on Youtube)](https://www.youtube.com/watch?v=BGg-gxhsV4E)\n[Michael Charkson's Course (on Bilibili)](https://www.bilibili.com/video/BV1kd4y1t7bw/)\n\n[Xiong Yingfei's Course Webpage (2023 Spring)](https://xiongyingfei.github.io/SF/2023/lectures.html)\n\nThis note is used as a brief summary and supplementofr the textbook and courses.\n\n\n## Tactics\n\n### The `apply` tactic with `symmetry ` and `transitivity`\n\n#### `apply`\nWhen encountering situations where the goal to be proved is exactly the same as some hypothesis in the context or some previously proved lemma, we can use `apply` tactic instead of the `rewrite` & `reflexivity` we previously used.\n\n```Coq\nTheorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m.\nProof.\n  intros n m eq.\n(** n, m : nat\n    eq : n = m\n    ______________________________________(1/1)\n    n = m\n*)\n  apply eq.  Qed.\n```\n\n<!--more-->\n\n\nThe `apply` tactic also works with conditional hypothesis. Like `eq2: n = m -> [n;o] = [m;p]` in the following theorem.\n```Coq\nTheorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p].\nProof.\n  intros n m o p eq1 eq2.\n  apply eq2. apply eq1.  Qed.\n```\n\n#### `symmetry`\nThe `symmetry` tactic exchange left hand side with right hand side. It is useful in the following example.\n```Coq\nTheorem silly3 : forall (n m : nat),\n  n = m ->\n  m = n.\nProof.\n  intros n m H.\n  symmetry. apply H.  Qed.\n```\n\n#### `transitivity`\nSometimes we need the help of `transitivity` tactic to utilize `apply`:\n```Coq\nExample trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  apply trans_eq with (m:=[c;d]). (* or try transitivity [c;d]. *)\n  apply eq1. apply eq2.   Qed.\n```\n\n### The `injection` and `discriminate` Tactics\n\n#### Injective property and tactic\n\nTake the example of type `nat`:\n```Coq\nInductive nat : Type :=\n  | O\n  | S (n : nat).\n```\n\nInjective means that $S n = S m => n = m$.\n\nHere is an example of the `injective` tactic.\n```Coq\nTheorem injection_ex1 : forall (n m o : nat),\n  [n;m] = [o;o] ->\n  n = m.\nProof.\n  intros n m o H.\n  (* WORKED IN CLASS *)\n  injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed.\n```\n\n\n#### Disjoint Property and The `discriminate` Tactic\nDisjoint means that, two terms beginning with different constructors can never be equal. For example, $S n \\neq 0$ for all $n \\in nat$.\n\nSo any time we are given such contradictary assumptions, any conclusion are thus satisfied, like the following example:\n```Coq\nTheorem discriminate_ex1 : forall (n m : nat),\n  false = true ->\n  n = m.\nProof.\n  intros n m contra. discriminate contra. Qed.\n```\n\n\n### Using Tactics on Hypotheses\n\nThe tactic `simpl in H` performs simplification on the hypothesis `H` in the context.\n\nSimilarly we have `apply H1 in H2` and `symmetry in H`.\n\n```Coq\nTheorem silly4 : forall (n m p q : nat),\n  (n = m -> p = q) ->\n  m = n ->\n  q = p.\nProof.\n  intros n m p q EQ H.\n  symmetry in H. apply EQ in H. symmetry in H.\n  apply H.  Qed.\n```\n\n\n\n### The `generalize dependent` Tactic\n\nTo illustrate the need of the tactic, I first show the rule of `intros`, that all variables and hypotheses will be introduced according to its sequance of appearance.\n\nHere is an example of a failed proof:\n\n```Coq\nExample discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n  intros x y z l j contra.\n  Fail discriminate contra.\n```\nThat is because `x` corresponds to `X` which is a type, `y` `z` and `l` corresponts the three `X` type variable,  and that `j` and `contra` corresponds to the two lists. So we cannot just skip some variable unintroduced.\n\nBut sometimes we do need free variables that haven't been introduced. Like in the following theorem:\n```Coq\nTheorem double_injective_take2 : forall n m,\n  double n = double m ->\n  n = m.\n```\n\nThen we can use `generalize dependent` tactic to temporarily free variable n.\n\n```Coq\nProof.\n  intros n m.\n  (* [n] and [m] are both in the context *)\n  generalize dependent n.\n  (* Now [n] is back in the goal and we can do induction on\n     [m] and get a sufficiently general IH. *)\n  induction m as [| m' IHm'].\n  - (* m = O *) simpl. intros n eq. destruct n as [| n'] eqn:E.\n    + (* n = O *) reflexivity.\n    + (* n = S n' *) discriminate eq.\n  - (* m = S m' *) intros n eq. destruct n as [| n'] eqn:E.\n    + (* n = O *) discriminate eq.\n    + (* n = S n' *) apply f_equal.\n      apply IHm'. injection eq as goal. apply goal.\nQed.\n```\n\n### Unfolding Definitions\n\nThe `simpl` tactic will only unfold `match` or `fixpoint` definition, not `Definition` clause. so we need `unfold` tactic to do this job.\n\n\nAnd it comes along with some new example of `destruct` tactic. \n```Coq\nDefinition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false.\n\nTheorem sillyfun_false : forall (n : nat),\n  sillyfun n = false.\nProof.\n  intros n. unfold sillyfun.\n  destruct (n =? 3) eqn:E1.\n    - (* n =? 3 = true *) reflexivity.\n    - (* n =? 3 = false *) destruct (n =? 5) eqn:E2.\n      + (* n =? 5 = true *) reflexivity.\n      + (* n =? 5 = false *) reflexivity.  Qed.\n```\n\nHere is another example of the `destrct` tactic being applied to compound expressions:\n```Coq\nTheorem bool_fn_applied_thrice :\n  forall (f : bool -> bool) (b : bool),\n  f (f (f b)) = f b.\nProof.\n  intros f b. \n  destruct b eqn:H1.\n  - destruct (f b) eqn:H2.\n    + rewrite H1 in H2. rewrite H2. rewrite H2. rewrite H2. reflexivity.\n    + rewrite H1 in H2. rewrite H2. destruct (f false) eqn:E3.\n        rewrite H2. reflexivity. \n        rewrite E3. reflexivity.\n  - destruct (f b) eqn:H2.\n    + rewrite H1 in H2. rewrite H2. destruct (f true) eqn:E3.\n        rewrite E3. reflexivity. \n        rewrite H2. reflexivity.\n    + rewrite H1 in H2. rewrite H2. rewrite H2. rewrite H2. reflexivity.\nQed.\n```\n\n\n\n\n\n","source":"_posts/Software-Foundations-06-Tactics.md","raw":"---\ntitle: Software Foundations 06 Tactics\ntoc: true\ndate: 2023-04-11 16:24:12\ntags:\ncategories:\n---\n\n# Software Foundations\n\n[Online Textbook](https://softwarefoundations.cis.upenn.edu/lf-current/index.html)\n\n[Michael Clarkson's Open Online Course (on Youtube)](https://www.youtube.com/watch?v=BGg-gxhsV4E)\n[Michael Charkson's Course (on Bilibili)](https://www.bilibili.com/video/BV1kd4y1t7bw/)\n\n[Xiong Yingfei's Course Webpage (2023 Spring)](https://xiongyingfei.github.io/SF/2023/lectures.html)\n\nThis note is used as a brief summary and supplementofr the textbook and courses.\n\n\n## Tactics\n\n### The `apply` tactic with `symmetry ` and `transitivity`\n\n#### `apply`\nWhen encountering situations where the goal to be proved is exactly the same as some hypothesis in the context or some previously proved lemma, we can use `apply` tactic instead of the `rewrite` & `reflexivity` we previously used.\n\n```Coq\nTheorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m.\nProof.\n  intros n m eq.\n(** n, m : nat\n    eq : n = m\n    ______________________________________(1/1)\n    n = m\n*)\n  apply eq.  Qed.\n```\n\n<!--more-->\n\n\nThe `apply` tactic also works with conditional hypothesis. Like `eq2: n = m -> [n;o] = [m;p]` in the following theorem.\n```Coq\nTheorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p].\nProof.\n  intros n m o p eq1 eq2.\n  apply eq2. apply eq1.  Qed.\n```\n\n#### `symmetry`\nThe `symmetry` tactic exchange left hand side with right hand side. It is useful in the following example.\n```Coq\nTheorem silly3 : forall (n m : nat),\n  n = m ->\n  m = n.\nProof.\n  intros n m H.\n  symmetry. apply H.  Qed.\n```\n\n#### `transitivity`\nSometimes we need the help of `transitivity` tactic to utilize `apply`:\n```Coq\nExample trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  apply trans_eq with (m:=[c;d]). (* or try transitivity [c;d]. *)\n  apply eq1. apply eq2.   Qed.\n```\n\n### The `injection` and `discriminate` Tactics\n\n#### Injective property and tactic\n\nTake the example of type `nat`:\n```Coq\nInductive nat : Type :=\n  | O\n  | S (n : nat).\n```\n\nInjective means that $S n = S m => n = m$.\n\nHere is an example of the `injective` tactic.\n```Coq\nTheorem injection_ex1 : forall (n m o : nat),\n  [n;m] = [o;o] ->\n  n = m.\nProof.\n  intros n m o H.\n  (* WORKED IN CLASS *)\n  injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed.\n```\n\n\n#### Disjoint Property and The `discriminate` Tactic\nDisjoint means that, two terms beginning with different constructors can never be equal. For example, $S n \\neq 0$ for all $n \\in nat$.\n\nSo any time we are given such contradictary assumptions, any conclusion are thus satisfied, like the following example:\n```Coq\nTheorem discriminate_ex1 : forall (n m : nat),\n  false = true ->\n  n = m.\nProof.\n  intros n m contra. discriminate contra. Qed.\n```\n\n\n### Using Tactics on Hypotheses\n\nThe tactic `simpl in H` performs simplification on the hypothesis `H` in the context.\n\nSimilarly we have `apply H1 in H2` and `symmetry in H`.\n\n```Coq\nTheorem silly4 : forall (n m p q : nat),\n  (n = m -> p = q) ->\n  m = n ->\n  q = p.\nProof.\n  intros n m p q EQ H.\n  symmetry in H. apply EQ in H. symmetry in H.\n  apply H.  Qed.\n```\n\n\n\n### The `generalize dependent` Tactic\n\nTo illustrate the need of the tactic, I first show the rule of `intros`, that all variables and hypotheses will be introduced according to its sequance of appearance.\n\nHere is an example of a failed proof:\n\n```Coq\nExample discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n  intros x y z l j contra.\n  Fail discriminate contra.\n```\nThat is because `x` corresponds to `X` which is a type, `y` `z` and `l` corresponts the three `X` type variable,  and that `j` and `contra` corresponds to the two lists. So we cannot just skip some variable unintroduced.\n\nBut sometimes we do need free variables that haven't been introduced. Like in the following theorem:\n```Coq\nTheorem double_injective_take2 : forall n m,\n  double n = double m ->\n  n = m.\n```\n\nThen we can use `generalize dependent` tactic to temporarily free variable n.\n\n```Coq\nProof.\n  intros n m.\n  (* [n] and [m] are both in the context *)\n  generalize dependent n.\n  (* Now [n] is back in the goal and we can do induction on\n     [m] and get a sufficiently general IH. *)\n  induction m as [| m' IHm'].\n  - (* m = O *) simpl. intros n eq. destruct n as [| n'] eqn:E.\n    + (* n = O *) reflexivity.\n    + (* n = S n' *) discriminate eq.\n  - (* m = S m' *) intros n eq. destruct n as [| n'] eqn:E.\n    + (* n = O *) discriminate eq.\n    + (* n = S n' *) apply f_equal.\n      apply IHm'. injection eq as goal. apply goal.\nQed.\n```\n\n### Unfolding Definitions\n\nThe `simpl` tactic will only unfold `match` or `fixpoint` definition, not `Definition` clause. so we need `unfold` tactic to do this job.\n\n\nAnd it comes along with some new example of `destruct` tactic. \n```Coq\nDefinition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false.\n\nTheorem sillyfun_false : forall (n : nat),\n  sillyfun n = false.\nProof.\n  intros n. unfold sillyfun.\n  destruct (n =? 3) eqn:E1.\n    - (* n =? 3 = true *) reflexivity.\n    - (* n =? 3 = false *) destruct (n =? 5) eqn:E2.\n      + (* n =? 5 = true *) reflexivity.\n      + (* n =? 5 = false *) reflexivity.  Qed.\n```\n\nHere is another example of the `destrct` tactic being applied to compound expressions:\n```Coq\nTheorem bool_fn_applied_thrice :\n  forall (f : bool -> bool) (b : bool),\n  f (f (f b)) = f b.\nProof.\n  intros f b. \n  destruct b eqn:H1.\n  - destruct (f b) eqn:H2.\n    + rewrite H1 in H2. rewrite H2. rewrite H2. rewrite H2. reflexivity.\n    + rewrite H1 in H2. rewrite H2. destruct (f false) eqn:E3.\n        rewrite H2. reflexivity. \n        rewrite E3. reflexivity.\n  - destruct (f b) eqn:H2.\n    + rewrite H1 in H2. rewrite H2. destruct (f true) eqn:E3.\n        rewrite E3. reflexivity. \n        rewrite H2. reflexivity.\n    + rewrite H1 in H2. rewrite H2. rewrite H2. rewrite H2. reflexivity.\nQed.\n```\n\n\n\n\n\n","slug":"Software-Foundations-06-Tactics","published":1,"updated":"2023-04-11T08:24:30.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbzyn7u0002m8mvcv4y1q28","content":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<p><a\r\nhref=\"https://softwarefoundations.cis.upenn.edu/lf-current/index.html\">Online\r\nTextbook</a></p>\r\n<p><a href=\"https://www.youtube.com/watch?v=BGg-gxhsV4E\">Michael\r\nClarkson's Open Online Course (on Youtube)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1kd4y1t7bw/\">Michael Charkson's\r\nCourse (on Bilibili)</a></p>\r\n<p><a href=\"https://xiongyingfei.github.io/SF/2023/lectures.html\">Xiong\r\nYingfei's Course Webpage (2023 Spring)</a></p>\r\n<p>This note is used as a brief summary and supplementofr the textbook\r\nand courses.</p>\r\n<h2 id=\"tactics\">Tactics</h2>\r\n<h3 id=\"the-apply-tactic-with-symmetry-and-transitivity\">The\r\n<code>apply</code> tactic with <code>symmetry</code> and\r\n<code>transitivity</code></h3>\r\n<h4 id=\"apply\"><code>apply</code></h4>\r\n<p>When encountering situations where the goal to be proved is exactly\r\nthe same as some hypothesis in the context or some previously proved\r\nlemma, we can use <code>apply</code> tactic instead of the\r\n<code>rewrite</code> &amp; <code>reflexivity</code> we previously\r\nused.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> silly1 : <span class=\"keyword\">forall</span> (n m : nat),</span><br><span class=\"line\">  n = m -&gt;</span><br><span class=\"line\">  n = m.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m eq.</span><br><span class=\"line\"><span class=\"comment\">(** n, m : nat</span></span><br><span class=\"line\"><span class=\"comment\">    eq : n = m</span></span><br><span class=\"line\"><span class=\"comment\">    ______________________________________(1/1)</span></span><br><span class=\"line\"><span class=\"comment\">    n = m</span></span><br><span class=\"line\"><span class=\"comment\">*)</span></span><br><span class=\"line\">  <span class=\"built_in\">apply</span> eq.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<span id=\"more\"></span>\r\n<p>The <code>apply</code> tactic also works with conditional hypothesis.\r\nLike <code>eq2: n = m -&gt; [n;o] = [m;p]</code> in the following\r\ntheorem. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> silly2 : <span class=\"keyword\">forall</span> (n m o p : nat),</span><br><span class=\"line\">  n = m -&gt;</span><br><span class=\"line\">  (n = m -&gt; [n;o] = [m;p]) -&gt;</span><br><span class=\"line\">  [n;o] = [m;p].</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m o p eq1 eq2.</span><br><span class=\"line\">  <span class=\"built_in\">apply</span> eq2. <span class=\"built_in\">apply</span> eq1.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"symmetry\"><code>symmetry</code></h4>\r\n<p>The <code>symmetry</code> tactic exchange left hand side with right\r\nhand side. It is useful in the following example. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> silly3 : <span class=\"keyword\">forall</span> (n m : nat),</span><br><span class=\"line\">  n = m -&gt;</span><br><span class=\"line\">  m = n.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m H.</span><br><span class=\"line\">  <span class=\"built_in\">symmetry</span>. <span class=\"built_in\">apply</span> H.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"transitivity\"><code>transitivity</code></h4>\r\n<p>Sometimes we need the help of <code>transitivity</code> tactic to\r\nutilize <code>apply</code>: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Example</span> trans_eq_example&#x27; : <span class=\"keyword\">forall</span> (a b c d e f : nat),</span><br><span class=\"line\">     [a;b] = [c;d] -&gt;</span><br><span class=\"line\">     [c;d] = [e;f] -&gt;</span><br><span class=\"line\">     [a;b] = [e;f].</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> a b c d e f eq1 eq2.</span><br><span class=\"line\">  <span class=\"built_in\">apply</span> trans_eq <span class=\"built_in\">with</span> (m:=[c;d]). <span class=\"comment\">(* or try transitivity [c;d]. *)</span></span><br><span class=\"line\">  <span class=\"built_in\">apply</span> eq1. <span class=\"built_in\">apply</span> eq2.   <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"the-injection-and-discriminate-tactics\">The\r\n<code>injection</code> and <code>discriminate</code> Tactics</h3>\r\n<h4 id=\"injective-property-and-tactic\">Injective property and\r\ntactic</h4>\r\n<p>Take the example of type <code>nat</code>: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> nat : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">O</span></span><br><span class=\"line\">  | <span class=\"type\">S</span> (n : nat).</span><br></pre></td></tr></table></figure></p>\r\n<p>Injective means that <span class=\"math inline\">\\(S n = S m =&gt; n =\r\nm\\)</span>.</p>\r\n<p>Here is an example of the <code>injective</code> tactic.\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> injection_ex1 : <span class=\"keyword\">forall</span> (n m o : nat),</span><br><span class=\"line\">  [n;m] = [o;o] -&gt;</span><br><span class=\"line\">  n = m.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m o H.</span><br><span class=\"line\">  <span class=\"comment\">(* WORKED IN CLASS *)</span></span><br><span class=\"line\">  <span class=\"built_in\">injection</span> H <span class=\"built_in\">as</span> H1 H2.</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> H1. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"disjoint-property-and-the-discriminate-tactic\">Disjoint Property\r\nand The <code>discriminate</code> Tactic</h4>\r\n<p>Disjoint means that, two terms beginning with different constructors\r\ncan never be equal. For example, <span class=\"math inline\">\\(S n \\neq\r\n0\\)</span> for all <span class=\"math inline\">\\(n \\in nat\\)</span>.</p>\r\n<p>So any time we are given such contradictary assumptions, any\r\nconclusion are thus satisfied, like the following example:\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> discriminate_ex1 : <span class=\"keyword\">forall</span> (n m : nat),</span><br><span class=\"line\">  false = true -&gt;</span><br><span class=\"line\">  n = m.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m contra. <span class=\"built_in\">discriminate</span> contra. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"using-tactics-on-hypotheses\">Using Tactics on Hypotheses</h3>\r\n<p>The tactic <code>simpl in H</code> performs simplification on the\r\nhypothesis <code>H</code> in the context.</p>\r\n<p>Similarly we have <code>apply H1 in H2</code> and\r\n<code>symmetry in H</code>.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> silly4 : <span class=\"keyword\">forall</span> (n m p q : nat),</span><br><span class=\"line\">  (n = m -&gt; p = q) -&gt;</span><br><span class=\"line\">  m = n -&gt;</span><br><span class=\"line\">  q = p.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m p q EQ H.</span><br><span class=\"line\">  <span class=\"built_in\">symmetry</span> <span class=\"built_in\">in</span> H. <span class=\"built_in\">apply</span> EQ <span class=\"built_in\">in</span> H. <span class=\"built_in\">symmetry</span> <span class=\"built_in\">in</span> H.</span><br><span class=\"line\">  <span class=\"built_in\">apply</span> H.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"the-generalize-dependent-tactic\">The\r\n<code>generalize dependent</code> Tactic</h3>\r\n<p>To illustrate the need of the tactic, I first show the rule of\r\n<code>intros</code>, that all variables and hypotheses will be\r\nintroduced according to its sequance of appearance.</p>\r\n<p>Here is an example of a failed proof:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Example</span> discriminate_ex3 :</span><br><span class=\"line\">  <span class=\"keyword\">forall</span> (X : <span class=\"keyword\">Type</span>) (x y z : X) (l j : list X),</span><br><span class=\"line\">    x :: y :: l = [] -&gt;</span><br><span class=\"line\">    x = z.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> x y z l j contra.</span><br><span class=\"line\">  Fail <span class=\"built_in\">discriminate</span> contra.</span><br></pre></td></tr></table></figure>\r\n<p>That is because <code>x</code> corresponds to <code>X</code> which is\r\na type, <code>y</code> <code>z</code> and <code>l</code> corresponts the\r\nthree <code>X</code> type variable, and that <code>j</code> and\r\n<code>contra</code> corresponds to the two lists. So we cannot just skip\r\nsome variable unintroduced.</p>\r\n<p>But sometimes we do need free variables that haven't been introduced.\r\nLike in the following theorem: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> double_injective_take2 : <span class=\"keyword\">forall</span> n m,</span><br><span class=\"line\">  <span class=\"built_in\">double</span> n = <span class=\"built_in\">double</span> m -&gt;</span><br><span class=\"line\">  n = m.</span><br></pre></td></tr></table></figure></p>\r\n<p>Then we can use <code>generalize dependent</code> tactic to\r\ntemporarily free variable n.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m.</span><br><span class=\"line\">  <span class=\"comment\">(* [n] and [m] are both in the context *)</span></span><br><span class=\"line\">  <span class=\"built_in\">generalize</span> <span class=\"built_in\">dependent</span> n.</span><br><span class=\"line\">  <span class=\"comment\">(* Now [n] is back in the goal and we can do induction on</span></span><br><span class=\"line\"><span class=\"comment\">     [m] and get a sufficiently general IH. *)</span></span><br><span class=\"line\">  <span class=\"built_in\">induction</span> m <span class=\"built_in\">as</span> [| <span class=\"type\">m</span>&#x27; IHm&#x27;].</span><br><span class=\"line\">  - <span class=\"comment\">(* m = O *)</span> <span class=\"built_in\">simpl</span>. <span class=\"built_in\">intros</span> n eq. <span class=\"built_in\">destruct</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27;] eqn:E.</span><br><span class=\"line\">    + <span class=\"comment\">(* n = O *)</span> <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">    + <span class=\"comment\">(* n = S n&#x27; *)</span> <span class=\"built_in\">discriminate</span> eq.</span><br><span class=\"line\">  - <span class=\"comment\">(* m = S m&#x27; *)</span> <span class=\"built_in\">intros</span> n eq. <span class=\"built_in\">destruct</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27;] eqn:E.</span><br><span class=\"line\">    + <span class=\"comment\">(* n = O *)</span> <span class=\"built_in\">discriminate</span> eq.</span><br><span class=\"line\">    + <span class=\"comment\">(* n = S n&#x27; *)</span> <span class=\"built_in\">apply</span> <span class=\"built_in\">f_equal</span>.</span><br><span class=\"line\">      <span class=\"built_in\">apply</span> IHm&#x27;. <span class=\"built_in\">injection</span> eq <span class=\"built_in\">as</span> goal. <span class=\"built_in\">apply</span> goal.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"unfolding-definitions\">Unfolding Definitions</h3>\r\n<p>The <code>simpl</code> tactic will only unfold <code>match</code> or\r\n<code>fixpoint</code> definition, not <code>Definition</code> clause. so\r\nwe need <code>unfold</code> tactic to do this job.</p>\r\n<p>And it comes along with some new example of <code>destruct</code>\r\ntactic. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> sillyfun (n : nat) : bool :=</span><br><span class=\"line\">  <span class=\"keyword\">if</span> n =? <span class=\"number\">3</span> <span class=\"keyword\">then</span> false</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> n =? <span class=\"number\">5</span> <span class=\"keyword\">then</span> false</span><br><span class=\"line\">  <span class=\"keyword\">else</span> false.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Theorem</span> sillyfun_false : <span class=\"keyword\">forall</span> (n : nat),</span><br><span class=\"line\">  sillyfun n = false.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n. <span class=\"built_in\">unfold</span> sillyfun.</span><br><span class=\"line\">  <span class=\"built_in\">destruct</span> (n =? <span class=\"number\">3</span>) eqn:E1.</span><br><span class=\"line\">    - <span class=\"comment\">(* n =? 3 = true *)</span> <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">    - <span class=\"comment\">(* n =? 3 = false *)</span> <span class=\"built_in\">destruct</span> (n =? <span class=\"number\">5</span>) eqn:E2.</span><br><span class=\"line\">      + <span class=\"comment\">(* n =? 5 = true *)</span> <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">      + <span class=\"comment\">(* n =? 5 = false *)</span> <span class=\"built_in\">reflexivity</span>.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>Here is another example of the <code>destrct</code> tactic being\r\napplied to compound expressions: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> bool_fn_applied_thrice :</span><br><span class=\"line\">  <span class=\"keyword\">forall</span> (f : bool -&gt; bool) (b : bool),</span><br><span class=\"line\">  f (f (f b)) = f b.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> f b. </span><br><span class=\"line\">  <span class=\"built_in\">destruct</span> b eqn:H1.</span><br><span class=\"line\">  - <span class=\"built_in\">destruct</span> (f b) eqn:H2.</span><br><span class=\"line\">    + <span class=\"built_in\">rewrite</span> H1 <span class=\"built_in\">in</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">    + <span class=\"built_in\">rewrite</span> H1 <span class=\"built_in\">in</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">destruct</span> (f false) eqn:E3.</span><br><span class=\"line\">        <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">reflexivity</span>. </span><br><span class=\"line\">        <span class=\"built_in\">rewrite</span> E3. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"built_in\">destruct</span> (f b) eqn:H2.</span><br><span class=\"line\">    + <span class=\"built_in\">rewrite</span> H1 <span class=\"built_in\">in</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">destruct</span> (f true) eqn:E3.</span><br><span class=\"line\">        <span class=\"built_in\">rewrite</span> E3. <span class=\"built_in\">reflexivity</span>. </span><br><span class=\"line\">        <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">    + <span class=\"built_in\">rewrite</span> H1 <span class=\"built_in\">in</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n","site":{"data":{}},"excerpt":"<h1 id=\"software-foundations\">Software Foundations</h1>\r\n<p><a\r\nhref=\"https://softwarefoundations.cis.upenn.edu/lf-current/index.html\">Online\r\nTextbook</a></p>\r\n<p><a href=\"https://www.youtube.com/watch?v=BGg-gxhsV4E\">Michael\r\nClarkson's Open Online Course (on Youtube)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1kd4y1t7bw/\">Michael Charkson's\r\nCourse (on Bilibili)</a></p>\r\n<p><a href=\"https://xiongyingfei.github.io/SF/2023/lectures.html\">Xiong\r\nYingfei's Course Webpage (2023 Spring)</a></p>\r\n<p>This note is used as a brief summary and supplementofr the textbook\r\nand courses.</p>\r\n<h2 id=\"tactics\">Tactics</h2>\r\n<h3 id=\"the-apply-tactic-with-symmetry-and-transitivity\">The\r\n<code>apply</code> tactic with <code>symmetry</code> and\r\n<code>transitivity</code></h3>\r\n<h4 id=\"apply\"><code>apply</code></h4>\r\n<p>When encountering situations where the goal to be proved is exactly\r\nthe same as some hypothesis in the context or some previously proved\r\nlemma, we can use <code>apply</code> tactic instead of the\r\n<code>rewrite</code> &amp; <code>reflexivity</code> we previously\r\nused.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> silly1 : <span class=\"keyword\">forall</span> (n m : nat),</span><br><span class=\"line\">  n = m -&gt;</span><br><span class=\"line\">  n = m.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m eq.</span><br><span class=\"line\"><span class=\"comment\">(** n, m : nat</span></span><br><span class=\"line\"><span class=\"comment\">    eq : n = m</span></span><br><span class=\"line\"><span class=\"comment\">    ______________________________________(1/1)</span></span><br><span class=\"line\"><span class=\"comment\">    n = m</span></span><br><span class=\"line\"><span class=\"comment\">*)</span></span><br><span class=\"line\">  <span class=\"built_in\">apply</span> eq.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>","more":"<p>The <code>apply</code> tactic also works with conditional hypothesis.\r\nLike <code>eq2: n = m -&gt; [n;o] = [m;p]</code> in the following\r\ntheorem. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> silly2 : <span class=\"keyword\">forall</span> (n m o p : nat),</span><br><span class=\"line\">  n = m -&gt;</span><br><span class=\"line\">  (n = m -&gt; [n;o] = [m;p]) -&gt;</span><br><span class=\"line\">  [n;o] = [m;p].</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m o p eq1 eq2.</span><br><span class=\"line\">  <span class=\"built_in\">apply</span> eq2. <span class=\"built_in\">apply</span> eq1.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"symmetry\"><code>symmetry</code></h4>\r\n<p>The <code>symmetry</code> tactic exchange left hand side with right\r\nhand side. It is useful in the following example. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> silly3 : <span class=\"keyword\">forall</span> (n m : nat),</span><br><span class=\"line\">  n = m -&gt;</span><br><span class=\"line\">  m = n.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m H.</span><br><span class=\"line\">  <span class=\"built_in\">symmetry</span>. <span class=\"built_in\">apply</span> H.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"transitivity\"><code>transitivity</code></h4>\r\n<p>Sometimes we need the help of <code>transitivity</code> tactic to\r\nutilize <code>apply</code>: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Example</span> trans_eq_example&#x27; : <span class=\"keyword\">forall</span> (a b c d e f : nat),</span><br><span class=\"line\">     [a;b] = [c;d] -&gt;</span><br><span class=\"line\">     [c;d] = [e;f] -&gt;</span><br><span class=\"line\">     [a;b] = [e;f].</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> a b c d e f eq1 eq2.</span><br><span class=\"line\">  <span class=\"built_in\">apply</span> trans_eq <span class=\"built_in\">with</span> (m:=[c;d]). <span class=\"comment\">(* or try transitivity [c;d]. *)</span></span><br><span class=\"line\">  <span class=\"built_in\">apply</span> eq1. <span class=\"built_in\">apply</span> eq2.   <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"the-injection-and-discriminate-tactics\">The\r\n<code>injection</code> and <code>discriminate</code> Tactics</h3>\r\n<h4 id=\"injective-property-and-tactic\">Injective property and\r\ntactic</h4>\r\n<p>Take the example of type <code>nat</code>: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Inductive</span> nat : <span class=\"keyword\">Type</span> :=</span><br><span class=\"line\">  | <span class=\"type\">O</span></span><br><span class=\"line\">  | <span class=\"type\">S</span> (n : nat).</span><br></pre></td></tr></table></figure></p>\r\n<p>Injective means that <span class=\"math inline\">\\(S n = S m =&gt; n =\r\nm\\)</span>.</p>\r\n<p>Here is an example of the <code>injective</code> tactic.\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> injection_ex1 : <span class=\"keyword\">forall</span> (n m o : nat),</span><br><span class=\"line\">  [n;m] = [o;o] -&gt;</span><br><span class=\"line\">  n = m.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m o H.</span><br><span class=\"line\">  <span class=\"comment\">(* WORKED IN CLASS *)</span></span><br><span class=\"line\">  <span class=\"built_in\">injection</span> H <span class=\"built_in\">as</span> H1 H2.</span><br><span class=\"line\">  <span class=\"built_in\">rewrite</span> H1. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"disjoint-property-and-the-discriminate-tactic\">Disjoint Property\r\nand The <code>discriminate</code> Tactic</h4>\r\n<p>Disjoint means that, two terms beginning with different constructors\r\ncan never be equal. For example, <span class=\"math inline\">\\(S n \\neq\r\n0\\)</span> for all <span class=\"math inline\">\\(n \\in nat\\)</span>.</p>\r\n<p>So any time we are given such contradictary assumptions, any\r\nconclusion are thus satisfied, like the following example:\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> discriminate_ex1 : <span class=\"keyword\">forall</span> (n m : nat),</span><br><span class=\"line\">  false = true -&gt;</span><br><span class=\"line\">  n = m.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m contra. <span class=\"built_in\">discriminate</span> contra. <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"using-tactics-on-hypotheses\">Using Tactics on Hypotheses</h3>\r\n<p>The tactic <code>simpl in H</code> performs simplification on the\r\nhypothesis <code>H</code> in the context.</p>\r\n<p>Similarly we have <code>apply H1 in H2</code> and\r\n<code>symmetry in H</code>.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> silly4 : <span class=\"keyword\">forall</span> (n m p q : nat),</span><br><span class=\"line\">  (n = m -&gt; p = q) -&gt;</span><br><span class=\"line\">  m = n -&gt;</span><br><span class=\"line\">  q = p.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m p q EQ H.</span><br><span class=\"line\">  <span class=\"built_in\">symmetry</span> <span class=\"built_in\">in</span> H. <span class=\"built_in\">apply</span> EQ <span class=\"built_in\">in</span> H. <span class=\"built_in\">symmetry</span> <span class=\"built_in\">in</span> H.</span><br><span class=\"line\">  <span class=\"built_in\">apply</span> H.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"the-generalize-dependent-tactic\">The\r\n<code>generalize dependent</code> Tactic</h3>\r\n<p>To illustrate the need of the tactic, I first show the rule of\r\n<code>intros</code>, that all variables and hypotheses will be\r\nintroduced according to its sequance of appearance.</p>\r\n<p>Here is an example of a failed proof:</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Example</span> discriminate_ex3 :</span><br><span class=\"line\">  <span class=\"keyword\">forall</span> (X : <span class=\"keyword\">Type</span>) (x y z : X) (l j : list X),</span><br><span class=\"line\">    x :: y :: l = [] -&gt;</span><br><span class=\"line\">    x = z.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> x y z l j contra.</span><br><span class=\"line\">  Fail <span class=\"built_in\">discriminate</span> contra.</span><br></pre></td></tr></table></figure>\r\n<p>That is because <code>x</code> corresponds to <code>X</code> which is\r\na type, <code>y</code> <code>z</code> and <code>l</code> corresponts the\r\nthree <code>X</code> type variable, and that <code>j</code> and\r\n<code>contra</code> corresponds to the two lists. So we cannot just skip\r\nsome variable unintroduced.</p>\r\n<p>But sometimes we do need free variables that haven't been introduced.\r\nLike in the following theorem: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> double_injective_take2 : <span class=\"keyword\">forall</span> n m,</span><br><span class=\"line\">  <span class=\"built_in\">double</span> n = <span class=\"built_in\">double</span> m -&gt;</span><br><span class=\"line\">  n = m.</span><br></pre></td></tr></table></figure></p>\r\n<p>Then we can use <code>generalize dependent</code> tactic to\r\ntemporarily free variable n.</p>\r\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n m.</span><br><span class=\"line\">  <span class=\"comment\">(* [n] and [m] are both in the context *)</span></span><br><span class=\"line\">  <span class=\"built_in\">generalize</span> <span class=\"built_in\">dependent</span> n.</span><br><span class=\"line\">  <span class=\"comment\">(* Now [n] is back in the goal and we can do induction on</span></span><br><span class=\"line\"><span class=\"comment\">     [m] and get a sufficiently general IH. *)</span></span><br><span class=\"line\">  <span class=\"built_in\">induction</span> m <span class=\"built_in\">as</span> [| <span class=\"type\">m</span>&#x27; IHm&#x27;].</span><br><span class=\"line\">  - <span class=\"comment\">(* m = O *)</span> <span class=\"built_in\">simpl</span>. <span class=\"built_in\">intros</span> n eq. <span class=\"built_in\">destruct</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27;] eqn:E.</span><br><span class=\"line\">    + <span class=\"comment\">(* n = O *)</span> <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">    + <span class=\"comment\">(* n = S n&#x27; *)</span> <span class=\"built_in\">discriminate</span> eq.</span><br><span class=\"line\">  - <span class=\"comment\">(* m = S m&#x27; *)</span> <span class=\"built_in\">intros</span> n eq. <span class=\"built_in\">destruct</span> n <span class=\"built_in\">as</span> [| <span class=\"type\">n</span>&#x27;] eqn:E.</span><br><span class=\"line\">    + <span class=\"comment\">(* n = O *)</span> <span class=\"built_in\">discriminate</span> eq.</span><br><span class=\"line\">    + <span class=\"comment\">(* n = S n&#x27; *)</span> <span class=\"built_in\">apply</span> <span class=\"built_in\">f_equal</span>.</span><br><span class=\"line\">      <span class=\"built_in\">apply</span> IHm&#x27;. <span class=\"built_in\">injection</span> eq <span class=\"built_in\">as</span> goal. <span class=\"built_in\">apply</span> goal.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"unfolding-definitions\">Unfolding Definitions</h3>\r\n<p>The <code>simpl</code> tactic will only unfold <code>match</code> or\r\n<code>fixpoint</code> definition, not <code>Definition</code> clause. so\r\nwe need <code>unfold</code> tactic to do this job.</p>\r\n<p>And it comes along with some new example of <code>destruct</code>\r\ntactic. <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Definition</span> sillyfun (n : nat) : bool :=</span><br><span class=\"line\">  <span class=\"keyword\">if</span> n =? <span class=\"number\">3</span> <span class=\"keyword\">then</span> false</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> n =? <span class=\"number\">5</span> <span class=\"keyword\">then</span> false</span><br><span class=\"line\">  <span class=\"keyword\">else</span> false.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Theorem</span> sillyfun_false : <span class=\"keyword\">forall</span> (n : nat),</span><br><span class=\"line\">  sillyfun n = false.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> n. <span class=\"built_in\">unfold</span> sillyfun.</span><br><span class=\"line\">  <span class=\"built_in\">destruct</span> (n =? <span class=\"number\">3</span>) eqn:E1.</span><br><span class=\"line\">    - <span class=\"comment\">(* n =? 3 = true *)</span> <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">    - <span class=\"comment\">(* n =? 3 = false *)</span> <span class=\"built_in\">destruct</span> (n =? <span class=\"number\">5</span>) eqn:E2.</span><br><span class=\"line\">      + <span class=\"comment\">(* n =? 5 = true *)</span> <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">      + <span class=\"comment\">(* n =? 5 = false *)</span> <span class=\"built_in\">reflexivity</span>.  <span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>\r\n<p>Here is another example of the <code>destrct</code> tactic being\r\napplied to compound expressions: <figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Theorem</span> bool_fn_applied_thrice :</span><br><span class=\"line\">  <span class=\"keyword\">forall</span> (f : bool -&gt; bool) (b : bool),</span><br><span class=\"line\">  f (f (f b)) = f b.</span><br><span class=\"line\"><span class=\"keyword\">Proof</span>.</span><br><span class=\"line\">  <span class=\"built_in\">intros</span> f b. </span><br><span class=\"line\">  <span class=\"built_in\">destruct</span> b eqn:H1.</span><br><span class=\"line\">  - <span class=\"built_in\">destruct</span> (f b) eqn:H2.</span><br><span class=\"line\">    + <span class=\"built_in\">rewrite</span> H1 <span class=\"built_in\">in</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">    + <span class=\"built_in\">rewrite</span> H1 <span class=\"built_in\">in</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">destruct</span> (f false) eqn:E3.</span><br><span class=\"line\">        <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">reflexivity</span>. </span><br><span class=\"line\">        <span class=\"built_in\">rewrite</span> E3. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">  - <span class=\"built_in\">destruct</span> (f b) eqn:H2.</span><br><span class=\"line\">    + <span class=\"built_in\">rewrite</span> H1 <span class=\"built_in\">in</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">destruct</span> (f true) eqn:E3.</span><br><span class=\"line\">        <span class=\"built_in\">rewrite</span> E3. <span class=\"built_in\">reflexivity</span>. </span><br><span class=\"line\">        <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\">    + <span class=\"built_in\">rewrite</span> H1 <span class=\"built_in\">in</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">rewrite</span> H2. <span class=\"built_in\">reflexivity</span>.</span><br><span class=\"line\"><span class=\"keyword\">Qed</span>.</span><br></pre></td></tr></table></figure></p>"},{"title":"UPenn CIS 194 Haskell","toc":true,"date":"2023-04-13T06:17:32.000Z","_content":"\n\n# Haskell\n\nwith [UPenn CIS 194: Introduction to Haskell (Spring 2013)](https://www.cis.upenn.edu/~cis1940/spring13/)\n\nand with Algebra of Programming (Richard Bird & Oege de Moor)\n\n## 基本语法\n\n- 操作符\n  - `==` 等于\n  -  `/=` 不等于\n  -  `++` 两个列表相加\n  - `：`  向列表前加入一个元素\n  - `--` 或 `{- ... -}` 注释\n  - `$`  apply 分隔函数和参数（类似于括号）\n  - `where` 在alternatives中用于定义重复使用的变量\n\n<!--more-->\n\n- 列表 `list`\n  - `[ .. ]`\n  - 自动填充，如`[1..10]`\n  - 列表中的元素必须是相同类型\n  - `head`首个元素\n  - `tail`除首个元素之外的部分（作为一个列表返回）\n  - `null List` 检查List中是否有元素 `null:: [a] -> Bool`\n  - `reverse List` 将List反转\n  - `take num List` 返回List前num个元素（作为一个列表）\n  - `drop num List` 删除List中前num个元素，并返回操作后的列表（如果num大于等于列表长度则返回空列表）\n  - `min List` 返回列表中最小值\n  - `sum List` 返回列表元素之和\n  - `product` 返回列表元素之积\n  - `listName !! index` 下标运算符\n  - `ele  ·elem·   List` 判断元素ele是否在列表List中，`·notElem·`相反\n  - `cycle List / repeat Ele` 利用列表List或者元素Ele生成无线列表\n  - `replicate num Ele` 得到Ele重复num次构成的列表\n  - `lines :: String → [String]`  将一段内容分行，可以用`map func  . lines` 表示对每行施加函数func\n- `Tuple (ele1, ele2, ...)`\n  - fixed-size collection of values\n  - each value can have a different type\n- 列举类型的元素 `data DataType = xxx ; | xxx ; | xxx; ... ; deriving (Eq,Show)`\n- 说明\n  - `:info (operator)`\n  - `:type ele` 判断元素的类型\n  - `:set prompt \"ghci>\"` 修改提示符设置\n- 函数\n  - `funcname args = ...`\n  - 函数首字母不能大写\n  - `:| filename` 装载中的函数以供使用\n  - 本质上，Haskell的函数都只有一个参数，所有多个参数的函数都是Curry函数，先返回取第一个数为参数的函数，然后再以第二个数为参数调用它\n  - 用不全的参数调用函数可以创造新的函数\n- Haskell高阶函数\n- Type constructor\n  - `data TypeName = Constructor ... ; deriving (Show)`\n  - newtype TypeName = Constructor Field  – – different from data keyword, newtype can only have one constructor and exactly one field.\n- if-then-else 中 else 不可忽略\n\n\n## Haskell模块\n- 加载模块\n  - `import moduleName` (e.g. `Data.List`)\n  - `:m modName1 modName2 modName3`\n  - 加载模块中的函数 `import modName (funcName1, funcName2`\n  - 除某个函数以外加载 `import modName hiding (funcName)`\n  - 防止重名，要求全名指定 `import qualified modName1`\n  - 库重命名 `import quantified modName as varName`\n- 用Hoogle检索函数  https://hoogle.haskell.org/\n- 常用模块\n  - Prelude\n    - Prelude is a module with a bunch of standard definitions that gets implicitely imported into every Haskell program.\n    - `data Maybe a = Nothing | Just a`  : A useful polymorphic type, either contains a value of type a (wrapped in the Just constructor), or it is nothing (representing some sort of failure or error)\n  - Data.List\n    - `intersperce ele List` 将元素ele置于List每两个元素之间\n    - `intercalate List1 List2` 将List1置于List2每两个元素之间\n    - `transpose` 视列表的列表为矩阵进行转置操作\n    - `any`/`or` `boolFunc List` 检查元素符合条件\n    - `takeWhile boolFunc List` 遇到false停止 （类似函数有`span`, `break`）\n    - `delete ele List` 删掉该List中首次出现的这一元素\n    - `List1 \\\\ List2 ` 差集操作List1-List2\n    - `List1 ·union· List2` 并集（遍历List2，若某元素不属于List1，则追加到List1后）\n    - `List1 ·intersection· List2` 交集\n  - Data.Char\n    - 字符串的本质就是一组字符的List，所以往往会在`filter`或是`map`字符串时用到\n    - `generalCategory`函数返回值是情况的枚举（参考`Ordering LT, GT, EQ`）\n- Haskell 输入与输出\n  - `main = putStrLn \"hello, world\"`\n  - `putStrLn`型态为`IO()`，`putStr()`不打印换行，`putStr()`由`putChar()`递归定义得到\n    `putStr(x:xs) = do ; putChar x ; putStr xs`\n  - 一个I/O action会在绑定到`main`并执行程序的时候被触发\n  - 用`do`表示法将所有的I/O action绑成一个\n  - 读出内容 `var<-getLine`\n  - 注意区分：`oper=getLine`只是为`getLine`取了一个别名\n  - `when`在Control.Monad中，必须import才能得到\n    - 接受boolean值跟I/O action，如果True，就回传所给的I/O action，否则回传`return()`\n  - `sequence`接受一串I/O action，并回传会依序执行他们的I/O action（ `sequence :: [IO a] -> IO[a]` ）\n  - `forever`在Control.Monad中，回传一个永远作同一件事的I/O action\n  - 文件流`getContents`标准输入读取至EOF。惰性I/O，并不会马上读取所有输入\n  - 读取文件 `handle <- openFile fileName ReadMode ; contents <- hGetContents handle ; ... ; hClose handle ; (openFile :: FilePath -> IOMode -> IO Handle)`\n  - 其中，`openFile`，`ReadMode`，`hGetContents`，`hClose`；`type FilePath = String`, `data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode`\n  - 或者用`contents <- readFile fileName` 读取文件，无需考虑句柄的关闭\n  - Map implementation:\n    ```Haskell\n    map :: (a, b) → [a] → [b]\n    map _ [] = []\n    map f (x:xs) = f x : map f xs\n    ```\n  - Filter implementation:\n    ```Haskell\n    filter :: (a → Bool) → [a] → [a]\n    filter _ [ ] = [ ]\n    filter p (x:xs)\n       | p x = x : filter xs\n       | otherwise = filter xs\n    ```\n  - Fold implementation. e.g. `fold (+) 0 [1,2,3,4,5] => (1+(2+(3+(4+(5+0)))))`\n    ```Haskell\n    foldr :: (a → b → b) → b → [a] → b\n    foldr _ z [ ] = z\n    foldr f z (x:xs) = f x (foldr f z xs)\n    ```\n\n\n\n## UPenn CIS 194 2013\n\n### Week 2: Type Construct\n\n- Enumeration types:\n  - `data TypeName = ele1 ; | ele2 ; … ; deriving (Show, Eq, … )`\n  - `data AlgDataType = Constr1 Type11 Type12; | Constr2 Type 21 ; … ; deriving (Show, Eq , …)`\n  - `func :: type1 → type2 ; func ele1 = ele2 ; func ele3 = ele4 ; … ; func _ = rest`\n\n\n### Week 4: Higher-order programming and type inference\n- Anonymous functions (lambda abstraction)\n  - Here is an example\n    ```Haskell\n    greaterThan100 [1, 9, 349, 6, 907] = [349, 907]\n    greaterThan100 :: [Integer] → [Integer]\n    greaterThan100 xs = filter (\\x → x > 100) xs\n    Or equivalent: greaterThan199 xs = filter (>100) xs\n    ```\n  - `\\` is supposed to be as lambda, function `\\x -> x > 100` outputs whether x is greater than 100\n  - `(>100)` is an operator section: `?y` is equivalent to `\\x -> x ? y`, and `y?` Is equivalent to `\\x -> y ? x`\n- Function composition `(f.g)`\n  - useful in writing concise, elegant code\n- Currying and partial application\n  - `\\x y z ->` is syntax for `\\x -> (\\y -> (\\z -> ... ))`\n- Wholemeal programming\n  - ```Haskell\n    foobar :: [Integer] → Integer\n    foobar [] = 0\n    foobar (x:xs)\n      | x > 3 = (7*x+2) + foobar xs\n      | otherwise = foobar xs\n\n    foobar’ :: [Integer] → Integer\n    foobar’ = sum . map (\\x -> 7*x + 2) . filter (>3)\n    ```\n- Avoid the problem of doing too much at once and working at too low of a level.\n- This defines foobar' as a \"pipeline\" of three functions. First filter, then apply to every element, eventually sum them up.\n- Folds\n  - ```Haskell\n    fold :: b → (a → b → b) → [a] → b\n    fold z f []  = z\n    fold z f (x:xs) = f x (fold z f xs)\n    ```\n  - fold is already provided in the standard Prelude, under the name of `foldr :: (a→b→b) → a → [a] → b`\n  -\tThere is also `foldl`, which folds from the left (use `foldl'` from Data.List is more efficient)\n\n### Week 5: More Polymorphism and Type Classes\n\n- Parametricity\n  - `a -> a -> a` is a promise that `a` function with this type will work no matter what type the caller chooses, otherwise specify the type\n- Type classes\n  - Num, Eq, Ord and Show are type classes, and we say that `(==)`, `(<)`, `(+)` are \"type-class polymorphic\".\n  - `deriving (Eq, Ord, Show)` Tell GHC to automatically derive instances of the `Eq`, `Ord`, and `Show` type classes for our data type.\n- Standard type classes\n  - Ord: totally ordered, any two elements can be compared to see which is less than the other.\n  - Num: numeric types, support things like addition, subtraction, and multiplication.\n  - Show: defines the method Show, which is used to convert values into Strings\n  - Read: the dual of Show\n  - Integal: represents whole number types such as Int and Integer\n\n\n### Week 6: Lazy Evaluation\n\n- Strict evaluation\n  - Opposite to lazy evaluation, function arguments are completely evaluated before passing them to the function.\n- Consequences\n  - Purity\n  - To the recursion function, whether the list should be recursed before processed, or computed first before unwinding.\n  - For example, foldl’ requires the second argument to be evaluated before it proceeds, so a large thunk never builds up (compared with function foldl).\n- Infinite data structures\n  - Lazy evaluation means that we can work with inifinite data structures. Defining an infinite data structure actually only creates a thunk, which we can think of as a “seed”, out of which the entire data structure can potentially grow.\n- Dynamic programming\n  - One must take great care to fill in entries of a dynamic programming table in the proper order, so that its dependencies have already been computed. If we get the order wrong, we gor bogus results.\n\n\n\n### Week 8: I/O\n\n- `main` itself is an I/O action with type IO()\n- `do` defines a sequence of actions\n- Combining IO\n  - `(>>) :: IO a -> IO b -> IO b` ––running two input computation in sequence\n  \n","source":"_posts/UPenn-CIS-194-Haskell.md","raw":"---\ntitle: UPenn CIS 194 Haskell\ntoc: true\ndate: 2023-04-13 14:17:32\ntags:\ncategories:\n---\n\n\n# Haskell\n\nwith [UPenn CIS 194: Introduction to Haskell (Spring 2013)](https://www.cis.upenn.edu/~cis1940/spring13/)\n\nand with Algebra of Programming (Richard Bird & Oege de Moor)\n\n## 基本语法\n\n- 操作符\n  - `==` 等于\n  -  `/=` 不等于\n  -  `++` 两个列表相加\n  - `：`  向列表前加入一个元素\n  - `--` 或 `{- ... -}` 注释\n  - `$`  apply 分隔函数和参数（类似于括号）\n  - `where` 在alternatives中用于定义重复使用的变量\n\n<!--more-->\n\n- 列表 `list`\n  - `[ .. ]`\n  - 自动填充，如`[1..10]`\n  - 列表中的元素必须是相同类型\n  - `head`首个元素\n  - `tail`除首个元素之外的部分（作为一个列表返回）\n  - `null List` 检查List中是否有元素 `null:: [a] -> Bool`\n  - `reverse List` 将List反转\n  - `take num List` 返回List前num个元素（作为一个列表）\n  - `drop num List` 删除List中前num个元素，并返回操作后的列表（如果num大于等于列表长度则返回空列表）\n  - `min List` 返回列表中最小值\n  - `sum List` 返回列表元素之和\n  - `product` 返回列表元素之积\n  - `listName !! index` 下标运算符\n  - `ele  ·elem·   List` 判断元素ele是否在列表List中，`·notElem·`相反\n  - `cycle List / repeat Ele` 利用列表List或者元素Ele生成无线列表\n  - `replicate num Ele` 得到Ele重复num次构成的列表\n  - `lines :: String → [String]`  将一段内容分行，可以用`map func  . lines` 表示对每行施加函数func\n- `Tuple (ele1, ele2, ...)`\n  - fixed-size collection of values\n  - each value can have a different type\n- 列举类型的元素 `data DataType = xxx ; | xxx ; | xxx; ... ; deriving (Eq,Show)`\n- 说明\n  - `:info (operator)`\n  - `:type ele` 判断元素的类型\n  - `:set prompt \"ghci>\"` 修改提示符设置\n- 函数\n  - `funcname args = ...`\n  - 函数首字母不能大写\n  - `:| filename` 装载中的函数以供使用\n  - 本质上，Haskell的函数都只有一个参数，所有多个参数的函数都是Curry函数，先返回取第一个数为参数的函数，然后再以第二个数为参数调用它\n  - 用不全的参数调用函数可以创造新的函数\n- Haskell高阶函数\n- Type constructor\n  - `data TypeName = Constructor ... ; deriving (Show)`\n  - newtype TypeName = Constructor Field  – – different from data keyword, newtype can only have one constructor and exactly one field.\n- if-then-else 中 else 不可忽略\n\n\n## Haskell模块\n- 加载模块\n  - `import moduleName` (e.g. `Data.List`)\n  - `:m modName1 modName2 modName3`\n  - 加载模块中的函数 `import modName (funcName1, funcName2`\n  - 除某个函数以外加载 `import modName hiding (funcName)`\n  - 防止重名，要求全名指定 `import qualified modName1`\n  - 库重命名 `import quantified modName as varName`\n- 用Hoogle检索函数  https://hoogle.haskell.org/\n- 常用模块\n  - Prelude\n    - Prelude is a module with a bunch of standard definitions that gets implicitely imported into every Haskell program.\n    - `data Maybe a = Nothing | Just a`  : A useful polymorphic type, either contains a value of type a (wrapped in the Just constructor), or it is nothing (representing some sort of failure or error)\n  - Data.List\n    - `intersperce ele List` 将元素ele置于List每两个元素之间\n    - `intercalate List1 List2` 将List1置于List2每两个元素之间\n    - `transpose` 视列表的列表为矩阵进行转置操作\n    - `any`/`or` `boolFunc List` 检查元素符合条件\n    - `takeWhile boolFunc List` 遇到false停止 （类似函数有`span`, `break`）\n    - `delete ele List` 删掉该List中首次出现的这一元素\n    - `List1 \\\\ List2 ` 差集操作List1-List2\n    - `List1 ·union· List2` 并集（遍历List2，若某元素不属于List1，则追加到List1后）\n    - `List1 ·intersection· List2` 交集\n  - Data.Char\n    - 字符串的本质就是一组字符的List，所以往往会在`filter`或是`map`字符串时用到\n    - `generalCategory`函数返回值是情况的枚举（参考`Ordering LT, GT, EQ`）\n- Haskell 输入与输出\n  - `main = putStrLn \"hello, world\"`\n  - `putStrLn`型态为`IO()`，`putStr()`不打印换行，`putStr()`由`putChar()`递归定义得到\n    `putStr(x:xs) = do ; putChar x ; putStr xs`\n  - 一个I/O action会在绑定到`main`并执行程序的时候被触发\n  - 用`do`表示法将所有的I/O action绑成一个\n  - 读出内容 `var<-getLine`\n  - 注意区分：`oper=getLine`只是为`getLine`取了一个别名\n  - `when`在Control.Monad中，必须import才能得到\n    - 接受boolean值跟I/O action，如果True，就回传所给的I/O action，否则回传`return()`\n  - `sequence`接受一串I/O action，并回传会依序执行他们的I/O action（ `sequence :: [IO a] -> IO[a]` ）\n  - `forever`在Control.Monad中，回传一个永远作同一件事的I/O action\n  - 文件流`getContents`标准输入读取至EOF。惰性I/O，并不会马上读取所有输入\n  - 读取文件 `handle <- openFile fileName ReadMode ; contents <- hGetContents handle ; ... ; hClose handle ; (openFile :: FilePath -> IOMode -> IO Handle)`\n  - 其中，`openFile`，`ReadMode`，`hGetContents`，`hClose`；`type FilePath = String`, `data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode`\n  - 或者用`contents <- readFile fileName` 读取文件，无需考虑句柄的关闭\n  - Map implementation:\n    ```Haskell\n    map :: (a, b) → [a] → [b]\n    map _ [] = []\n    map f (x:xs) = f x : map f xs\n    ```\n  - Filter implementation:\n    ```Haskell\n    filter :: (a → Bool) → [a] → [a]\n    filter _ [ ] = [ ]\n    filter p (x:xs)\n       | p x = x : filter xs\n       | otherwise = filter xs\n    ```\n  - Fold implementation. e.g. `fold (+) 0 [1,2,3,4,5] => (1+(2+(3+(4+(5+0)))))`\n    ```Haskell\n    foldr :: (a → b → b) → b → [a] → b\n    foldr _ z [ ] = z\n    foldr f z (x:xs) = f x (foldr f z xs)\n    ```\n\n\n\n## UPenn CIS 194 2013\n\n### Week 2: Type Construct\n\n- Enumeration types:\n  - `data TypeName = ele1 ; | ele2 ; … ; deriving (Show, Eq, … )`\n  - `data AlgDataType = Constr1 Type11 Type12; | Constr2 Type 21 ; … ; deriving (Show, Eq , …)`\n  - `func :: type1 → type2 ; func ele1 = ele2 ; func ele3 = ele4 ; … ; func _ = rest`\n\n\n### Week 4: Higher-order programming and type inference\n- Anonymous functions (lambda abstraction)\n  - Here is an example\n    ```Haskell\n    greaterThan100 [1, 9, 349, 6, 907] = [349, 907]\n    greaterThan100 :: [Integer] → [Integer]\n    greaterThan100 xs = filter (\\x → x > 100) xs\n    Or equivalent: greaterThan199 xs = filter (>100) xs\n    ```\n  - `\\` is supposed to be as lambda, function `\\x -> x > 100` outputs whether x is greater than 100\n  - `(>100)` is an operator section: `?y` is equivalent to `\\x -> x ? y`, and `y?` Is equivalent to `\\x -> y ? x`\n- Function composition `(f.g)`\n  - useful in writing concise, elegant code\n- Currying and partial application\n  - `\\x y z ->` is syntax for `\\x -> (\\y -> (\\z -> ... ))`\n- Wholemeal programming\n  - ```Haskell\n    foobar :: [Integer] → Integer\n    foobar [] = 0\n    foobar (x:xs)\n      | x > 3 = (7*x+2) + foobar xs\n      | otherwise = foobar xs\n\n    foobar’ :: [Integer] → Integer\n    foobar’ = sum . map (\\x -> 7*x + 2) . filter (>3)\n    ```\n- Avoid the problem of doing too much at once and working at too low of a level.\n- This defines foobar' as a \"pipeline\" of three functions. First filter, then apply to every element, eventually sum them up.\n- Folds\n  - ```Haskell\n    fold :: b → (a → b → b) → [a] → b\n    fold z f []  = z\n    fold z f (x:xs) = f x (fold z f xs)\n    ```\n  - fold is already provided in the standard Prelude, under the name of `foldr :: (a→b→b) → a → [a] → b`\n  -\tThere is also `foldl`, which folds from the left (use `foldl'` from Data.List is more efficient)\n\n### Week 5: More Polymorphism and Type Classes\n\n- Parametricity\n  - `a -> a -> a` is a promise that `a` function with this type will work no matter what type the caller chooses, otherwise specify the type\n- Type classes\n  - Num, Eq, Ord and Show are type classes, and we say that `(==)`, `(<)`, `(+)` are \"type-class polymorphic\".\n  - `deriving (Eq, Ord, Show)` Tell GHC to automatically derive instances of the `Eq`, `Ord`, and `Show` type classes for our data type.\n- Standard type classes\n  - Ord: totally ordered, any two elements can be compared to see which is less than the other.\n  - Num: numeric types, support things like addition, subtraction, and multiplication.\n  - Show: defines the method Show, which is used to convert values into Strings\n  - Read: the dual of Show\n  - Integal: represents whole number types such as Int and Integer\n\n\n### Week 6: Lazy Evaluation\n\n- Strict evaluation\n  - Opposite to lazy evaluation, function arguments are completely evaluated before passing them to the function.\n- Consequences\n  - Purity\n  - To the recursion function, whether the list should be recursed before processed, or computed first before unwinding.\n  - For example, foldl’ requires the second argument to be evaluated before it proceeds, so a large thunk never builds up (compared with function foldl).\n- Infinite data structures\n  - Lazy evaluation means that we can work with inifinite data structures. Defining an infinite data structure actually only creates a thunk, which we can think of as a “seed”, out of which the entire data structure can potentially grow.\n- Dynamic programming\n  - One must take great care to fill in entries of a dynamic programming table in the proper order, so that its dependencies have already been computed. If we get the order wrong, we gor bogus results.\n\n\n\n### Week 8: I/O\n\n- `main` itself is an I/O action with type IO()\n- `do` defines a sequence of actions\n- Combining IO\n  - `(>>) :: IO a -> IO b -> IO b` ––running two input computation in sequence\n  \n","slug":"UPenn-CIS-194-Haskell","published":1,"updated":"2023-04-13T06:18:01.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgeqbeek0000p0mvhva8edzw","content":"<h1 id=\"haskell\">Haskell</h1>\r\n<p>with <a href=\"https://www.cis.upenn.edu/~cis1940/spring13/\">UPenn CIS\r\n194: Introduction to Haskell (Spring 2013)</a></p>\r\n<p>and with Algebra of Programming (Richard Bird &amp; Oege de Moor)</p>\r\n<h2 id=\"基本语法\">基本语法</h2>\r\n<ul>\r\n<li>操作符\r\n<ul>\r\n<li><code>==</code> 等于</li>\r\n<li><code>/=</code> 不等于</li>\r\n<li><code>++</code> 两个列表相加</li>\r\n<li><code>：</code> 向列表前加入一个元素</li>\r\n<li><code>--</code> 或 <code>&#123;- ... -&#125;</code> 注释</li>\r\n<li><code>$</code> apply 分隔函数和参数（类似于括号）</li>\r\n<li><code>where</code> 在alternatives中用于定义重复使用的变量</li>\r\n</ul></li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<ul>\r\n<li>列表 <code>list</code>\r\n<ul>\r\n<li><code>[ .. ]</code></li>\r\n<li>自动填充，如<code>[1..10]</code></li>\r\n<li>列表中的元素必须是相同类型</li>\r\n<li><code>head</code>首个元素</li>\r\n<li><code>tail</code>除首个元素之外的部分（作为一个列表返回）</li>\r\n<li><code>null List</code> 检查List中是否有元素\r\n<code>null:: [a] -&gt; Bool</code></li>\r\n<li><code>reverse List</code> 将List反转</li>\r\n<li><code>take num List</code> 返回List前num个元素（作为一个列表）</li>\r\n<li><code>drop num List</code>\r\n删除List中前num个元素，并返回操作后的列表（如果num大于等于列表长度则返回空列表）</li>\r\n<li><code>min List</code> 返回列表中最小值</li>\r\n<li><code>sum List</code> 返回列表元素之和</li>\r\n<li><code>product</code> 返回列表元素之积</li>\r\n<li><code>listName !! index</code> 下标运算符</li>\r\n<li><code>ele  ·elem·   List</code>\r\n判断元素ele是否在列表List中，<code>·notElem·</code>相反</li>\r\n<li><code>cycle List / repeat Ele</code>\r\n利用列表List或者元素Ele生成无线列表</li>\r\n<li><code>replicate num Ele</code> 得到Ele重复num次构成的列表</li>\r\n<li><code>lines :: String → [String]</code>\r\n将一段内容分行，可以用<code>map func  . lines</code>\r\n表示对每行施加函数func</li>\r\n</ul></li>\r\n<li><code>Tuple (ele1, ele2, ...)</code>\r\n<ul>\r\n<li>fixed-size collection of values</li>\r\n<li>each value can have a different type</li>\r\n</ul></li>\r\n<li>列举类型的元素\r\n<code>data DataType = xxx ; | xxx ; | xxx; ... ; deriving (Eq,Show)</code></li>\r\n<li>说明\r\n<ul>\r\n<li><code>:info (operator)</code></li>\r\n<li><code>:type ele</code> 判断元素的类型</li>\r\n<li><code>:set prompt \"ghci&gt;\"</code> 修改提示符设置</li>\r\n</ul></li>\r\n<li>函数\r\n<ul>\r\n<li><code>funcname args = ...</code></li>\r\n<li>函数首字母不能大写</li>\r\n<li><code>:| filename</code> 装载中的函数以供使用</li>\r\n<li>本质上，Haskell的函数都只有一个参数，所有多个参数的函数都是Curry函数，先返回取第一个数为参数的函数，然后再以第二个数为参数调用它</li>\r\n<li>用不全的参数调用函数可以创造新的函数</li>\r\n</ul></li>\r\n<li>Haskell高阶函数</li>\r\n<li>Type constructor\r\n<ul>\r\n<li><code>data TypeName = Constructor ... ; deriving (Show)</code></li>\r\n<li>newtype TypeName = Constructor Field – – different from data\r\nkeyword, newtype can only have one constructor and exactly one\r\nfield.</li>\r\n</ul></li>\r\n<li>if-then-else 中 else 不可忽略</li>\r\n</ul>\r\n<h2 id=\"haskell模块\">Haskell模块</h2>\r\n<ul>\r\n<li>加载模块\r\n<ul>\r\n<li><code>import moduleName</code> (e.g. <code>Data.List</code>)</li>\r\n<li><code>:m modName1 modName2 modName3</code></li>\r\n<li>加载模块中的函数\r\n<code>import modName (funcName1, funcName2</code></li>\r\n<li>除某个函数以外加载\r\n<code>import modName hiding (funcName)</code></li>\r\n<li>防止重名，要求全名指定 <code>import qualified modName1</code></li>\r\n<li>库重命名 <code>import quantified modName as varName</code></li>\r\n</ul></li>\r\n<li>用Hoogle检索函数 https://hoogle.haskell.org/</li>\r\n<li>常用模块\r\n<ul>\r\n<li>Prelude\r\n<ul>\r\n<li>Prelude is a module with a bunch of standard definitions that gets\r\nimplicitely imported into every Haskell program.</li>\r\n<li><code>data Maybe a = Nothing | Just a</code> : A useful polymorphic\r\ntype, either contains a value of type a (wrapped in the Just\r\nconstructor), or it is nothing (representing some sort of failure or\r\nerror)</li>\r\n</ul></li>\r\n<li>Data.List\r\n<ul>\r\n<li><code>intersperce ele List</code>\r\n将元素ele置于List每两个元素之间</li>\r\n<li><code>intercalate List1 List2</code>\r\n将List1置于List2每两个元素之间</li>\r\n<li><code>transpose</code> 视列表的列表为矩阵进行转置操作</li>\r\n<li><code>any</code>/<code>or</code> <code>boolFunc List</code>\r\n检查元素符合条件</li>\r\n<li><code>takeWhile boolFunc List</code> 遇到false停止\r\n（类似函数有<code>span</code>, <code>break</code>）</li>\r\n<li><code>delete ele List</code> 删掉该List中首次出现的这一元素</li>\r\n<li><code>List1 \\\\ List2</code> 差集操作List1-List2</li>\r\n<li><code>List1 ·union· List2</code>\r\n并集（遍历List2，若某元素不属于List1，则追加到List1后）</li>\r\n<li><code>List1 ·intersection· List2</code> 交集</li>\r\n</ul></li>\r\n<li>Data.Char\r\n<ul>\r\n<li>字符串的本质就是一组字符的List，所以往往会在<code>filter</code>或是<code>map</code>字符串时用到</li>\r\n<li><code>generalCategory</code>函数返回值是情况的枚举（参考<code>Ordering LT, GT, EQ</code>）</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Haskell 输入与输出\r\n<ul>\r\n<li><code>main = putStrLn \"hello, world\"</code></li>\r\n<li><code>putStrLn</code>型态为<code>IO()</code>，<code>putStr()</code>不打印换行，<code>putStr()</code>由<code>putChar()</code>递归定义得到\r\n<code>putStr(x:xs) = do ; putChar x ; putStr xs</code></li>\r\n<li>一个I/O action会在绑定到<code>main</code>并执行程序的时候被触发</li>\r\n<li>用<code>do</code>表示法将所有的I/O action绑成一个</li>\r\n<li>读出内容 <code>var&lt;-getLine</code></li>\r\n<li>注意区分：<code>oper=getLine</code>只是为<code>getLine</code>取了一个别名</li>\r\n<li><code>when</code>在Control.Monad中，必须import才能得到\r\n<ul>\r\n<li>接受boolean值跟I/O action，如果True，就回传所给的I/O\r\naction，否则回传<code>return()</code></li>\r\n</ul></li>\r\n<li><code>sequence</code>接受一串I/O action，并回传会依序执行他们的I/O\r\naction（ <code>sequence :: [IO a] -&gt; IO[a]</code> ）</li>\r\n<li><code>forever</code>在Control.Monad中，回传一个永远作同一件事的I/O\r\naction</li>\r\n<li>文件流<code>getContents</code>标准输入读取至EOF。惰性I/O，并不会马上读取所有输入</li>\r\n<li>读取文件\r\n<code>handle &lt;- openFile fileName ReadMode ; contents &lt;- hGetContents handle ; ... ; hClose handle ; (openFile :: FilePath -&gt; IOMode -&gt; IO Handle)</code></li>\r\n<li>其中，<code>openFile</code>，<code>ReadMode</code>，<code>hGetContents</code>，<code>hClose</code>；<code>type FilePath = String</code>,\r\n<code>data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode</code></li>\r\n<li>或者用<code>contents &lt;- readFile fileName</code>\r\n读取文件，无需考虑句柄的关闭</li>\r\n<li>Map implementation: <figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">map</span> :: (a, b) → [a] → [b]</span><br><span class=\"line\"><span class=\"title\">map</span> _ [] = []</span><br><span class=\"line\"><span class=\"title\">map</span> f (x:xs) = f x : map f xs</span><br></pre></td></tr></table></figure></li>\r\n<li>Filter implementation: <figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">filter</span> :: (a → <span class=\"type\">Bool</span>) → [a] → [a]</span><br><span class=\"line\"><span class=\"title\">filter</span> _ [ ] = [ ]</span><br><span class=\"line\"><span class=\"title\">filter</span> p (x:xs)</span><br><span class=\"line\">   | p x = x : filter xs</span><br><span class=\"line\">   | otherwise = filter xs</span><br></pre></td></tr></table></figure></li>\r\n<li>Fold implementation. e.g.\r\n<code>fold (+) 0 [1,2,3,4,5] =&gt; (1+(2+(3+(4+(5+0)))))</code>\r\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">foldr</span> :: (a → b → b) → b → [a] → b</span><br><span class=\"line\"><span class=\"title\">foldr</span> _ z [ ] = z</span><br><span class=\"line\"><span class=\"title\">foldr</span> f z (x:xs) = f x (foldr f z xs)</span><br></pre></td></tr></table></figure></li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"upenn-cis-194-2013\">UPenn CIS 194 2013</h2>\r\n<h3 id=\"week-2-type-construct\">Week 2: Type Construct</h3>\r\n<ul>\r\n<li>Enumeration types:\r\n<ul>\r\n<li><code>data TypeName = ele1 ; | ele2 ; … ; deriving (Show, Eq, … )</code></li>\r\n<li><code>data AlgDataType = Constr1 Type11 Type12; | Constr2 Type 21 ; … ; deriving (Show, Eq , …)</code></li>\r\n<li><code>func :: type1 → type2 ; func ele1 = ele2 ; func ele3 = ele4 ; … ; func _ = rest</code></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"week-4-higher-order-programming-and-type-inference\">Week 4:\r\nHigher-order programming and type inference</h3>\r\n<ul>\r\n<li>Anonymous functions (lambda abstraction)\r\n<ul>\r\n<li>Here is an example <figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">greaterThan100</span> [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">349</span>, <span class=\"number\">6</span>, <span class=\"number\">907</span>] = [<span class=\"number\">349</span>, <span class=\"number\">907</span>]</span><br><span class=\"line\"><span class=\"title\">greaterThan100</span> :: [<span class=\"type\">Integer</span>] → [<span class=\"type\">Integer</span>]</span><br><span class=\"line\"><span class=\"title\">greaterThan100</span> xs = filter (\\x → x &gt; <span class=\"number\">100</span>) xs</span><br><span class=\"line\"><span class=\"type\">Or</span> equivalent: greaterThan199 xs = filter (&gt;<span class=\"number\">100</span>) xs</span><br></pre></td></tr></table></figure></li>\r\n<li><code>\\</code> is supposed to be as lambda, function\r\n<code>\\x -&gt; x &gt; 100</code> outputs whether x is greater than\r\n100</li>\r\n<li><code>(&gt;100)</code> is an operator section: <code>?y</code> is\r\nequivalent to <code>\\x -&gt; x ? y</code>, and <code>y?</code> Is\r\nequivalent to <code>\\x -&gt; y ? x</code></li>\r\n</ul></li>\r\n<li>Function composition <code>(f.g)</code>\r\n<ul>\r\n<li>useful in writing concise, elegant code</li>\r\n</ul></li>\r\n<li>Currying and partial application\r\n<ul>\r\n<li><code>\\x y z -&gt;</code> is syntax for\r\n<code>\\x -&gt; (\\y -&gt; (\\z -&gt; ... ))</code></li>\r\n</ul></li>\r\n<li>Wholemeal programming\r\n<ul>\r\n<li><p>```Haskell foobar :: [Integer] → Integer foobar [] = 0 foobar\r\n(x:xs) | x &gt; 3 = (7*x+2) + foobar xs | otherwise = foobar xs</p>\r\n<p>foobar’ :: [Integer] → Integer foobar’ = sum . map (-&gt; 7*x + 2) .\r\nfilter (&gt;3) <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Avoid the problem of doing too much at once and working at too low of a level.</span><br><span class=\"line\">- This defines foobar&#x27; as a &quot;pipeline&quot; of three functions. First filter, then apply to every element, eventually sum them up.</span><br><span class=\"line\">- Folds</span><br><span class=\"line\">  - ```Haskell</span><br><span class=\"line\">    fold :: b → (a → b → b) → [a] → b</span><br><span class=\"line\">    fold z f []  = z</span><br><span class=\"line\">    fold z f (x:xs) = f x (fold z f xs)</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>fold is already provided in the standard Prelude, under the name\r\nof <code>foldr :: (a→b→b) → a → [a] → b</code></p></li>\r\n<li><p>There is also <code>foldl</code>, which folds from the left (use\r\n<code>foldl'</code> from Data.List is more efficient)</p></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"week-5-more-polymorphism-and-type-classes\">Week 5: More\r\nPolymorphism and Type Classes</h3>\r\n<ul>\r\n<li>Parametricity\r\n<ul>\r\n<li><code>a -&gt; a -&gt; a</code> is a promise that <code>a</code>\r\nfunction with this type will work no matter what type the caller\r\nchooses, otherwise specify the type</li>\r\n</ul></li>\r\n<li>Type classes\r\n<ul>\r\n<li>Num, Eq, Ord and Show are type classes, and we say that\r\n<code>(==)</code>, <code>(&lt;)</code>, <code>(+)</code> are \"type-class\r\npolymorphic\".</li>\r\n<li><code>deriving (Eq, Ord, Show)</code> Tell GHC to automatically\r\nderive instances of the <code>Eq</code>, <code>Ord</code>, and\r\n<code>Show</code> type classes for our data type.</li>\r\n</ul></li>\r\n<li>Standard type classes\r\n<ul>\r\n<li>Ord: totally ordered, any two elements can be compared to see which\r\nis less than the other.</li>\r\n<li>Num: numeric types, support things like addition, subtraction, and\r\nmultiplication.</li>\r\n<li>Show: defines the method Show, which is used to convert values into\r\nStrings</li>\r\n<li>Read: the dual of Show</li>\r\n<li>Integal: represents whole number types such as Int and Integer</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"week-6-lazy-evaluation\">Week 6: Lazy Evaluation</h3>\r\n<ul>\r\n<li>Strict evaluation\r\n<ul>\r\n<li>Opposite to lazy evaluation, function arguments are completely\r\nevaluated before passing them to the function.</li>\r\n</ul></li>\r\n<li>Consequences\r\n<ul>\r\n<li>Purity</li>\r\n<li>To the recursion function, whether the list should be recursed\r\nbefore processed, or computed first before unwinding.</li>\r\n<li>For example, foldl’ requires the second argument to be evaluated\r\nbefore it proceeds, so a large thunk never builds up (compared with\r\nfunction foldl).</li>\r\n</ul></li>\r\n<li>Infinite data structures\r\n<ul>\r\n<li>Lazy evaluation means that we can work with inifinite data\r\nstructures. Defining an infinite data structure actually only creates a\r\nthunk, which we can think of as a “seed”, out of which the entire data\r\nstructure can potentially grow.</li>\r\n</ul></li>\r\n<li>Dynamic programming\r\n<ul>\r\n<li>One must take great care to fill in entries of a dynamic programming\r\ntable in the proper order, so that its dependencies have already been\r\ncomputed. If we get the order wrong, we gor bogus results.</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"week-8-io\">Week 8: I/O</h3>\r\n<ul>\r\n<li><code>main</code> itself is an I/O action with type IO()</li>\r\n<li><code>do</code> defines a sequence of actions</li>\r\n<li>Combining IO\r\n<ul>\r\n<li><code>(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b</code> ––running two\r\ninput computation in sequence</li>\r\n</ul></li>\r\n</ul>\r\n","site":{"data":{}},"excerpt":"<h1 id=\"haskell\">Haskell</h1>\r\n<p>with <a href=\"https://www.cis.upenn.edu/~cis1940/spring13/\">UPenn CIS\r\n194: Introduction to Haskell (Spring 2013)</a></p>\r\n<p>and with Algebra of Programming (Richard Bird &amp; Oege de Moor)</p>\r\n<h2 id=\"基本语法\">基本语法</h2>\r\n<ul>\r\n<li>操作符\r\n<ul>\r\n<li><code>==</code> 等于</li>\r\n<li><code>/=</code> 不等于</li>\r\n<li><code>++</code> 两个列表相加</li>\r\n<li><code>：</code> 向列表前加入一个元素</li>\r\n<li><code>--</code> 或 <code>&#123;- ... -&#125;</code> 注释</li>\r\n<li><code>$</code> apply 分隔函数和参数（类似于括号）</li>\r\n<li><code>where</code> 在alternatives中用于定义重复使用的变量</li>\r\n</ul></li>\r\n</ul>","more":"<ul>\r\n<li>列表 <code>list</code>\r\n<ul>\r\n<li><code>[ .. ]</code></li>\r\n<li>自动填充，如<code>[1..10]</code></li>\r\n<li>列表中的元素必须是相同类型</li>\r\n<li><code>head</code>首个元素</li>\r\n<li><code>tail</code>除首个元素之外的部分（作为一个列表返回）</li>\r\n<li><code>null List</code> 检查List中是否有元素\r\n<code>null:: [a] -&gt; Bool</code></li>\r\n<li><code>reverse List</code> 将List反转</li>\r\n<li><code>take num List</code> 返回List前num个元素（作为一个列表）</li>\r\n<li><code>drop num List</code>\r\n删除List中前num个元素，并返回操作后的列表（如果num大于等于列表长度则返回空列表）</li>\r\n<li><code>min List</code> 返回列表中最小值</li>\r\n<li><code>sum List</code> 返回列表元素之和</li>\r\n<li><code>product</code> 返回列表元素之积</li>\r\n<li><code>listName !! index</code> 下标运算符</li>\r\n<li><code>ele  ·elem·   List</code>\r\n判断元素ele是否在列表List中，<code>·notElem·</code>相反</li>\r\n<li><code>cycle List / repeat Ele</code>\r\n利用列表List或者元素Ele生成无线列表</li>\r\n<li><code>replicate num Ele</code> 得到Ele重复num次构成的列表</li>\r\n<li><code>lines :: String → [String]</code>\r\n将一段内容分行，可以用<code>map func  . lines</code>\r\n表示对每行施加函数func</li>\r\n</ul></li>\r\n<li><code>Tuple (ele1, ele2, ...)</code>\r\n<ul>\r\n<li>fixed-size collection of values</li>\r\n<li>each value can have a different type</li>\r\n</ul></li>\r\n<li>列举类型的元素\r\n<code>data DataType = xxx ; | xxx ; | xxx; ... ; deriving (Eq,Show)</code></li>\r\n<li>说明\r\n<ul>\r\n<li><code>:info (operator)</code></li>\r\n<li><code>:type ele</code> 判断元素的类型</li>\r\n<li><code>:set prompt \"ghci&gt;\"</code> 修改提示符设置</li>\r\n</ul></li>\r\n<li>函数\r\n<ul>\r\n<li><code>funcname args = ...</code></li>\r\n<li>函数首字母不能大写</li>\r\n<li><code>:| filename</code> 装载中的函数以供使用</li>\r\n<li>本质上，Haskell的函数都只有一个参数，所有多个参数的函数都是Curry函数，先返回取第一个数为参数的函数，然后再以第二个数为参数调用它</li>\r\n<li>用不全的参数调用函数可以创造新的函数</li>\r\n</ul></li>\r\n<li>Haskell高阶函数</li>\r\n<li>Type constructor\r\n<ul>\r\n<li><code>data TypeName = Constructor ... ; deriving (Show)</code></li>\r\n<li>newtype TypeName = Constructor Field – – different from data\r\nkeyword, newtype can only have one constructor and exactly one\r\nfield.</li>\r\n</ul></li>\r\n<li>if-then-else 中 else 不可忽略</li>\r\n</ul>\r\n<h2 id=\"haskell模块\">Haskell模块</h2>\r\n<ul>\r\n<li>加载模块\r\n<ul>\r\n<li><code>import moduleName</code> (e.g. <code>Data.List</code>)</li>\r\n<li><code>:m modName1 modName2 modName3</code></li>\r\n<li>加载模块中的函数\r\n<code>import modName (funcName1, funcName2</code></li>\r\n<li>除某个函数以外加载\r\n<code>import modName hiding (funcName)</code></li>\r\n<li>防止重名，要求全名指定 <code>import qualified modName1</code></li>\r\n<li>库重命名 <code>import quantified modName as varName</code></li>\r\n</ul></li>\r\n<li>用Hoogle检索函数 https://hoogle.haskell.org/</li>\r\n<li>常用模块\r\n<ul>\r\n<li>Prelude\r\n<ul>\r\n<li>Prelude is a module with a bunch of standard definitions that gets\r\nimplicitely imported into every Haskell program.</li>\r\n<li><code>data Maybe a = Nothing | Just a</code> : A useful polymorphic\r\ntype, either contains a value of type a (wrapped in the Just\r\nconstructor), or it is nothing (representing some sort of failure or\r\nerror)</li>\r\n</ul></li>\r\n<li>Data.List\r\n<ul>\r\n<li><code>intersperce ele List</code>\r\n将元素ele置于List每两个元素之间</li>\r\n<li><code>intercalate List1 List2</code>\r\n将List1置于List2每两个元素之间</li>\r\n<li><code>transpose</code> 视列表的列表为矩阵进行转置操作</li>\r\n<li><code>any</code>/<code>or</code> <code>boolFunc List</code>\r\n检查元素符合条件</li>\r\n<li><code>takeWhile boolFunc List</code> 遇到false停止\r\n（类似函数有<code>span</code>, <code>break</code>）</li>\r\n<li><code>delete ele List</code> 删掉该List中首次出现的这一元素</li>\r\n<li><code>List1 \\\\ List2</code> 差集操作List1-List2</li>\r\n<li><code>List1 ·union· List2</code>\r\n并集（遍历List2，若某元素不属于List1，则追加到List1后）</li>\r\n<li><code>List1 ·intersection· List2</code> 交集</li>\r\n</ul></li>\r\n<li>Data.Char\r\n<ul>\r\n<li>字符串的本质就是一组字符的List，所以往往会在<code>filter</code>或是<code>map</code>字符串时用到</li>\r\n<li><code>generalCategory</code>函数返回值是情况的枚举（参考<code>Ordering LT, GT, EQ</code>）</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>Haskell 输入与输出\r\n<ul>\r\n<li><code>main = putStrLn \"hello, world\"</code></li>\r\n<li><code>putStrLn</code>型态为<code>IO()</code>，<code>putStr()</code>不打印换行，<code>putStr()</code>由<code>putChar()</code>递归定义得到\r\n<code>putStr(x:xs) = do ; putChar x ; putStr xs</code></li>\r\n<li>一个I/O action会在绑定到<code>main</code>并执行程序的时候被触发</li>\r\n<li>用<code>do</code>表示法将所有的I/O action绑成一个</li>\r\n<li>读出内容 <code>var&lt;-getLine</code></li>\r\n<li>注意区分：<code>oper=getLine</code>只是为<code>getLine</code>取了一个别名</li>\r\n<li><code>when</code>在Control.Monad中，必须import才能得到\r\n<ul>\r\n<li>接受boolean值跟I/O action，如果True，就回传所给的I/O\r\naction，否则回传<code>return()</code></li>\r\n</ul></li>\r\n<li><code>sequence</code>接受一串I/O action，并回传会依序执行他们的I/O\r\naction（ <code>sequence :: [IO a] -&gt; IO[a]</code> ）</li>\r\n<li><code>forever</code>在Control.Monad中，回传一个永远作同一件事的I/O\r\naction</li>\r\n<li>文件流<code>getContents</code>标准输入读取至EOF。惰性I/O，并不会马上读取所有输入</li>\r\n<li>读取文件\r\n<code>handle &lt;- openFile fileName ReadMode ; contents &lt;- hGetContents handle ; ... ; hClose handle ; (openFile :: FilePath -&gt; IOMode -&gt; IO Handle)</code></li>\r\n<li>其中，<code>openFile</code>，<code>ReadMode</code>，<code>hGetContents</code>，<code>hClose</code>；<code>type FilePath = String</code>,\r\n<code>data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode</code></li>\r\n<li>或者用<code>contents &lt;- readFile fileName</code>\r\n读取文件，无需考虑句柄的关闭</li>\r\n<li>Map implementation: <figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">map</span> :: (a, b) → [a] → [b]</span><br><span class=\"line\"><span class=\"title\">map</span> _ [] = []</span><br><span class=\"line\"><span class=\"title\">map</span> f (x:xs) = f x : map f xs</span><br></pre></td></tr></table></figure></li>\r\n<li>Filter implementation: <figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">filter</span> :: (a → <span class=\"type\">Bool</span>) → [a] → [a]</span><br><span class=\"line\"><span class=\"title\">filter</span> _ [ ] = [ ]</span><br><span class=\"line\"><span class=\"title\">filter</span> p (x:xs)</span><br><span class=\"line\">   | p x = x : filter xs</span><br><span class=\"line\">   | otherwise = filter xs</span><br></pre></td></tr></table></figure></li>\r\n<li>Fold implementation. e.g.\r\n<code>fold (+) 0 [1,2,3,4,5] =&gt; (1+(2+(3+(4+(5+0)))))</code>\r\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">foldr</span> :: (a → b → b) → b → [a] → b</span><br><span class=\"line\"><span class=\"title\">foldr</span> _ z [ ] = z</span><br><span class=\"line\"><span class=\"title\">foldr</span> f z (x:xs) = f x (foldr f z xs)</span><br></pre></td></tr></table></figure></li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"upenn-cis-194-2013\">UPenn CIS 194 2013</h2>\r\n<h3 id=\"week-2-type-construct\">Week 2: Type Construct</h3>\r\n<ul>\r\n<li>Enumeration types:\r\n<ul>\r\n<li><code>data TypeName = ele1 ; | ele2 ; … ; deriving (Show, Eq, … )</code></li>\r\n<li><code>data AlgDataType = Constr1 Type11 Type12; | Constr2 Type 21 ; … ; deriving (Show, Eq , …)</code></li>\r\n<li><code>func :: type1 → type2 ; func ele1 = ele2 ; func ele3 = ele4 ; … ; func _ = rest</code></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"week-4-higher-order-programming-and-type-inference\">Week 4:\r\nHigher-order programming and type inference</h3>\r\n<ul>\r\n<li>Anonymous functions (lambda abstraction)\r\n<ul>\r\n<li>Here is an example <figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">greaterThan100</span> [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">349</span>, <span class=\"number\">6</span>, <span class=\"number\">907</span>] = [<span class=\"number\">349</span>, <span class=\"number\">907</span>]</span><br><span class=\"line\"><span class=\"title\">greaterThan100</span> :: [<span class=\"type\">Integer</span>] → [<span class=\"type\">Integer</span>]</span><br><span class=\"line\"><span class=\"title\">greaterThan100</span> xs = filter (\\x → x &gt; <span class=\"number\">100</span>) xs</span><br><span class=\"line\"><span class=\"type\">Or</span> equivalent: greaterThan199 xs = filter (&gt;<span class=\"number\">100</span>) xs</span><br></pre></td></tr></table></figure></li>\r\n<li><code>\\</code> is supposed to be as lambda, function\r\n<code>\\x -&gt; x &gt; 100</code> outputs whether x is greater than\r\n100</li>\r\n<li><code>(&gt;100)</code> is an operator section: <code>?y</code> is\r\nequivalent to <code>\\x -&gt; x ? y</code>, and <code>y?</code> Is\r\nequivalent to <code>\\x -&gt; y ? x</code></li>\r\n</ul></li>\r\n<li>Function composition <code>(f.g)</code>\r\n<ul>\r\n<li>useful in writing concise, elegant code</li>\r\n</ul></li>\r\n<li>Currying and partial application\r\n<ul>\r\n<li><code>\\x y z -&gt;</code> is syntax for\r\n<code>\\x -&gt; (\\y -&gt; (\\z -&gt; ... ))</code></li>\r\n</ul></li>\r\n<li>Wholemeal programming\r\n<ul>\r\n<li><p>```Haskell foobar :: [Integer] → Integer foobar [] = 0 foobar\r\n(x:xs) | x &gt; 3 = (7*x+2) + foobar xs | otherwise = foobar xs</p>\r\n<p>foobar’ :: [Integer] → Integer foobar’ = sum . map (-&gt; 7*x + 2) .\r\nfilter (&gt;3) <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Avoid the problem of doing too much at once and working at too low of a level.</span><br><span class=\"line\">- This defines foobar&#x27; as a &quot;pipeline&quot; of three functions. First filter, then apply to every element, eventually sum them up.</span><br><span class=\"line\">- Folds</span><br><span class=\"line\">  - ```Haskell</span><br><span class=\"line\">    fold :: b → (a → b → b) → [a] → b</span><br><span class=\"line\">    fold z f []  = z</span><br><span class=\"line\">    fold z f (x:xs) = f x (fold z f xs)</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>fold is already provided in the standard Prelude, under the name\r\nof <code>foldr :: (a→b→b) → a → [a] → b</code></p></li>\r\n<li><p>There is also <code>foldl</code>, which folds from the left (use\r\n<code>foldl'</code> from Data.List is more efficient)</p></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"week-5-more-polymorphism-and-type-classes\">Week 5: More\r\nPolymorphism and Type Classes</h3>\r\n<ul>\r\n<li>Parametricity\r\n<ul>\r\n<li><code>a -&gt; a -&gt; a</code> is a promise that <code>a</code>\r\nfunction with this type will work no matter what type the caller\r\nchooses, otherwise specify the type</li>\r\n</ul></li>\r\n<li>Type classes\r\n<ul>\r\n<li>Num, Eq, Ord and Show are type classes, and we say that\r\n<code>(==)</code>, <code>(&lt;)</code>, <code>(+)</code> are \"type-class\r\npolymorphic\".</li>\r\n<li><code>deriving (Eq, Ord, Show)</code> Tell GHC to automatically\r\nderive instances of the <code>Eq</code>, <code>Ord</code>, and\r\n<code>Show</code> type classes for our data type.</li>\r\n</ul></li>\r\n<li>Standard type classes\r\n<ul>\r\n<li>Ord: totally ordered, any two elements can be compared to see which\r\nis less than the other.</li>\r\n<li>Num: numeric types, support things like addition, subtraction, and\r\nmultiplication.</li>\r\n<li>Show: defines the method Show, which is used to convert values into\r\nStrings</li>\r\n<li>Read: the dual of Show</li>\r\n<li>Integal: represents whole number types such as Int and Integer</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"week-6-lazy-evaluation\">Week 6: Lazy Evaluation</h3>\r\n<ul>\r\n<li>Strict evaluation\r\n<ul>\r\n<li>Opposite to lazy evaluation, function arguments are completely\r\nevaluated before passing them to the function.</li>\r\n</ul></li>\r\n<li>Consequences\r\n<ul>\r\n<li>Purity</li>\r\n<li>To the recursion function, whether the list should be recursed\r\nbefore processed, or computed first before unwinding.</li>\r\n<li>For example, foldl’ requires the second argument to be evaluated\r\nbefore it proceeds, so a large thunk never builds up (compared with\r\nfunction foldl).</li>\r\n</ul></li>\r\n<li>Infinite data structures\r\n<ul>\r\n<li>Lazy evaluation means that we can work with inifinite data\r\nstructures. Defining an infinite data structure actually only creates a\r\nthunk, which we can think of as a “seed”, out of which the entire data\r\nstructure can potentially grow.</li>\r\n</ul></li>\r\n<li>Dynamic programming\r\n<ul>\r\n<li>One must take great care to fill in entries of a dynamic programming\r\ntable in the proper order, so that its dependencies have already been\r\ncomputed. If we get the order wrong, we gor bogus results.</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"week-8-io\">Week 8: I/O</h3>\r\n<ul>\r\n<li><code>main</code> itself is an I/O action with type IO()</li>\r\n<li><code>do</code> defines a sequence of actions</li>\r\n<li>Combining IO\r\n<ul>\r\n<li><code>(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b</code> ––running two\r\ninput computation in sequence</li>\r\n</ul></li>\r\n</ul>"}],"PostAsset":[{"_id":"source/_posts/Basics/02-step_by_step_1.png","slug":"02-step_by_step_1.png","post":"clg1287ju0003x8mv1apa5wk9","modified":0,"renderable":0},{"_id":"source/_posts/Basics/02-notation.png","slug":"02-notation.png","post":"clg1287ju0003x8mv1apa5wk9","modified":0,"renderable":0},{"_id":"source/_posts/Basics/02-step_by_step_2.png","slug":"02-step_by_step_2.png","post":"clg1287ju0003x8mv1apa5wk9","modified":0,"renderable":0},{"_id":"source/_posts/Basics/02-step_by_step_3.png","slug":"02-step_by_step_3.png","post":"clg1287ju0003x8mv1apa5wk9","modified":0,"renderable":0},{"_id":"source/_posts/Basics/02-step_by_step_4.png","slug":"02-step_by_step_4.png","post":"clg1287ju0003x8mv1apa5wk9","modified":0,"renderable":0},{"_id":"source/_posts/Sipser-Part-One/sipser_lec3_pic1.png","slug":"sipser_lec3_pic1.png","post":"clgbzoyc60000lgmvfei144h3","modified":0,"renderable":0},{"_id":"source/_posts/Sipser-Part-One/sipser_lec6_pic1.png","slug":"sipser_lec6_pic1.png","post":"clgbzoyc60000lgmvfei144h3","modified":0,"renderable":0},{"_id":"source/_posts/Sipser-Part-One/sipser_lec6_pic2.png","slug":"sipser_lec6_pic2.png","post":"clgbzoyc60000lgmvfei144h3","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[],"Tag":[]}}