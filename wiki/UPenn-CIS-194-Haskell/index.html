<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>UPenn CIS 194 Haskell | 肖扬的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Haskell with UPenn CIS 194: Introduction to Haskell (Spring 2013) and with Algebra of Programming (Richard Bird &amp; Oege de Moor) 基本语法  操作符  &#x3D;&#x3D; 等于 &#x2F;&#x3D; 不等于 ++ 两个列表相加 ： 向列表前加入一个元素 -- 或 &amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="UPenn CIS 194 Haskell">
<meta property="og:url" content="http://example.com/wiki/UPenn-CIS-194-Haskell/index.html">
<meta property="og:site_name" content="肖扬的博客">
<meta property="og:description" content="Haskell with UPenn CIS 194: Introduction to Haskell (Spring 2013) and with Algebra of Programming (Richard Bird &amp; Oege de Moor) 基本语法  操作符  &#x3D;&#x3D; 等于 &#x2F;&#x3D; 不等于 ++ 两个列表相加 ： 向列表前加入一个元素 -- 或 &amp;#12">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-13T06:17:32.000Z">
<meta property="article:modified_time" content="2023-04-13T06:18:01.541Z">
<meta property="article:author" content="肖扬">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="肖扬的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">肖扬的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-UPenn-CIS-194-Haskell" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/wiki/UPenn-CIS-194-Haskell/" class="article-date">
  <time datetime="2023-04-13T06:17:32.000Z" itemprop="datePublished">2023-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      UPenn CIS 194 Haskell
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="haskell">Haskell</h1>
<p>with <a target="_blank" rel="noopener" href="https://www.cis.upenn.edu/~cis1940/spring13/">UPenn CIS
194: Introduction to Haskell (Spring 2013)</a></p>
<p>and with Algebra of Programming (Richard Bird &amp; Oege de Moor)</p>
<h2 id="基本语法">基本语法</h2>
<ul>
<li>操作符
<ul>
<li><code>==</code> 等于</li>
<li><code>/=</code> 不等于</li>
<li><code>++</code> 两个列表相加</li>
<li><code>：</code> 向列表前加入一个元素</li>
<li><code>--</code> 或 <code>&#123;- ... -&#125;</code> 注释</li>
<li><code>$</code> apply 分隔函数和参数（类似于括号）</li>
<li><code>where</code> 在alternatives中用于定义重复使用的变量</li>
</ul></li>
</ul>
<span id="more"></span>
<ul>
<li>列表 <code>list</code>
<ul>
<li><code>[ .. ]</code></li>
<li>自动填充，如<code>[1..10]</code></li>
<li>列表中的元素必须是相同类型</li>
<li><code>head</code>首个元素</li>
<li><code>tail</code>除首个元素之外的部分（作为一个列表返回）</li>
<li><code>null List</code> 检查List中是否有元素
<code>null:: [a] -&gt; Bool</code></li>
<li><code>reverse List</code> 将List反转</li>
<li><code>take num List</code> 返回List前num个元素（作为一个列表）</li>
<li><code>drop num List</code>
删除List中前num个元素，并返回操作后的列表（如果num大于等于列表长度则返回空列表）</li>
<li><code>min List</code> 返回列表中最小值</li>
<li><code>sum List</code> 返回列表元素之和</li>
<li><code>product</code> 返回列表元素之积</li>
<li><code>listName !! index</code> 下标运算符</li>
<li><code>ele  ·elem·   List</code>
判断元素ele是否在列表List中，<code>·notElem·</code>相反</li>
<li><code>cycle List / repeat Ele</code>
利用列表List或者元素Ele生成无线列表</li>
<li><code>replicate num Ele</code> 得到Ele重复num次构成的列表</li>
<li><code>lines :: String → [String]</code>
将一段内容分行，可以用<code>map func  . lines</code>
表示对每行施加函数func</li>
</ul></li>
<li><code>Tuple (ele1, ele2, ...)</code>
<ul>
<li>fixed-size collection of values</li>
<li>each value can have a different type</li>
</ul></li>
<li>列举类型的元素
<code>data DataType = xxx ; | xxx ; | xxx; ... ; deriving (Eq,Show)</code></li>
<li>说明
<ul>
<li><code>:info (operator)</code></li>
<li><code>:type ele</code> 判断元素的类型</li>
<li><code>:set prompt "ghci&gt;"</code> 修改提示符设置</li>
</ul></li>
<li>函数
<ul>
<li><code>funcname args = ...</code></li>
<li>函数首字母不能大写</li>
<li><code>:| filename</code> 装载中的函数以供使用</li>
<li>本质上，Haskell的函数都只有一个参数，所有多个参数的函数都是Curry函数，先返回取第一个数为参数的函数，然后再以第二个数为参数调用它</li>
<li>用不全的参数调用函数可以创造新的函数</li>
</ul></li>
<li>Haskell高阶函数</li>
<li>Type constructor
<ul>
<li><code>data TypeName = Constructor ... ; deriving (Show)</code></li>
<li>newtype TypeName = Constructor Field – – different from data
keyword, newtype can only have one constructor and exactly one
field.</li>
</ul></li>
<li>if-then-else 中 else 不可忽略</li>
</ul>
<h2 id="haskell模块">Haskell模块</h2>
<ul>
<li>加载模块
<ul>
<li><code>import moduleName</code> (e.g. <code>Data.List</code>)</li>
<li><code>:m modName1 modName2 modName3</code></li>
<li>加载模块中的函数
<code>import modName (funcName1, funcName2</code></li>
<li>除某个函数以外加载
<code>import modName hiding (funcName)</code></li>
<li>防止重名，要求全名指定 <code>import qualified modName1</code></li>
<li>库重命名 <code>import quantified modName as varName</code></li>
</ul></li>
<li>用Hoogle检索函数 https://hoogle.haskell.org/</li>
<li>常用模块
<ul>
<li>Prelude
<ul>
<li>Prelude is a module with a bunch of standard definitions that gets
implicitely imported into every Haskell program.</li>
<li><code>data Maybe a = Nothing | Just a</code> : A useful polymorphic
type, either contains a value of type a (wrapped in the Just
constructor), or it is nothing (representing some sort of failure or
error)</li>
</ul></li>
<li>Data.List
<ul>
<li><code>intersperce ele List</code>
将元素ele置于List每两个元素之间</li>
<li><code>intercalate List1 List2</code>
将List1置于List2每两个元素之间</li>
<li><code>transpose</code> 视列表的列表为矩阵进行转置操作</li>
<li><code>any</code>/<code>or</code> <code>boolFunc List</code>
检查元素符合条件</li>
<li><code>takeWhile boolFunc List</code> 遇到false停止
（类似函数有<code>span</code>, <code>break</code>）</li>
<li><code>delete ele List</code> 删掉该List中首次出现的这一元素</li>
<li><code>List1 \\ List2</code> 差集操作List1-List2</li>
<li><code>List1 ·union· List2</code>
并集（遍历List2，若某元素不属于List1，则追加到List1后）</li>
<li><code>List1 ·intersection· List2</code> 交集</li>
</ul></li>
<li>Data.Char
<ul>
<li>字符串的本质就是一组字符的List，所以往往会在<code>filter</code>或是<code>map</code>字符串时用到</li>
<li><code>generalCategory</code>函数返回值是情况的枚举（参考<code>Ordering LT, GT, EQ</code>）</li>
</ul></li>
</ul></li>
<li>Haskell 输入与输出
<ul>
<li><code>main = putStrLn "hello, world"</code></li>
<li><code>putStrLn</code>型态为<code>IO()</code>，<code>putStr()</code>不打印换行，<code>putStr()</code>由<code>putChar()</code>递归定义得到
<code>putStr(x:xs) = do ; putChar x ; putStr xs</code></li>
<li>一个I/O action会在绑定到<code>main</code>并执行程序的时候被触发</li>
<li>用<code>do</code>表示法将所有的I/O action绑成一个</li>
<li>读出内容 <code>var&lt;-getLine</code></li>
<li>注意区分：<code>oper=getLine</code>只是为<code>getLine</code>取了一个别名</li>
<li><code>when</code>在Control.Monad中，必须import才能得到
<ul>
<li>接受boolean值跟I/O action，如果True，就回传所给的I/O
action，否则回传<code>return()</code></li>
</ul></li>
<li><code>sequence</code>接受一串I/O action，并回传会依序执行他们的I/O
action（ <code>sequence :: [IO a] -&gt; IO[a]</code> ）</li>
<li><code>forever</code>在Control.Monad中，回传一个永远作同一件事的I/O
action</li>
<li>文件流<code>getContents</code>标准输入读取至EOF。惰性I/O，并不会马上读取所有输入</li>
<li>读取文件
<code>handle &lt;- openFile fileName ReadMode ; contents &lt;- hGetContents handle ; ... ; hClose handle ; (openFile :: FilePath -&gt; IOMode -&gt; IO Handle)</code></li>
<li>其中，<code>openFile</code>，<code>ReadMode</code>，<code>hGetContents</code>，<code>hClose</code>；<code>type FilePath = String</code>,
<code>data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode</code></li>
<li>或者用<code>contents &lt;- readFile fileName</code>
读取文件，无需考虑句柄的关闭</li>
<li>Map implementation: <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a, b) → [a] → [b]</span><br><span class="line"><span class="title">map</span> _ [] = []</span><br><span class="line"><span class="title">map</span> f (x:xs) = f x : map f xs</span><br></pre></td></tr></table></figure></li>
<li>Filter implementation: <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: (a → <span class="type">Bool</span>) → [a] → [a]</span><br><span class="line"><span class="title">filter</span> _ [ ] = [ ]</span><br><span class="line"><span class="title">filter</span> p (x:xs)</span><br><span class="line">   | p x = x : filter xs</span><br><span class="line">   | otherwise = filter xs</span><br></pre></td></tr></table></figure></li>
<li>Fold implementation. e.g.
<code>fold (+) 0 [1,2,3,4,5] =&gt; (1+(2+(3+(4+(5+0)))))</code>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldr</span> :: (a → b → b) → b → [a] → b</span><br><span class="line"><span class="title">foldr</span> _ z [ ] = z</span><br><span class="line"><span class="title">foldr</span> f z (x:xs) = f x (foldr f z xs)</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="upenn-cis-194-2013">UPenn CIS 194 2013</h2>
<h3 id="week-2-type-construct">Week 2: Type Construct</h3>
<ul>
<li>Enumeration types:
<ul>
<li><code>data TypeName = ele1 ; | ele2 ; … ; deriving (Show, Eq, … )</code></li>
<li><code>data AlgDataType = Constr1 Type11 Type12; | Constr2 Type 21 ; … ; deriving (Show, Eq , …)</code></li>
<li><code>func :: type1 → type2 ; func ele1 = ele2 ; func ele3 = ele4 ; … ; func _ = rest</code></li>
</ul></li>
</ul>
<h3 id="week-4-higher-order-programming-and-type-inference">Week 4:
Higher-order programming and type inference</h3>
<ul>
<li>Anonymous functions (lambda abstraction)
<ul>
<li>Here is an example <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">greaterThan100</span> [<span class="number">1</span>, <span class="number">9</span>, <span class="number">349</span>, <span class="number">6</span>, <span class="number">907</span>] = [<span class="number">349</span>, <span class="number">907</span>]</span><br><span class="line"><span class="title">greaterThan100</span> :: [<span class="type">Integer</span>] → [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">greaterThan100</span> xs = filter (\x → x &gt; <span class="number">100</span>) xs</span><br><span class="line"><span class="type">Or</span> equivalent: greaterThan199 xs = filter (&gt;<span class="number">100</span>) xs</span><br></pre></td></tr></table></figure></li>
<li><code>\</code> is supposed to be as lambda, function
<code>\x -&gt; x &gt; 100</code> outputs whether x is greater than
100</li>
<li><code>(&gt;100)</code> is an operator section: <code>?y</code> is
equivalent to <code>\x -&gt; x ? y</code>, and <code>y?</code> Is
equivalent to <code>\x -&gt; y ? x</code></li>
</ul></li>
<li>Function composition <code>(f.g)</code>
<ul>
<li>useful in writing concise, elegant code</li>
</ul></li>
<li>Currying and partial application
<ul>
<li><code>\x y z -&gt;</code> is syntax for
<code>\x -&gt; (\y -&gt; (\z -&gt; ... ))</code></li>
</ul></li>
<li>Wholemeal programming
<ul>
<li><p>```Haskell foobar :: [Integer] → Integer foobar [] = 0 foobar
(x:xs) | x &gt; 3 = (7*x+2) + foobar xs | otherwise = foobar xs</p>
<p>foobar’ :: [Integer] → Integer foobar’ = sum . map (-&gt; 7*x + 2) .
filter (&gt;3) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- Avoid the problem of doing too much at once and working at too low of a level.</span><br><span class="line">- This defines foobar&#x27; as a &quot;pipeline&quot; of three functions. First filter, then apply to every element, eventually sum them up.</span><br><span class="line">- Folds</span><br><span class="line">  - ```Haskell</span><br><span class="line">    fold :: b → (a → b → b) → [a] → b</span><br><span class="line">    fold z f []  = z</span><br><span class="line">    fold z f (x:xs) = f x (fold z f xs)</span><br></pre></td></tr></table></figure></p></li>
<li><p>fold is already provided in the standard Prelude, under the name
of <code>foldr :: (a→b→b) → a → [a] → b</code></p></li>
<li><p>There is also <code>foldl</code>, which folds from the left (use
<code>foldl'</code> from Data.List is more efficient)</p></li>
</ul></li>
</ul>
<h3 id="week-5-more-polymorphism-and-type-classes">Week 5: More
Polymorphism and Type Classes</h3>
<ul>
<li>Parametricity
<ul>
<li><code>a -&gt; a -&gt; a</code> is a promise that <code>a</code>
function with this type will work no matter what type the caller
chooses, otherwise specify the type</li>
</ul></li>
<li>Type classes
<ul>
<li>Num, Eq, Ord and Show are type classes, and we say that
<code>(==)</code>, <code>(&lt;)</code>, <code>(+)</code> are "type-class
polymorphic".</li>
<li><code>deriving (Eq, Ord, Show)</code> Tell GHC to automatically
derive instances of the <code>Eq</code>, <code>Ord</code>, and
<code>Show</code> type classes for our data type.</li>
</ul></li>
<li>Standard type classes
<ul>
<li>Ord: totally ordered, any two elements can be compared to see which
is less than the other.</li>
<li>Num: numeric types, support things like addition, subtraction, and
multiplication.</li>
<li>Show: defines the method Show, which is used to convert values into
Strings</li>
<li>Read: the dual of Show</li>
<li>Integal: represents whole number types such as Int and Integer</li>
</ul></li>
</ul>
<h3 id="week-6-lazy-evaluation">Week 6: Lazy Evaluation</h3>
<ul>
<li>Strict evaluation
<ul>
<li>Opposite to lazy evaluation, function arguments are completely
evaluated before passing them to the function.</li>
</ul></li>
<li>Consequences
<ul>
<li>Purity</li>
<li>To the recursion function, whether the list should be recursed
before processed, or computed first before unwinding.</li>
<li>For example, foldl’ requires the second argument to be evaluated
before it proceeds, so a large thunk never builds up (compared with
function foldl).</li>
</ul></li>
<li>Infinite data structures
<ul>
<li>Lazy evaluation means that we can work with inifinite data
structures. Defining an infinite data structure actually only creates a
thunk, which we can think of as a “seed”, out of which the entire data
structure can potentially grow.</li>
</ul></li>
<li>Dynamic programming
<ul>
<li>One must take great care to fill in entries of a dynamic programming
table in the proper order, so that its dependencies have already been
computed. If we get the order wrong, we gor bogus results.</li>
</ul></li>
</ul>
<h3 id="week-8-io">Week 8: I/O</h3>
<ul>
<li><code>main</code> itself is an I/O action with type IO()</li>
<li><code>do</code> defines a sequence of actions</li>
<li>Combining IO
<ul>
<li><code>(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b</code> ––running two
input computation in sequence</li>
</ul></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/wiki/UPenn-CIS-194-Haskell/" data-id="clgeqbeek0000p0mvhva8edzw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/wiki/Software-Foundations-06-Tactics/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Software Foundations 06 Tactics</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/wiki/UPenn-CIS-194-Haskell/">UPenn CIS 194 Haskell</a>
          </li>
        
          <li>
            <a href="/wiki/Software-Foundations-06-Tactics/">Software Foundations 06 Tactics</a>
          </li>
        
          <li>
            <a href="/wiki/Software-Foundations-05-Poly/">Software Foundations 05 Poly</a>
          </li>
        
          <li>
            <a href="/wiki/Software-Foundations-04-Lists/">Software Foundations 04 Lists</a>
          </li>
        
          <li>
            <a href="/wiki/Sipser-Part-One/">Sipser Part One</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 肖扬<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>